import "./chunk-TWH2WUSA.js";
import {
  __async,
  __commonJS,
  __objRest,
  __require,
  __spreadProps,
  __spreadValues,
  __superGet,
  __toESM
} from "./chunk-KKWNQZCW.js";

// ../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
  }
});

// ../node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "../node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// ../node_modules/typeorm/node_modules/buffer/index.js
var require_buffer = __commonJS({
  "../node_modules/typeorm/node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = {
          foo: function() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E("ERR_INVALID_ARG_TYPE", function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// ../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../node_modules/buffer/index.js
var require_buffer2 = __commonJS({
  "../node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = {
          foo: function() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a === b) return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer3.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer3.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
  }
});

// ../node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer2();
    var Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "../node_modules/sha.js/hash.js"(exports, module) {
    var Buffer3 = require_safe_buffer().Buffer;
    function Hash(blockSize, finalSize) {
      this._block = Buffer3.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash.prototype.update = function(data, enc) {
      if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer3.from(data, enc);
      }
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for (var i = 0; i < remainder; i++) {
          block[assigned + i] = data[offset + i];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash2 = this._hash();
      return enc ? hash2.toString(enc) : hash2;
    };
    Hash.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module.exports = Hash;
  }
});

// ../node_modules/sha.js/sha.js
var require_sha = __commonJS({
  "../node_modules/sha.js/sha.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer3 = require_safe_buffer().Buffer;
    var K = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
    var W = new Array(80);
    function Sha() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha, Hash);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) return b & c | ~b & d;
      if (s === 2) return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i) W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H = Buffer3.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module.exports = Sha;
  }
});

// ../node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "../node_modules/sha.js/sha1.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer3 = require_safe_buffer().Buffer;
    var K = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha1, Hash);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) return b & c | ~b & d;
      if (s === 2) return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha1.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i) W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H = Buffer3.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module.exports = Sha1;
  }
});

// ../node_modules/sha.js/sha256.js
var require_sha256 = __commonJS({
  "../node_modules/sha.js/sha256.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer3 = require_safe_buffer().Buffer;
    var K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    var W = new Array(64);
    function Sha256() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha256, Hash);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
    }
    function sigma1(x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
    }
    function gamma0(x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
    }
    function gamma1(x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
    }
    Sha256.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f2 = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;
      for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
      for (; i < 64; ++i) W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;
      for (var j = 0; j < 64; ++j) {
        var T1 = h + sigma1(e) + ch(e, f2, g) + K[j] + W2[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;
        h = g;
        g = f2;
        f2 = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
      this._f = f2 + this._f | 0;
      this._g = g + this._g | 0;
      this._h = h + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H = Buffer3.allocUnsafe(32);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);
      return H;
    };
    module.exports = Sha256;
  }
});

// ../node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "../node_modules/sha.js/sha224.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Sha256 = require_sha256();
    var Hash = require_hash();
    var Buffer3 = require_safe_buffer().Buffer;
    var W = new Array(64);
    function Sha224() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H = Buffer3.allocUnsafe(28);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      return H;
    };
    module.exports = Sha224;
  }
});

// ../node_modules/sha.js/sha512.js
var require_sha512 = __commonJS({
  "../node_modules/sha.js/sha512.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer3 = require_safe_buffer().Buffer;
    var K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    var W = new Array(160);
    function Sha512() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha512, Hash);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
    }
    function sigma1(x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
    }
    function Gamma0(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
    }
    function Gamma0l(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
    }
    function Gamma1(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
    }
    function Gamma1l(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
    }
    function getCarry(a, b) {
      return a >>> 0 < b >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M) {
      var W2 = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i = 0; i < 32; i += 2) {
        W2[i] = M.readInt32BE(i * 4);
        W2[i + 1] = M.readInt32BE(i * 4 + 4);
      }
      for (; i < 160; i += 2) {
        var xh = W2[i - 15 * 2];
        var xl = W2[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W2[i - 2 * 2];
        xl = W2[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = W2[i - 7 * 2];
        var Wi7l = W2[i - 7 * 2 + 1];
        var Wi16h = W2[i - 16 * 2];
        var Wi16l = W2[i - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W2[i] = Wih;
        W2[i + 1] = Wil;
      }
      for (var j = 0; j < 160; j += 2) {
        Wih = W2[j];
        Wil = W2[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H = Buffer3.allocUnsafe(64);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H;
    };
    module.exports = Sha512;
  }
});

// ../node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "../node_modules/sha.js/sha384.js"(exports, module) {
    var inherits = require_inherits_browser();
    var SHA512 = require_sha512();
    var Hash = require_hash();
    var Buffer3 = require_safe_buffer().Buffer;
    var W = new Array(160);
    function Sha384() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H = Buffer3.allocUnsafe(48);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H;
    };
    module.exports = Sha384;
  }
});

// ../node_modules/sha.js/index.js
var require_sha2 = __commonJS({
  "../node_modules/sha.js/index.js"(exports, module) {
    var exports = module.exports = function SHA(algorithm) {
      algorithm = algorithm.toLowerCase();
      var Algorithm = exports[algorithm];
      if (!Algorithm) throw new Error(algorithm + " is not supported (we accept pull requests)");
      return new Algorithm();
    };
    exports.sha = require_sha();
    exports.sha1 = require_sha1();
    exports.sha224 = require_sha224();
    exports.sha256 = require_sha256();
    exports.sha384 = require_sha384();
    exports.sha512 = require_sha512();
  }
});

// ../node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "../node_modules/dayjs/dayjs.min.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f2 = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = {
        name: "en",
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        ordinal: function(t2) {
          var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
          return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
        }
      }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = {
        s: m,
        z: function(t2) {
          var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
          return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
        },
        m: function t2(e2, n2) {
          if (e2.date() < n2.date()) return -t2(n2, e2);
          var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
          return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
        },
        a: function(t2) {
          return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
        },
        p: function(t2) {
          return {
            M: c,
            y: h,
            w: o,
            d: a,
            D: d,
            h: u,
            m: s,
            s: i,
            ms: r,
            Q: f2
          }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
        },
        u: function(t2) {
          return void 0 === t2;
        }
      }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = function(t2) {
        return t2 instanceof _ || !(!t2 || !t2[p]);
      }, w = function t2(e2, n2, r2) {
        var i2;
        if (!e2) return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1) return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O = function(t2, e2) {
        if (S(t2)) return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, b = v;
      b.l = w, b.i = S, b.w = function(t2, e2) {
        return O(t2, {
          locale: e2.$L,
          utc: e2.$u,
          x: e2.$x,
          $offset: e2.$offset
        });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2) return /* @__PURE__ */ new Date(NaN);
            if (b.u(e2)) return /* @__PURE__ */ new Date();
            if (e2 instanceof Date) return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = O(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return O(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < O(t2);
        }, m2.$g = function(t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f3 = b.p(t2), l2 = function(t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function(t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f3) {
            case h:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = b.p(t2), f3 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f3 + "Date", n2[d] = f3 + "Date", n2[c] = f3 + "Month", n2[h] = f3 + "FullYear", n2[u] = f3 + "Hours", n2[s] = f3 + "Minutes", n2[i] = f3 + "Seconds", n2[r] = f3 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[b.p(t2)]();
        }, m2.add = function(r2, f3) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f3), y2 = function(t2) {
            var e2 = O(l2);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === c) return this.set(c, this.$M + r2);
          if ($2 === h) return this.set(h, this.$y + r2);
          if ($2 === a) return y2(1);
          if ($2 === o) return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid()) return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f3 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function(t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, $2 = f3 || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, function(t3, r3) {
            return r3 || function(t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t3) || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f2:
              $2 = D2() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2) return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t2) {
        k[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), O.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, O), t2.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
        return O(1e3 * t2);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    });
  }
});

// ../node_modules/ms/index.js
var require_ms = __commonJS({
  "../node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../node_modules/debug/src/common.js
var require_common = __commonJS({
  "../node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [...createDebug.names, ...createDebug.skips.map((namespace) => "-" + namespace)].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// ../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var {
      formatters
    } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../node_modules/typeorm/browser/metadata-builder/MetadataUtils.js
var MetadataUtils = class {
  /**
   * Gets given's entity all inherited classes.
   * Gives in order from parents to children.
   * For example Post extends ContentModel which extends Unit it will give
   * [Unit, ContentModel, Post]
   */
  static getInheritanceTree(entity) {
    const tree = [entity];
    const getPrototypeOf = (object) => {
      const proto = Object.getPrototypeOf(object);
      if (proto && proto.name) {
        tree.push(proto);
        getPrototypeOf(proto);
      }
    };
    getPrototypeOf(entity);
    return tree;
  }
  /**
   * Checks if this table is inherited from another table.
   */
  static isInherited(target1, target2) {
    return target1.prototype instanceof target2;
  }
  /**
   * Filters given array of targets by a given classes.
   * If classes are not given, then it returns array itself.
   */
  static filterByTarget(array, classes) {
    if (!classes) return array;
    return array.filter((item) => item.target && classes.indexOf(item.target) !== -1);
  }
};

// ../node_modules/typeorm/browser/metadata-args/MetadataArgsStorage.js
var MetadataArgsStorage = class {
  constructor() {
    this.tables = [];
    this.trees = [];
    this.entityRepositories = [];
    this.transactionEntityManagers = [];
    this.transactionRepositories = [];
    this.namingStrategies = [];
    this.entitySubscribers = [];
    this.indices = [];
    this.uniques = [];
    this.checks = [];
    this.exclusions = [];
    this.columns = [];
    this.generations = [];
    this.relations = [];
    this.joinColumns = [];
    this.joinTables = [];
    this.entityListeners = [];
    this.relationCounts = [];
    this.relationIds = [];
    this.embeddeds = [];
    this.inheritances = [];
    this.discriminatorValues = [];
  }
  filterTables(target) {
    return this.filterByTarget(this.tables, target);
  }
  filterColumns(target) {
    return this.filterByTargetAndWithoutDuplicateProperties(this.columns, target);
  }
  findGenerated(target, propertyName) {
    return this.generations.find((generated) => {
      return (Array.isArray(target) ? target.indexOf(generated.target) !== -1 : generated.target === target) && generated.propertyName === propertyName;
    });
  }
  findTree(target) {
    return this.trees.find((tree) => {
      return Array.isArray(target) ? target.indexOf(tree.target) !== -1 : tree.target === target;
    });
  }
  filterRelations(target) {
    return this.filterByTargetAndWithoutDuplicateRelationProperties(this.relations, target);
  }
  filterRelationIds(target) {
    return this.filterByTargetAndWithoutDuplicateProperties(this.relationIds, target);
  }
  filterRelationCounts(target) {
    return this.filterByTargetAndWithoutDuplicateProperties(this.relationCounts, target);
  }
  filterIndices(target) {
    return this.indices.filter((index) => {
      return Array.isArray(target) ? target.indexOf(index.target) !== -1 : index.target === target;
    });
  }
  filterUniques(target) {
    return this.uniques.filter((unique) => {
      return Array.isArray(target) ? target.indexOf(unique.target) !== -1 : unique.target === target;
    });
  }
  filterChecks(target) {
    return this.checks.filter((check) => {
      return Array.isArray(target) ? target.indexOf(check.target) !== -1 : check.target === target;
    });
  }
  filterExclusions(target) {
    return this.exclusions.filter((exclusion) => {
      return Array.isArray(target) ? target.indexOf(exclusion.target) !== -1 : exclusion.target === target;
    });
  }
  filterListeners(target) {
    return this.filterByTarget(this.entityListeners, target);
  }
  filterEmbeddeds(target) {
    return this.filterByTargetAndWithoutDuplicateEmbeddedProperties(this.embeddeds, target);
  }
  findJoinTable(target, propertyName) {
    return this.joinTables.find((joinTable) => {
      return joinTable.target === target && joinTable.propertyName === propertyName;
    });
  }
  filterJoinColumns(target, propertyName) {
    return this.joinColumns.filter((joinColumn) => {
      return joinColumn.target === target && joinColumn.propertyName === propertyName;
    });
  }
  filterSubscribers(target) {
    return this.filterByTarget(this.entitySubscribers, target);
  }
  filterNamingStrategies(target) {
    return this.filterByTarget(this.namingStrategies, target);
  }
  filterTransactionEntityManagers(target, propertyName) {
    return this.transactionEntityManagers.filter((transactionEm) => {
      return (Array.isArray(target) ? target.indexOf(transactionEm.target) !== -1 : transactionEm.target === target) && transactionEm.methodName === propertyName;
    });
  }
  filterTransactionRepository(target, propertyName) {
    return this.transactionRepositories.filter((transactionEm) => {
      return (Array.isArray(target) ? target.indexOf(transactionEm.target) !== -1 : transactionEm.target === target) && transactionEm.methodName === propertyName;
    });
  }
  filterSingleTableChildren(target) {
    return this.tables.filter((table) => {
      return typeof table.target === "function" && typeof target === "function" && MetadataUtils.isInherited(table.target, target) && table.type === "entity-child";
    });
  }
  findInheritanceType(target) {
    return this.inheritances.find((inheritance) => inheritance.target === target);
  }
  findDiscriminatorValue(target) {
    return this.discriminatorValues.find((discriminatorValue) => discriminatorValue.target === target);
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Filters given array by a given target or targets.
   */
  filterByTarget(array, target) {
    return array.filter((table) => {
      return Array.isArray(target) ? target.indexOf(table.target) !== -1 : table.target === target;
    });
  }
  /**
   * Filters given array by a given target or targets and prevents duplicate property names.
   */
  filterByTargetAndWithoutDuplicateProperties(array, target) {
    const newArray = [];
    array.forEach((item) => {
      const sameTarget = Array.isArray(target) ? target.indexOf(item.target) !== -1 : item.target === target;
      if (sameTarget) {
        if (!newArray.find((newItem) => newItem.propertyName === item.propertyName)) newArray.push(item);
      }
    });
    return newArray;
  }
  /**
   * Filters given array by a given target or targets and prevents duplicate relation property names.
   */
  filterByTargetAndWithoutDuplicateRelationProperties(array, target) {
    const newArray = [];
    array.forEach((item) => {
      const sameTarget = Array.isArray(target) ? target.indexOf(item.target) !== -1 : item.target === target;
      if (sameTarget) {
        const existingIndex = newArray.findIndex((newItem) => newItem.propertyName === item.propertyName);
        if (Array.isArray(target) && existingIndex !== -1 && target.indexOf(item.target) < target.indexOf(newArray[existingIndex].target)) {
          const clone = Object.create(newArray[existingIndex]);
          clone.type = item.type;
          newArray[existingIndex] = clone;
        } else if (existingIndex === -1) {
          newArray.push(item);
        }
      }
    });
    return newArray;
  }
  /**
   * Filters given array by a given target or targets and prevents duplicate embedded property names.
   */
  filterByTargetAndWithoutDuplicateEmbeddedProperties(array, target) {
    const newArray = [];
    array.forEach((item) => {
      const sameTarget = Array.isArray(target) ? target.indexOf(item.target) !== -1 : item.target === target;
      if (sameTarget) {
        const isDuplicateEmbeddedProperty = newArray.find((newItem) => newItem.prefix === item.prefix && newItem.propertyName === item.propertyName);
        if (!isDuplicateEmbeddedProperty) newArray.push(item);
      }
    });
    return newArray;
  }
};

// ../node_modules/typeorm/browser/platform/BrowserPlatformTools.js
var import_buffer = __toESM(require_buffer());
var PlatformTools = class {
  /**
   * Gets global variable where global stuff can be stored.
   */
  static getGlobalVariable() {
    if (typeof window !== "undefined") {
      return window;
    } else {
      return global;
    }
  }
  /**
   * Loads ("require"-s) given file or package.
   * This operation only supports on node platform
   */
  static load(name) {
    if (this.type === "browser") throw new Error(`This option/function is not supported in the browser environment. Failed operation: require("${name}").`);
    return "";
  }
  /**
   * Normalizes given path. Does "path.normalize".
   */
  static pathNormalize(pathStr) {
    if (this.type === "browser") throw new Error(`This option/function is not supported in the browser environment. Failed operation: path.normalize("${pathStr}").`);
    return "";
  }
  /**
   * Gets file extension. Does "path.extname".
   */
  static pathExtname(pathStr) {
    if (this.type === "browser") throw new Error(`This option/function is not supported in the browser environment. Failed operation: path.extname("${pathStr}").`);
    return "";
  }
  /**
   * Resolved given path. Does "path.resolve".
   */
  static pathResolve(pathStr) {
    if (this.type === "browser") throw new Error(`This option/function is not supported in the browser environment. Failed operation: path.resolve("${pathStr}").`);
    return "";
  }
  /**
   * Synchronously checks if file exist. Does "fs.existsSync".
   */
  static fileExist(pathStr) {
    if (this.type === "browser") throw new Error(`This option/function is not supported in the browser environment. Failed operation: fs.existsSync("${pathStr}").`);
    return false;
  }
  static dotenv(pathStr) {
    if (this.type === "browser") throw new Error(`This option/function is not supported in the browser environment. Failed operation: dotenv.config({ path: "${pathStr}" }).`);
  }
  /**
   * Gets environment variable.
   */
  static getEnvVariable(name) {
    return void 0;
  }
  static readFileSync(filename) {
    if (this.type === "browser") throw new Error(`This option/function is not supported in the browser environment. Failed operation: fs.readFileSync("${filename}").`);
    return null;
  }
  static appendFileSync(filename, data) {
    if (this.type === "browser") throw new Error(`This option/function is not supported in the browser environment. Failed operation: fs.appendFileSync("${filename}").`);
  }
  static writeFile(path, data) {
    if (this.type === "browser") throw new Error(`This option/function is not supported in the browser environment. Failed operation: fs.writeFile("${path}").`);
    return Promise.reject(null);
  }
  /**
   * Highlights sql string to be printed in the console.
   */
  static highlightSql(sql) {
    return sql;
  }
  /**
   * Logging functions needed by AdvancedConsoleLogger (but here without ANSI colors)
   */
  static logInfo(prefix, info) {
    console.info(prefix + " ", info);
  }
  static logError(prefix, error) {
    console.error(prefix + " ", error);
  }
  static logWarn(prefix, warning) {
    console.warn(prefix + " ", warning);
  }
  static log(message) {
    console.log(message);
  }
  static warn(message) {
    return message;
  }
};
PlatformTools.type = "browser";
if (typeof window !== "undefined") {
  window.Buffer = import_buffer.Buffer;
}
if (typeof global !== "undefined" && typeof __require !== "undefined") {
  global.Buffer = require_buffer().Buffer;
}

// ../node_modules/typeorm/browser/platform/BrowserConnectionOptionsReaderDummy.js
var ConnectionOptionsReader = class {
  all() {
    return __async(this, null, function* () {
      throw new Error(`Cannot read connection options in a browser context.`);
    });
  }
  get() {
    return __async(this, null, function* () {
      throw new Error(`Cannot read connection options in a browser context.`);
    });
  }
  has() {
    return __async(this, null, function* () {
      throw new Error(`Cannot read connection options in a browser context.`);
    });
  }
};

// ../node_modules/typeorm/browser/util/ObjectUtils.js
var ObjectUtils = class {
  /**
   * Checks if given value is an object.
   * We cannot use instanceof because it has problems when running on different contexts.
   * And we don't simply use typeof because typeof null === "object".
   */
  static isObject(val) {
    return val !== null && typeof val === "object";
  }
  /**
   * Checks if given value is an object.
   * We cannot use instanceof because it has problems when running on different contexts.
   * And we don't simply use typeof because typeof null === "object".
   */
  static isObjectWithName(val) {
    return val !== null && typeof val === "object" && val["name"] !== void 0;
  }
  /**
   * Copy the values of all of the enumerable own properties from one or more source objects to a
   * target object.
   * @param target The target object to copy to.
   * @param sources One or more source objects from which to copy properties
   */
  static assign(target, ...sources) {
    for (const source of sources) {
      for (const prop of Object.getOwnPropertyNames(source)) {
        ;
        target[prop] = source[prop];
      }
    }
  }
  /**
   * Converts MixedList<T> to strictly an array of its T items.
   */
  static mixedListToArray(list) {
    if (list !== null && typeof list === "object") {
      return Object.keys(list).map((key) => list[key]);
    } else {
      return list;
    }
  }
};

// ../node_modules/typeorm/browser/error/TypeORMError.js
var TypeORMError = class extends Error {
  get name() {
    return this.constructor.name;
  }
  constructor(message) {
    super(message);
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, new.target.prototype);
    } else {
      ;
      this.__proto__ = new.target.prototype;
    }
  }
};

// ../node_modules/typeorm/browser/error/CannotReflectMethodParameterTypeError.js
var CannotReflectMethodParameterTypeError = class extends TypeORMError {
  constructor(target, methodName) {
    super(`Cannot get reflected type for a "${methodName}" method's parameter of "${target.name}" class. Make sure you have turned on an "emitDecoratorMetadata": true option in tsconfig.json. Also make sure you have imported "reflect-metadata" on top of the main entry file in your application.`);
  }
};

// ../node_modules/typeorm/browser/error/AlreadyHasActiveConnectionError.js
var AlreadyHasActiveConnectionError = class extends TypeORMError {
  constructor(connectionName) {
    super(`Cannot create a new connection named "${connectionName}", because connection with such name already exist and it now has an active connection session.`);
  }
};

// ../node_modules/typeorm/browser/error/SubjectWithoutIdentifierError.js
var SubjectWithoutIdentifierError = class extends TypeORMError {
  constructor(subject) {
    super(`Internal error. Subject ${subject.metadata.targetName} must have an identifier to perform operation.`);
  }
};

// ../node_modules/typeorm/browser/error/CannotConnectAlreadyConnectedError.js
var CannotConnectAlreadyConnectedError = class extends TypeORMError {
  constructor(connectionName) {
    super(`Cannot create a "${connectionName}" connection because connection to the database already established.`);
  }
};

// ../node_modules/typeorm/browser/error/LockNotSupportedOnGivenDriverError.js
var LockNotSupportedOnGivenDriverError = class extends TypeORMError {
  constructor() {
    super(`Locking not supported on given driver.`);
  }
};

// ../node_modules/typeorm/browser/error/ConnectionIsNotSetError.js
var ConnectionIsNotSetError = class extends TypeORMError {
  constructor(dbType) {
    super(`Connection with ${dbType} database is not established. Check connection configuration.`);
  }
};

// ../node_modules/typeorm/browser/error/CannotCreateEntityIdMapError.js
var CannotCreateEntityIdMapError = class extends TypeORMError {
  constructor(metadata, id) {
    super();
    const objectExample = metadata.primaryColumns.reduce((object, column, index) => {
      column.setEntityValue(object, index + 1);
      return object;
    }, {});
    this.message = `Cannot use given entity id "${id}" because "${metadata.targetName}" contains multiple primary columns, you must provide object in following form: ${JSON.stringify(objectExample)} as an id.`;
  }
};

// ../node_modules/typeorm/browser/error/MetadataAlreadyExistsError.js
var MetadataAlreadyExistsError = class extends TypeORMError {
  constructor(metadataType, constructor, propertyName) {
    super(metadataType + " metadata already exists for the class constructor " + JSON.stringify(constructor) + (propertyName ? " on property " + propertyName : ". If you previously renamed or moved entity class, make sure that compiled version of old entity class source wasn't left in the compiler output directory."));
  }
};

// ../node_modules/typeorm/browser/error/CannotDetermineEntityError.js
var CannotDetermineEntityError = class extends TypeORMError {
  constructor(operation) {
    super(`Cannot ${operation}, given value must be instance of entity class, instead object literal is given. Or you must specify an entity target to method call.`);
  }
};

// ../node_modules/typeorm/browser/error/UpdateValuesMissingError.js
var UpdateValuesMissingError = class extends TypeORMError {
  constructor() {
    super(`Cannot perform update query because update values are not defined. Call "qb.set(...)" method to specify updated values.`);
  }
};

// ../node_modules/typeorm/browser/error/TreeRepositoryNotSupportedError.js
var TreeRepositoryNotSupportedError = class extends TypeORMError {
  constructor(driver) {
    super(`Tree repositories are not supported in ${driver.options.type} driver.`);
  }
};

// ../node_modules/typeorm/browser/error/CustomRepositoryNotFoundError.js
var CustomRepositoryNotFoundError = class extends TypeORMError {
  constructor(repository) {
    super(`Custom repository ${typeof repository === "function" ? repository.name : repository.constructor.name} was not found. Did you forgot to put @EntityRepository decorator on it?`);
  }
};

// ../node_modules/typeorm/browser/error/TransactionNotStartedError.js
var TransactionNotStartedError = class extends TypeORMError {
  constructor() {
    super(`Transaction is not started yet, start transaction before committing or rolling it back.`);
  }
};

// ../node_modules/typeorm/browser/error/TransactionAlreadyStartedError.js
var TransactionAlreadyStartedError = class extends TypeORMError {
  constructor() {
    super(`Transaction already started for the given connection, commit current transaction before starting a new one.`);
  }
};

// ../node_modules/typeorm/browser/util/InstanceChecker.js
var InstanceChecker = class {
  static isMssqlParameter(obj) {
    return this.check(obj, "MssqlParameter");
  }
  static isEntityMetadata(obj) {
    return this.check(obj, "EntityMetadata");
  }
  static isColumnMetadata(obj) {
    return this.check(obj, "ColumnMetadata");
  }
  static isSelectQueryBuilder(obj) {
    return this.check(obj, "SelectQueryBuilder");
  }
  static isInsertQueryBuilder(obj) {
    return this.check(obj, "InsertQueryBuilder");
  }
  static isDeleteQueryBuilder(obj) {
    return this.check(obj, "DeleteQueryBuilder");
  }
  static isUpdateQueryBuilder(obj) {
    return this.check(obj, "UpdateQueryBuilder");
  }
  static isSoftDeleteQueryBuilder(obj) {
    return this.check(obj, "SoftDeleteQueryBuilder");
  }
  static isRelationQueryBuilder(obj) {
    return this.check(obj, "RelationQueryBuilder");
  }
  static isBrackets(obj) {
    return this.check(obj, "Brackets") || this.check(obj, "NotBrackets");
  }
  static isNotBrackets(obj) {
    return this.check(obj, "NotBrackets");
  }
  static isSubject(obj) {
    return this.check(obj, "Subject");
  }
  static isRdbmsSchemaBuilder(obj) {
    return this.check(obj, "RdbmsSchemaBuilder");
  }
  static isMongoEntityManager(obj) {
    return this.check(obj, "MongoEntityManager");
  }
  static isSqljsEntityManager(obj) {
    return this.check(obj, "SqljsEntityManager");
  }
  static isEntitySchema(obj) {
    return this.check(obj, "EntitySchema");
  }
  static isBaseEntityConstructor(obj) {
    return typeof obj === "function" && typeof obj.hasId === "function" && typeof obj.save === "function" && typeof obj.useDataSource === "function";
  }
  static isFindOperator(obj) {
    return this.check(obj, "FindOperator") || this.check(obj, "EqualOperator");
  }
  static isEqualOperator(obj) {
    return this.check(obj, "EqualOperator");
  }
  static isQuery(obj) {
    return this.check(obj, "Query");
  }
  static isTable(obj) {
    return this.check(obj, "Table");
  }
  static isTableCheck(obj) {
    return this.check(obj, "TableCheck");
  }
  static isTableColumn(obj) {
    return this.check(obj, "TableColumn");
  }
  static isTableExclusion(obj) {
    return this.check(obj, "TableExclusion");
  }
  static isTableForeignKey(obj) {
    return this.check(obj, "TableForeignKey");
  }
  static isTableIndex(obj) {
    return this.check(obj, "TableIndex");
  }
  static isTableUnique(obj) {
    return this.check(obj, "TableUnique");
  }
  static isView(obj) {
    return this.check(obj, "View");
  }
  static isDataSource(obj) {
    return this.check(obj, "DataSource");
  }
  static check(obj, name) {
    return typeof obj === "object" && obj !== null && obj["@instanceof"] === Symbol.for(name);
  }
};

// ../node_modules/typeorm/browser/error/EntityNotFoundError.js
var EntityNotFoundError = class extends TypeORMError {
  constructor(entityClass, criteria) {
    super();
    this.entityClass = entityClass;
    this.criteria = criteria;
    this.message = `Could not find any entity of type "${this.stringifyTarget(entityClass)}" matching: ${this.stringifyCriteria(criteria)}`;
  }
  stringifyTarget(target) {
    if (InstanceChecker.isEntitySchema(target)) {
      return target.options.name;
    } else if (typeof target === "function") {
      return target.name;
    } else if (ObjectUtils.isObject(target) && "name" in target) {
      return target.name;
    } else {
      return target;
    }
  }
  stringifyCriteria(criteria) {
    try {
      return JSON.stringify(criteria, null, 4);
    } catch (e) {
    }
    return "" + criteria;
  }
};

// ../node_modules/typeorm/browser/error/EntityMetadataNotFoundError.js
var EntityMetadataNotFoundError = class extends TypeORMError {
  constructor(target) {
    super();
    this.message = `No metadata for "${this.stringifyTarget(target)}" was found.`;
  }
  stringifyTarget(target) {
    if (InstanceChecker.isEntitySchema(target)) {
      return target.options.name;
    } else if (typeof target === "function") {
      return target.name;
    } else if (ObjectUtils.isObject(target) && "name" in target) {
      return target.name;
    } else {
      return target;
    }
  }
};

// ../node_modules/typeorm/browser/error/MustBeEntityError.js
var MustBeEntityError = class extends TypeORMError {
  constructor(operation, wrongValue) {
    super(`Cannot ${operation}, given value must be an entity, instead "${wrongValue}" is given.`);
  }
};

// ../node_modules/typeorm/browser/error/OptimisticLockVersionMismatchError.js
var OptimisticLockVersionMismatchError = class extends TypeORMError {
  constructor(entity, expectedVersion, actualVersion) {
    super(`The optimistic lock on entity ${entity} failed, version ${expectedVersion} was expected, but is actually ${actualVersion}.`);
  }
};

// ../node_modules/typeorm/browser/error/LimitOnUpdateNotSupportedError.js
var LimitOnUpdateNotSupportedError = class extends TypeORMError {
  constructor() {
    super(`Your database does not support LIMIT on UPDATE statements.`);
  }
};

// ../node_modules/typeorm/browser/error/PrimaryColumnCannotBeNullableError.js
var PrimaryColumnCannotBeNullableError = class extends TypeORMError {
  constructor(object, propertyName) {
    super(`Primary column ${object.constructor.name}#${propertyName} cannot be nullable. Its not allowed for primary keys. Try to remove nullable option.`);
  }
};

// ../node_modules/typeorm/browser/error/CustomRepositoryCannotInheritRepositoryError.js
var CustomRepositoryCannotInheritRepositoryError = class extends TypeORMError {
  constructor(repository) {
    super(`Custom entity repository ${typeof repository === "function" ? repository.name : repository.constructor.name}  cannot inherit Repository class without entity being set in the @EntityRepository decorator.`);
  }
};

// ../node_modules/typeorm/browser/error/QueryRunnerProviderAlreadyReleasedError.js
var QueryRunnerProviderAlreadyReleasedError = class extends TypeORMError {
  constructor() {
    super(`Database connection provided by a query runner was already released, cannot continue to use its querying methods anymore.`);
  }
};

// ../node_modules/typeorm/browser/error/CannotAttachTreeChildrenEntityError.js
var CannotAttachTreeChildrenEntityError = class extends TypeORMError {
  constructor(entityName) {
    super(`Cannot attach entity "${entityName}" to its parent. Please make sure parent is saved in the database before saving children nodes.`);
  }
};

// ../node_modules/typeorm/browser/error/CustomRepositoryDoesNotHaveEntityError.js
var CustomRepositoryDoesNotHaveEntityError = class extends TypeORMError {
  constructor(repository) {
    super(`Custom repository ${typeof repository === "function" ? repository.name : repository.constructor.name} does not have managed entity. Did you forget to specify entity for it @EntityRepository(MyEntity)? `);
  }
};

// ../node_modules/typeorm/browser/error/MissingDeleteDateColumnError.js
var MissingDeleteDateColumnError = class extends TypeORMError {
  constructor(entityMetadata) {
    super(`Entity "${entityMetadata.name}" does not have delete date columns.`);
  }
};

// ../node_modules/typeorm/browser/error/NoConnectionForRepositoryError.js
var NoConnectionForRepositoryError = class extends TypeORMError {
  constructor(connectionName) {
    super(`Cannot get a Repository for "${connectionName} connection, because connection with the database is not established yet. Call connection#connect method to establish connection.`);
  }
};

// ../node_modules/typeorm/browser/error/CircularRelationsError.js
var CircularRelationsError = class extends TypeORMError {
  constructor(path) {
    super(`Circular relations detected: ${path}. To resolve this issue you need to set nullable: true somewhere in this dependency structure.`);
  }
};

// ../node_modules/typeorm/browser/error/ReturningStatementNotSupportedError.js
var ReturningStatementNotSupportedError = class extends TypeORMError {
  constructor() {
    super(`OUTPUT or RETURNING clause only supported by Microsoft SQL Server or PostgreSQL or MariaDB databases.`);
  }
};

// ../node_modules/typeorm/browser/error/UsingJoinTableIsNotAllowedError.js
var UsingJoinTableIsNotAllowedError = class extends TypeORMError {
  constructor(entityMetadata, relation) {
    super(`Using JoinTable on ${entityMetadata.name}#${relation.propertyName} is wrong. ${entityMetadata.name}#${relation.propertyName} has ${relation.relationType} relation, however you can use JoinTable only on many-to-many relations.`);
  }
};

// ../node_modules/typeorm/browser/error/MissingJoinColumnError.js
var MissingJoinColumnError = class extends TypeORMError {
  constructor(entityMetadata, relation) {
    super();
    if (relation.inverseRelation) {
      this.message = `JoinColumn is missing on both sides of ${entityMetadata.name}#${relation.propertyName} and ${relation.inverseEntityMetadata.name}#${relation.inverseRelation.propertyName} one-to-one relationship. You need to put JoinColumn decorator on one of the sides.`;
    } else {
      this.message = `JoinColumn is missing on ${entityMetadata.name}#${relation.propertyName} one-to-one relationship. You need to put JoinColumn decorator on it.`;
    }
  }
};

// ../node_modules/typeorm/browser/error/MissingPrimaryColumnError.js
var MissingPrimaryColumnError = class extends TypeORMError {
  constructor(entityMetadata) {
    super(`Entity "${entityMetadata.name}" does not have a primary column. Primary column is required to have in all your entities. Use @PrimaryColumn decorator to add a primary column to your entity.`);
  }
};

// ../node_modules/typeorm/browser/error/EntityPropertyNotFoundError.js
var EntityPropertyNotFoundError = class _EntityPropertyNotFoundError extends TypeORMError {
  constructor(propertyPath, metadata) {
    super(propertyPath);
    Object.setPrototypeOf(this, _EntityPropertyNotFoundError.prototype);
    this.message = `Property "${propertyPath}" was not found in "${metadata.targetName}". Make sure your query is correct.`;
  }
};

// ../node_modules/typeorm/browser/error/MissingDriverError.js
var MissingDriverError = class extends TypeORMError {
  constructor(driverType, availableDrivers = []) {
    super(`Wrong driver: "${driverType}" given. Supported drivers are: ${availableDrivers.map((d) => `"${d}"`).join(", ")}.`);
  }
};

// ../node_modules/typeorm/browser/error/DriverPackageNotInstalledError.js
var DriverPackageNotInstalledError = class extends TypeORMError {
  constructor(driverName, packageName) {
    super(`${driverName} package has not been found installed. Try to install it: npm install ${packageName} --save`);
  }
};

// ../node_modules/typeorm/browser/error/CannotGetEntityManagerNotConnectedError.js
var CannotGetEntityManagerNotConnectedError = class extends TypeORMError {
  constructor(connectionName) {
    super(`Cannot get entity manager for "${connectionName}" connection because connection is not yet established.`);
  }
};

// ../node_modules/typeorm/browser/error/ConnectionNotFoundError.js
var ConnectionNotFoundError = class extends TypeORMError {
  constructor(name) {
    super(`Connection "${name}" was not found.`);
  }
};

// ../node_modules/typeorm/browser/error/NoVersionOrUpdateDateColumnError.js
var NoVersionOrUpdateDateColumnError = class extends TypeORMError {
  constructor(entity) {
    super(`Entity ${entity} does not have version or update date columns.`);
  }
};

// ../node_modules/typeorm/browser/error/InsertValuesMissingError.js
var InsertValuesMissingError = class extends TypeORMError {
  constructor() {
    super(`Cannot perform insert query because values are not defined. Call "qb.values(...)" method to specify inserted values.`);
  }
};

// ../node_modules/typeorm/browser/error/OptimisticLockCanNotBeUsedError.js
var OptimisticLockCanNotBeUsedError = class extends TypeORMError {
  constructor() {
    super(`The optimistic lock can be used only with getOne() method.`);
  }
};

// ../node_modules/typeorm/browser/error/MetadataWithSuchNameAlreadyExistsError.js
var MetadataWithSuchNameAlreadyExistsError = class extends TypeORMError {
  constructor(metadataType, name) {
    super(metadataType + " metadata with such name " + name + " already exists. Do you apply decorator twice? Or maybe try to change a name?");
  }
};

// ../node_modules/typeorm/browser/error/DriverOptionNotSetError.js
var DriverOptionNotSetError = class extends TypeORMError {
  constructor(optionName) {
    super(`Driver option (${optionName}) is not set. Please set it to perform connection to the database.`);
  }
};

// ../node_modules/typeorm/browser/error/FindRelationsNotFoundError.js
var FindRelationsNotFoundError = class extends TypeORMError {
  constructor(notFoundRelations) {
    super();
    if (notFoundRelations.length === 1) {
      this.message = `Relation "${notFoundRelations[0]}" was not found; please check if it is correct and really exists in your entity.`;
    } else {
      this.message = `Relations ${notFoundRelations.map((relation) => `"${relation}"`).join(", ")} were not found; please check if relations are correct and they exist in your entities.`;
    }
  }
};

// ../node_modules/typeorm/browser/error/NamingStrategyNotFoundError.js
var NamingStrategyNotFoundError = class extends TypeORMError {
  constructor(strategyName, connectionName) {
    super();
    const name = typeof strategyName === "function" ? strategyName.name : strategyName;
    this.message = `Naming strategy "${name}" was not found. Looks like this naming strategy does not exist or it was not registered in current "${connectionName}" connection?`;
  }
};

// ../node_modules/typeorm/browser/error/PessimisticLockTransactionRequiredError.js
var PessimisticLockTransactionRequiredError = class extends TypeORMError {
  constructor() {
    super(`An open transaction is required for pessimistic lock.`);
  }
};

// ../node_modules/typeorm/browser/error/RepositoryNotTreeError.js
var RepositoryNotTreeError = class extends TypeORMError {
  constructor(entityClass) {
    super();
    let targetName;
    if (InstanceChecker.isEntitySchema(entityClass)) {
      targetName = entityClass.options.name;
    } else if (typeof entityClass === "function") {
      targetName = entityClass.name;
    } else if (ObjectUtils.isObject(entityClass) && "name" in entityClass) {
      targetName = entityClass.name;
    } else {
      targetName = entityClass;
    }
    this.message = `Repository of the "${targetName}" class is not a TreeRepository. Try to apply @Tree decorator on your entity.`;
  }
};

// ../node_modules/typeorm/browser/error/DataTypeNotSupportedError.js
var DataTypeNotSupportedError = class extends TypeORMError {
  constructor(column, dataType, database) {
    super();
    const type = typeof dataType === "string" ? dataType : dataType.name;
    this.message = `Data type "${type}" in "${column.entityMetadata.targetName}.${column.propertyName}" is not supported by "${database}" database.`;
  }
};

// ../node_modules/typeorm/browser/error/InitializedRelationError.js
var InitializedRelationError = class extends TypeORMError {
  constructor(relation) {
    super(`Array initializations are not allowed in entity relations. Please remove array initialization (= []) from "${relation.entityMetadata.targetName}#${relation.propertyPath}". This is ORM requirement to make relations to work properly. Refer docs for more information.`);
  }
};

// ../node_modules/typeorm/browser/error/MissingJoinTableError.js
var MissingJoinTableError = class extends TypeORMError {
  constructor(entityMetadata, relation) {
    super();
    if (relation.inverseRelation) {
      this.message = `JoinTable is missing on both sides of ${entityMetadata.name}#${relation.propertyName} and ${relation.inverseEntityMetadata.name}#${relation.inverseRelation.propertyName} many-to-many relationship. You need to put decorator decorator on one of the sides.`;
    } else {
      this.message = `JoinTable is missing on ${entityMetadata.name}#${relation.propertyName} many-to-many relationship. You need to put JoinTable decorator on it.`;
    }
  }
};

// ../node_modules/typeorm/browser/error/QueryFailedError.js
var QueryFailedError = class extends TypeORMError {
  constructor(query, parameters, driverError) {
    super(driverError.toString().replace(/^error: /, "").replace(/^Error: /, "").replace(/^Request/, ""));
    this.query = query;
    this.parameters = parameters;
    this.driverError = driverError;
    if (driverError) {
      const _a = driverError, {
        name: _
      } = _a, otherProperties = __objRest(_a, [
        "name"
      ]);
      ObjectUtils.assign(this, __spreadValues({}, otherProperties));
    }
  }
};

// ../node_modules/typeorm/browser/error/NoNeedToReleaseEntityManagerError.js
var NoNeedToReleaseEntityManagerError = class extends TypeORMError {
  constructor() {
    super(`Entity manager is not using single database connection and cannot be released. Only entity managers created by connection#createEntityManagerWithSingleDatabaseConnection methods have a single database connection and they should be released.`);
  }
};

// ../node_modules/typeorm/browser/error/UsingJoinColumnOnlyOnOneSideAllowedError.js
var UsingJoinColumnOnlyOnOneSideAllowedError = class extends TypeORMError {
  constructor(entityMetadata, relation) {
    super(`Using JoinColumn is allowed only on one side of the one-to-one relationship. Both ${entityMetadata.name}#${relation.propertyName} and ${relation.inverseEntityMetadata.name}#${relation.inverseRelation.propertyName} has JoinTable decorators. Choose one of them and left JoinTable decorator only on it.`);
  }
};

// ../node_modules/typeorm/browser/error/UsingJoinTableOnlyOnOneSideAllowedError.js
var UsingJoinTableOnlyOnOneSideAllowedError = class extends TypeORMError {
  constructor(entityMetadata, relation) {
    super(`Using JoinTable is allowed only on one side of the many-to-many relationship. Both ${entityMetadata.name}#${relation.propertyName} and ${relation.inverseEntityMetadata.name}#${relation.inverseRelation.propertyName} has JoinTable decorators. Choose one of them and left JoinColumn decorator only on it.`);
  }
};

// ../node_modules/typeorm/browser/error/SubjectRemovedAndUpdatedError.js
var SubjectRemovedAndUpdatedError = class extends TypeORMError {
  constructor(subject) {
    super(`Removed entity "${subject.metadata.name}" is also scheduled for update operation. Make sure you are not updating and removing same object (note that update or remove may be executed by cascade operations).`);
  }
};

// ../node_modules/typeorm/browser/error/PersistedEntityNotFoundError.js
var PersistedEntityNotFoundError = class extends TypeORMError {
  constructor() {
    super(`Internal error. Persisted entity was not found in the list of prepared operated entities.`);
  }
};

// ../node_modules/typeorm/browser/error/UsingJoinColumnIsNotAllowedError.js
var UsingJoinColumnIsNotAllowedError = class extends TypeORMError {
  constructor(entityMetadata, relation) {
    super(`Using JoinColumn on ${entityMetadata.name}#${relation.propertyName} is wrong. You can use JoinColumn only on one-to-one and many-to-one relations.`);
  }
};

// ../node_modules/typeorm/browser/error/ColumnTypeUndefinedError.js
var ColumnTypeUndefinedError = class extends TypeORMError {
  constructor(object, propertyName) {
    super(`Column type for ${object.constructor.name}#${propertyName} is not defined and cannot be guessed. Make sure you have turned on an "emitDecoratorMetadata": true option in tsconfig.json. Also make sure you have imported "reflect-metadata" on top of the main entry file in your application (before any entity imported).If you are using JavaScript instead of TypeScript you must explicitly provide a column type.`);
  }
};

// ../node_modules/typeorm/browser/error/QueryRunnerAlreadyReleasedError.js
var QueryRunnerAlreadyReleasedError = class extends TypeORMError {
  constructor() {
    super(`Query runner already released. Cannot run queries anymore.`);
  }
};

// ../node_modules/typeorm/browser/error/OffsetWithoutLimitNotSupportedError.js
var OffsetWithoutLimitNotSupportedError = class extends TypeORMError {
  constructor() {
    super(`RDBMS does not support OFFSET without LIMIT in SELECT statements. You must use limit in conjunction with offset function (or take in conjunction with skip function if you are using pagination).`);
  }
};

// ../node_modules/typeorm/browser/error/CannotExecuteNotConnectedError.js
var CannotExecuteNotConnectedError = class extends TypeORMError {
  constructor(connectionName) {
    super(`Cannot execute operation on "${connectionName}" connection because connection is not yet established.`);
  }
};

// ../node_modules/typeorm/browser/error/NoConnectionOptionError.js
var NoConnectionOptionError = class extends TypeORMError {
  constructor(optionName) {
    super(`Option "${optionName}" is not set in your connection options, please define "${optionName}" option in your connection options or ormconfig.json`);
  }
};

// ../node_modules/typeorm/browser/error/ForbiddenTransactionModeOverrideError.js
var ForbiddenTransactionModeOverrideError = class extends TypeORMError {
  constructor(migrationsOverridingTransactionMode) {
    const migrationNames = migrationsOverridingTransactionMode.map((migration) => `"${migration.name}"`);
    super(`Migrations ${migrationNames.join(", ")} override the transaction mode, but the global transaction mode is "all"`);
  }
};

// ../node_modules/typeorm/browser/query-builder/Alias.js
var Alias = class {
  constructor(alias) {
    ObjectUtils.assign(this, alias || {});
  }
  get target() {
    return this.metadata.target;
  }
  get hasMetadata() {
    return !!this._metadata;
  }
  set metadata(metadata) {
    this._metadata = metadata;
  }
  get metadata() {
    if (!this._metadata) throw new TypeORMError(`Cannot get entity metadata for the given alias "${this.name}"`);
    return this._metadata;
  }
};

// ../node_modules/typeorm/browser/query-builder/QueryBuilderUtils.js
var QueryBuilderUtils = class {
  /**
   * Checks if given value is a string representation of alias property,
   * e.g. "post.category" or "post.id".
   */
  static isAliasProperty(str) {
    if (typeof str !== "string" || str.indexOf(".") === -1) return false;
    const [aliasName, propertyName] = str.split(".");
    if (!aliasName || !propertyName) return false;
    if (str.indexOf("(") !== -1 || str.indexOf(")") !== -1) return false;
    return true;
  }
};

// ../node_modules/typeorm/browser/util/StringUtils.js
var import_sha = __toESM(require_sha2());
function camelCase(str, firstCapital = false) {
  if (firstCapital) str = " " + str;
  return str.replace(/^([A-Z])|[\s-_](\w)/g, function(match, p1, p2) {
    if (p2) return p2.toUpperCase();
    return p1.toLowerCase();
  });
}
function snakeCase(str) {
  return str.replace(/([A-Z])([A-Z])([a-z])/g, "$1_$2$3").replace(/([a-z0-9])([A-Z])/g, "$1_$2").toLowerCase();
}
function titleCase(str) {
  return str.replace(/\w\S*/g, (txt) => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());
}
function shorten(input, options = {}) {
  const {
    segmentLength = 4,
    separator = "__",
    termLength = 2
  } = options;
  const segments = input.split(separator);
  const shortSegments = segments.reduce((acc, val) => {
    const segmentTerms = val.replace(/([a-z\xE0-\xFF])([A-Z\xC0-\xDF])/g, "$1 $2").split(" ");
    const length = segmentTerms.length > 1 ? termLength : segmentLength;
    const shortSegment = segmentTerms.map((term) => term.substr(0, length)).join("");
    acc.push(shortSegment);
    return acc;
  }, []);
  return shortSegments.join(separator);
}
function hash(input, options = {}) {
  const hashFunction = (0, import_sha.default)("sha1");
  hashFunction.update(input, "utf8");
  const hashedInput = hashFunction.digest("hex");
  if (options.length) {
    return hashedInput.slice(0, options.length);
  }
  return hashedInput;
}

// ../node_modules/typeorm/browser/util/VersionUtils.js
var VersionUtils = class {
  static isGreaterOrEqual(version, targetVersion) {
    const v1 = parseVersion(version);
    const v2 = parseVersion(targetVersion);
    return v1[0] > v2[0] || v1[0] === v2[0] && v1[1] > v2[1] || v1[0] === v2[0] && v1[1] === v2[1] && v1[2] >= v2[2];
  }
};
function parseVersion(version = "") {
  const v = [0, 0, 0];
  version.split(".").forEach((value, i) => v[i] = parseInt(value, 10));
  return v;
}

// ../node_modules/typeorm/browser/driver/DriverUtils.js
var DriverUtils = class {
  // -------------------------------------------------------------------------
  // Public Static Methods
  // -------------------------------------------------------------------------
  /**
   * Returns true if given driver is SQLite-based driver.
   */
  static isSQLiteFamily(driver) {
    return ["sqlite", "cordova", "react-native", "nativescript", "sqljs", "expo", "better-sqlite3", "capacitor"].includes(driver.options.type);
  }
  /**
   * Returns true if given driver is MySQL-based driver.
   */
  static isMySQLFamily(driver) {
    return ["mysql", "mariadb"].includes(driver.options.type);
  }
  static isReleaseVersionOrGreater(driver, version) {
    return driver.version != null && VersionUtils.isGreaterOrEqual(driver.version, version);
  }
  static isPostgresFamily(driver) {
    return ["postgres", "aurora-postgres", "cockroachdb"].includes(driver.options.type);
  }
  /**
   * Normalizes and builds a new driver options.
   * Extracts settings from connection url and sets to a new options object.
   */
  static buildDriverOptions(options, buildOptions) {
    if (options.url) {
      const urlDriverOptions = this.parseConnectionUrl(options.url);
      if (buildOptions && buildOptions.useSid && urlDriverOptions.database) {
        urlDriverOptions.sid = urlDriverOptions.database;
      }
      for (const key of Object.keys(urlDriverOptions)) {
        if (typeof urlDriverOptions[key] === "undefined") {
          delete urlDriverOptions[key];
        }
      }
      return Object.assign({}, options, urlDriverOptions);
    }
    return Object.assign({}, options);
  }
  /**
   * buildDriverOptions for MongodDB only to support replica set
   */
  static buildMongoDBDriverOptions(options, buildOptions) {
    if (options.url) {
      const urlDriverOptions = this.parseMongoDBConnectionUrl(options.url);
      if (buildOptions && buildOptions.useSid && urlDriverOptions.database) {
        urlDriverOptions.sid = urlDriverOptions.database;
      }
      for (const key of Object.keys(urlDriverOptions)) {
        if (typeof urlDriverOptions[key] === "undefined") {
          delete urlDriverOptions[key];
        }
      }
      return Object.assign({}, options, urlDriverOptions);
    }
    return Object.assign({}, options);
  }
  /**
   * Joins and shortens alias if needed.
   *
   * If the alias length is greater than the limit allowed by the current
   * driver, replaces it with a shortend string, if the shortend string
   * is still too long, it will then hash the alias.
   *
   * @param driver Current `Driver`.
   * @param buildOptions Optional settings.
   * @param alias Alias parts.
   *
   * @return An alias that is no longer than the divers max alias length.
   */
  static buildAlias({
    maxAliasLength
  }, buildOptions, ...alias) {
    const joiner = buildOptions && buildOptions.joiner ? buildOptions.joiner : "_";
    let newAlias = alias.length === 1 ? alias[0] : alias.join(joiner);
    if (maxAliasLength && maxAliasLength > 0 && newAlias.length > maxAliasLength) {
      if (buildOptions && buildOptions.shorten === true) {
        const shortenedAlias = shorten(newAlias);
        if (shortenedAlias.length < maxAliasLength) {
          return shortenedAlias;
        }
      }
      return hash(newAlias, {
        length: maxAliasLength
      });
    }
    return newAlias;
  }
  /**
   * @deprecated use `buildAlias` instead.
   */
  static buildColumnAlias({
    maxAliasLength
  }, buildOptions, ...alias) {
    if (typeof buildOptions === "string") {
      alias.unshift(buildOptions);
      buildOptions = {
        shorten: false,
        joiner: "_"
      };
    } else {
      buildOptions = Object.assign({
        shorten: false,
        joiner: "_"
      }, buildOptions);
    }
    return this.buildAlias({
      maxAliasLength
    }, buildOptions, ...alias);
  }
  // -------------------------------------------------------------------------
  // Private Static Methods
  // -------------------------------------------------------------------------
  /**
   * Extracts connection data from the connection url.
   */
  static parseConnectionUrl(url) {
    const type = url.split(":")[0];
    const firstSlashes = url.indexOf("//");
    const preBase = url.substr(firstSlashes + 2);
    const secondSlash = preBase.indexOf("/");
    const base = secondSlash !== -1 ? preBase.substr(0, secondSlash) : preBase;
    let afterBase = secondSlash !== -1 ? preBase.substr(secondSlash + 1) : void 0;
    if (afterBase && afterBase.indexOf("?") !== -1) {
      afterBase = afterBase.substr(0, afterBase.indexOf("?"));
    }
    const lastAtSign = base.lastIndexOf("@");
    const usernameAndPassword = base.substr(0, lastAtSign);
    const hostAndPort = base.substr(lastAtSign + 1);
    let username = usernameAndPassword;
    let password = "";
    const firstColon = usernameAndPassword.indexOf(":");
    if (firstColon !== -1) {
      username = usernameAndPassword.substr(0, firstColon);
      password = usernameAndPassword.substr(firstColon + 1);
    }
    const [host, port] = hostAndPort.split(":");
    return {
      type,
      host,
      username: decodeURIComponent(username),
      password: decodeURIComponent(password),
      port: port ? parseInt(port) : void 0,
      database: afterBase || void 0
    };
  }
  /**
   * Extracts connection data from the connection url for MongoDB to support replica set.
   */
  static parseMongoDBConnectionUrl(url) {
    const type = url.split(":")[0];
    const firstSlashes = url.indexOf("//");
    const preBase = url.substr(firstSlashes + 2);
    const secondSlash = preBase.indexOf("/");
    const base = secondSlash !== -1 ? preBase.substr(0, secondSlash) : preBase;
    let afterBase = secondSlash !== -1 ? preBase.substr(secondSlash + 1) : void 0;
    let afterQuestionMark = "";
    let host = void 0;
    let port = void 0;
    let hostReplicaSet = void 0;
    let replicaSet = void 0;
    let optionsObject = {};
    if (afterBase && afterBase.indexOf("?") !== -1) {
      afterQuestionMark = afterBase.substr(afterBase.indexOf("?") + 1, afterBase.length);
      const optionsList = afterQuestionMark.split("&");
      let optionKey;
      let optionValue;
      optionsList.forEach((optionItem) => {
        optionKey = optionItem.split("=")[0];
        optionValue = optionItem.split("=")[1];
        optionsObject[optionKey] = optionValue;
      });
      replicaSet = optionsObject["replicaSet"];
      afterBase = afterBase.substr(0, afterBase.indexOf("?"));
    }
    const lastAtSign = base.lastIndexOf("@");
    const usernameAndPassword = base.substr(0, lastAtSign);
    const hostAndPort = base.substr(lastAtSign + 1);
    let username = usernameAndPassword;
    let password = "";
    const firstColon = usernameAndPassword.indexOf(":");
    if (firstColon !== -1) {
      username = usernameAndPassword.substr(0, firstColon);
      password = usernameAndPassword.substr(firstColon + 1);
    }
    if (replicaSet) {
      hostReplicaSet = hostAndPort;
    } else {
      ;
      [host, port] = hostAndPort.split(":");
    }
    let connectionUrl = {
      type,
      host,
      hostReplicaSet,
      username: decodeURIComponent(username),
      password: decodeURIComponent(password),
      port: port ? parseInt(port) : void 0,
      database: afterBase || void 0
    };
    for (const [key, value] of Object.entries(optionsObject)) {
      connectionUrl[key] = value;
    }
    return connectionUrl;
  }
};

// ../node_modules/typeorm/browser/query-builder/JoinAttribute.js
var JoinAttribute = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection, queryExpressionMap, joinAttribute) {
    this.connection = connection;
    this.queryExpressionMap = queryExpressionMap;
    this.isSelectedEvaluated = false;
    this.relationEvaluated = false;
    if (joinAttribute) {
      ObjectUtils.assign(this, joinAttribute);
    }
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  get isMany() {
    if (this.isMappingMany !== void 0) return this.isMappingMany;
    if (this.relation) return this.relation.isManyToMany || this.relation.isOneToMany;
    return false;
  }
  /**
   * Indicates if this join is selected.
   */
  get isSelected() {
    if (!this.isSelectedEvaluated) {
      let getValue = () => {
        for (const select of this.queryExpressionMap.selects) {
          if (select.selection === this.alias.name) return true;
          if (this.metadata && !!this.metadata.columns.find((column) => select.selection === this.alias.name + "." + column.propertyPath)) return true;
        }
        return false;
      };
      this.isSelectedCache = getValue();
      this.isSelectedEvaluated = true;
    }
    return this.isSelectedCache;
  }
  /**
   * Name of the table which we should join.
   */
  get tablePath() {
    return this.metadata ? this.metadata.tablePath : this.entityOrProperty;
  }
  /**
   * Alias of the parent of this join.
   * For example, if we join ("post.category", "categoryAlias") then "post" is a parent alias.
   * This value is extracted from entityOrProperty value.
   * This is available when join was made using "post.category" syntax.
   */
  get parentAlias() {
    if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty)) return void 0;
    return this.entityOrProperty.substr(0, this.entityOrProperty.indexOf("."));
  }
  /**
   * Relation property name of the parent.
   * This is used to understand what is joined.
   * For example, if we join ("post.category", "categoryAlias") then "category" is a relation property.
   * This value is extracted from entityOrProperty value.
   * This is available when join was made using "post.category" syntax.
   */
  get relationPropertyPath() {
    if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty)) return void 0;
    return this.entityOrProperty.substr(this.entityOrProperty.indexOf(".") + 1);
  }
  /**
   * Relation of the parent.
   * This is used to understand what is joined.
   * This is available when join was made using "post.category" syntax.
   * Relation can be undefined if entityOrProperty is regular entity or custom table.
   */
  get relation() {
    if (!this.relationEvaluated) {
      let getValue = () => {
        if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty)) return void 0;
        const relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias);
        let relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(this.relationPropertyPath);
        if (relation) {
          return relation;
        }
        if (relationOwnerSelection.metadata.parentEntityMetadata) {
          relation = relationOwnerSelection.metadata.parentEntityMetadata.findRelationWithPropertyPath(this.relationPropertyPath);
          if (relation) {
            return relation;
          }
        }
        throw new TypeORMError(`Relation with property path ${this.relationPropertyPath} in entity was not found.`);
      };
      this.relationCache = getValue.bind(this)();
      this.relationEvaluated = true;
    }
    return this.relationCache;
  }
  /**
   * Metadata of the joined entity.
   * If table without entity was joined, then it will return undefined.
   */
  get metadata() {
    if (this.relation) return this.relation.inverseEntityMetadata;
    if (this.connection.hasMetadata(this.entityOrProperty)) return this.connection.getMetadata(this.entityOrProperty);
    if (this.mapAsEntity && this.connection.hasMetadata(this.mapAsEntity)) {
      return this.connection.getMetadata(this.mapAsEntity);
    }
    return void 0;
  }
  /**
   * Generates alias of junction table, whose ids we get.
   */
  get junctionAlias() {
    if (!this.relation) {
      throw new TypeORMError(`Cannot get junction table for join without relation.`);
    }
    if (typeof this.entityOrProperty !== "string") {
      throw new TypeORMError(`Junction property is not defined.`);
    }
    const aliasProperty = this.entityOrProperty.substr(0, this.entityOrProperty.indexOf("."));
    if (this.relation.isOwning) {
      return DriverUtils.buildAlias(this.connection.driver, void 0, aliasProperty, this.alias.name);
    } else {
      return DriverUtils.buildAlias(this.connection.driver, void 0, this.alias.name, aliasProperty);
    }
  }
  get mapToPropertyParentAlias() {
    if (!this.mapToProperty) return void 0;
    return this.mapToProperty.split(".")[0];
  }
  get mapToPropertyPropertyName() {
    if (!this.mapToProperty) return void 0;
    return this.mapToProperty.split(".")[1];
  }
};

// ../node_modules/typeorm/browser/query-builder/relation-id/RelationIdAttribute.js
var RelationIdAttribute = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(queryExpressionMap, relationIdAttribute) {
    this.queryExpressionMap = queryExpressionMap;
    this.disableMixedMap = false;
    ObjectUtils.assign(this, relationIdAttribute || {});
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  get joinInverseSideMetadata() {
    return this.relation.inverseEntityMetadata;
  }
  /**
   * Alias of the parent of this join.
   * For example, if we join ("post.category", "categoryAlias") then "post" is a parent alias.
   * This value is extracted from entityOrProperty value.
   * This is available when join was made using "post.category" syntax.
   */
  get parentAlias() {
    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value must be a string representation of alias property`);
    return this.relationName.substr(0, this.relationName.indexOf("."));
  }
  /**
   * Relation property name of the parent.
   * This is used to understand what is joined.
   * For example, if we join ("post.category", "categoryAlias") then "category" is a relation property.
   * This value is extracted from entityOrProperty value.
   * This is available when join was made using "post.category" syntax.
   */
  get relationPropertyPath() {
    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value must be a string representation of alias property`);
    return this.relationName.substr(this.relationName.indexOf(".") + 1);
  }
  /**
   * Relation of the parent.
   * This is used to understand what is joined.
   * This is available when join was made using "post.category" syntax.
   */
  get relation() {
    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value must be a string representation of alias property`);
    const relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias);
    const relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(this.relationPropertyPath);
    if (!relation) throw new TypeORMError(`Relation with property path ${this.relationPropertyPath} in entity was not found.`);
    return relation;
  }
  /**
   * Generates alias of junction table, whose ids we get.
   */
  get junctionAlias() {
    const [parentAlias, relationProperty] = this.relationName.split(".");
    return parentAlias + "_" + relationProperty + "_rid";
  }
  /**
   * Metadata of the joined entity.
   * If extra condition without entity was joined, then it will return undefined.
   */
  get junctionMetadata() {
    return this.relation.junctionEntityMetadata;
  }
  get mapToPropertyParentAlias() {
    return this.mapToProperty.substr(0, this.mapToProperty.indexOf("."));
  }
  get mapToPropertyPropertyPath() {
    return this.mapToProperty.substr(this.mapToProperty.indexOf(".") + 1);
  }
};

// ../node_modules/typeorm/browser/query-builder/relation-count/RelationCountAttribute.js
var RelationCountAttribute = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(expressionMap, relationCountAttribute) {
    this.expressionMap = expressionMap;
    ObjectUtils.assign(this, relationCountAttribute || {});
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  get joinInverseSideMetadata() {
    return this.relation.inverseEntityMetadata;
  }
  /**
   * Alias of the parent of this join.
   * For example, if we join ("post.category", "categoryAlias") then "post" is a parent alias.
   * This value is extracted from entityOrProperty value.
   * This is available when join was made using "post.category" syntax.
   */
  get parentAlias() {
    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value must be a string representation of alias property`);
    return this.relationName.split(".")[0];
  }
  /**
   * Relation property name of the parent.
   * This is used to understand what is joined.
   * For example, if we join ("post.category", "categoryAlias") then "category" is a relation property.
   * This value is extracted from entityOrProperty value.
   * This is available when join was made using "post.category" syntax.
   */
  get relationProperty() {
    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value is a string representation of alias property`);
    return this.relationName.split(".")[1];
  }
  get junctionAlias() {
    const [parentAlias, relationProperty] = this.relationName.split(".");
    return parentAlias + "_" + relationProperty + "_rc";
  }
  /**
   * Relation of the parent.
   * This is used to understand what is joined.
   * This is available when join was made using "post.category" syntax.
   */
  get relation() {
    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value is a string representation of alias property`);
    const [parentAlias, propertyPath] = this.relationName.split(".");
    const relationOwnerSelection = this.expressionMap.findAliasByName(parentAlias);
    const relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(propertyPath);
    if (!relation) throw new TypeORMError(`Relation with property path ${propertyPath} in entity was not found.`);
    return relation;
  }
  /**
   * Metadata of the joined entity.
   * If table without entity was joined, then it will return undefined.
   */
  get metadata() {
    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value is a string representation of alias property`);
    const parentAlias = this.relationName.split(".")[0];
    const selection = this.expressionMap.findAliasByName(parentAlias);
    return selection.metadata;
  }
  get mapToPropertyPropertyName() {
    return this.mapToProperty.split(".")[1];
  }
};

// ../node_modules/typeorm/browser/query-builder/QueryExpressionMap.js
var QueryExpressionMap = class _QueryExpressionMap {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    this.connection = connection;
    this.relationLoadStrategy = "join";
    this.queryEntity = false;
    this.aliases = [];
    this.queryType = "select";
    this.selects = [];
    this.maxExecutionTime = 0;
    this.selectDistinct = false;
    this.selectDistinctOn = [];
    this.extraReturningColumns = [];
    this.onConflict = "";
    this.onIgnore = false;
    this.joinAttributes = [];
    this.relationIdAttributes = [];
    this.relationCountAttributes = [];
    this.wheres = [];
    this.havings = [];
    this.orderBys = {};
    this.groupBys = [];
    this.withDeleted = false;
    this.parameters = {};
    this.disableEscaping = true;
    this.enableRelationIdValues = false;
    this.extraAppendedAndWhereCondition = "";
    this.subQuery = false;
    this.aliasNamePrefixingEnabled = true;
    this.options = [];
    this.insertColumns = [];
    this.whereEntities = [];
    this.updateEntity = true;
    this.callListeners = true;
    this.useTransaction = false;
    this.nativeParameters = {};
    this.locallyGenerated = {};
    this.commonTableExpressions = [];
    if (connection.options.relationLoadStrategy) {
      this.relationLoadStrategy = connection.options.relationLoadStrategy;
    }
    this.timeTravel = connection.options?.timeTravelQueries || false;
  }
  // -------------------------------------------------------------------------
  // Accessors
  // -------------------------------------------------------------------------
  /**
   * Get all ORDER BY queries - if order by is specified by user then it uses them,
   * otherwise it uses default entity order by if it was set.
   */
  get allOrderBys() {
    if (!Object.keys(this.orderBys).length && this.mainAlias.hasMetadata && this.options.indexOf("disable-global-order") === -1) {
      const entityOrderBy = this.mainAlias.metadata.orderBy || {};
      return Object.keys(entityOrderBy).reduce((orderBy, key) => {
        orderBy[this.mainAlias.name + "." + key] = entityOrderBy[key];
        return orderBy;
      }, {});
    }
    return this.orderBys;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates a main alias and adds it to the current expression map.
   */
  setMainAlias(alias) {
    this.mainAlias = alias;
    return alias;
  }
  /**
   * Creates a new alias and adds it to the current expression map.
   */
  createAlias(options) {
    let aliasName = options.name;
    if (!aliasName && options.tablePath) aliasName = options.tablePath;
    if (!aliasName && typeof options.target === "function") aliasName = options.target.name;
    if (!aliasName && typeof options.target === "string") aliasName = options.target;
    const alias = new Alias();
    alias.type = options.type;
    if (aliasName) alias.name = aliasName;
    if (options.metadata) alias.metadata = options.metadata;
    if (options.target && !alias.hasMetadata) alias.metadata = this.connection.getMetadata(options.target);
    if (options.tablePath) alias.tablePath = options.tablePath;
    if (options.subQuery) alias.subQuery = options.subQuery;
    this.aliases.push(alias);
    return alias;
  }
  /**
   * Finds alias with the given name.
   * If alias was not found it throw an exception.
   */
  findAliasByName(aliasName) {
    const alias = this.aliases.find((alias2) => alias2.name === aliasName);
    if (!alias) throw new TypeORMError(`"${aliasName}" alias was not found. Maybe you forgot to join it?`);
    return alias;
  }
  findColumnByAliasExpression(aliasExpression) {
    const [aliasName, propertyPath] = aliasExpression.split(".");
    const alias = this.findAliasByName(aliasName);
    return alias.metadata.findColumnWithPropertyName(propertyPath);
  }
  /**
   * Gets relation metadata of the relation this query builder works with.
   *
   * todo: add proper exceptions
   */
  get relationMetadata() {
    if (!this.mainAlias) throw new TypeORMError(`Entity to work with is not specified!`);
    const relationMetadata = this.mainAlias.metadata.findRelationWithPropertyPath(this.relationPropertyPath);
    if (!relationMetadata) throw new TypeORMError(`Relation ${this.relationPropertyPath} was not found in entity ${this.mainAlias.name}`);
    return relationMetadata;
  }
  /**
   * Copies all properties of the current QueryExpressionMap into a new one.
   * Useful when QueryBuilder needs to create a copy of itself.
   */
  clone() {
    const map = new _QueryExpressionMap(this.connection);
    map.queryType = this.queryType;
    map.selects = this.selects.map((select) => select);
    map.maxExecutionTime = this.maxExecutionTime;
    map.selectDistinct = this.selectDistinct;
    map.selectDistinctOn = this.selectDistinctOn;
    this.aliases.forEach((alias) => map.aliases.push(new Alias(alias)));
    map.relationLoadStrategy = this.relationLoadStrategy;
    map.mainAlias = this.mainAlias;
    map.valuesSet = this.valuesSet;
    map.returning = this.returning;
    map.onConflict = this.onConflict;
    map.onIgnore = this.onIgnore;
    map.onUpdate = this.onUpdate;
    map.joinAttributes = this.joinAttributes.map((join) => new JoinAttribute(this.connection, this, join));
    map.relationIdAttributes = this.relationIdAttributes.map((relationId) => new RelationIdAttribute(this, relationId));
    map.relationCountAttributes = this.relationCountAttributes.map((relationCount) => new RelationCountAttribute(this, relationCount));
    map.wheres = this.wheres.map((where) => __spreadValues({}, where));
    map.havings = this.havings.map((having) => __spreadValues({}, having));
    map.orderBys = Object.assign({}, this.orderBys);
    map.groupBys = this.groupBys.map((groupBy) => groupBy);
    map.limit = this.limit;
    map.offset = this.offset;
    map.skip = this.skip;
    map.take = this.take;
    map.lockMode = this.lockMode;
    map.onLocked = this.onLocked;
    map.lockVersion = this.lockVersion;
    map.lockTables = this.lockTables;
    map.withDeleted = this.withDeleted;
    map.parameters = Object.assign({}, this.parameters);
    map.disableEscaping = this.disableEscaping;
    map.enableRelationIdValues = this.enableRelationIdValues;
    map.extraAppendedAndWhereCondition = this.extraAppendedAndWhereCondition;
    map.subQuery = this.subQuery;
    map.aliasNamePrefixingEnabled = this.aliasNamePrefixingEnabled;
    map.cache = this.cache;
    map.cacheId = this.cacheId;
    map.cacheDuration = this.cacheDuration;
    map.relationPropertyPath = this.relationPropertyPath;
    map.of = this.of;
    map.insertColumns = this.insertColumns;
    map.whereEntities = this.whereEntities;
    map.updateEntity = this.updateEntity;
    map.callListeners = this.callListeners;
    map.useTransaction = this.useTransaction;
    map.timeTravel = this.timeTravel;
    map.nativeParameters = Object.assign({}, this.nativeParameters);
    map.comment = this.comment;
    map.commonTableExpressions = this.commonTableExpressions.map((cteOptions) => ({
      alias: cteOptions.alias,
      queryBuilder: typeof cteOptions.queryBuilder === "string" ? cteOptions.queryBuilder : cteOptions.queryBuilder.clone(),
      options: cteOptions.options
    }));
    return map;
  }
};

// ../node_modules/typeorm/browser/query-builder/Brackets.js
var Brackets = class {
  /**
   * Given WHERE query builder that will build a WHERE expression that will be taken into brackets.
   */
  constructor(whereFactory) {
    this["@instanceof"] = Symbol.for("Brackets");
    this.whereFactory = whereFactory;
  }
};

// ../node_modules/typeorm/browser/util/ApplyValueTransformers.js
var ApplyValueTransformers = class {
  static transformFrom(transformer, databaseValue) {
    if (Array.isArray(transformer)) {
      const reverseTransformers = transformer.slice().reverse();
      return reverseTransformers.reduce((transformedValue, _transformer) => {
        return _transformer.from(transformedValue);
      }, databaseValue);
    }
    return transformer.from(databaseValue);
  }
  static transformTo(transformer, entityValue) {
    if (Array.isArray(transformer)) {
      return transformer.reduce((transformedValue, _transformer) => {
        return _transformer.to(transformedValue);
      }, entityValue);
    }
    return transformer.to(entityValue);
  }
};

// ../node_modules/typeorm/browser/find-options/FindOperator.js
var FindOperator = class _FindOperator {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(type, value, useParameter = true, multipleParameters = false, getSql, objectLiteralParameters) {
    this["@instanceof"] = Symbol.for("FindOperator");
    this._type = type;
    this._value = value;
    this._useParameter = useParameter;
    this._multipleParameters = multipleParameters;
    this._getSql = getSql;
    this._objectLiteralParameters = objectLiteralParameters;
  }
  // -------------------------------------------------------------------------
  // Accessors
  // -------------------------------------------------------------------------
  /**
   * Indicates if parameter is used or not for this operator.
   * Extracts final value if value is another find operator.
   */
  get useParameter() {
    if (InstanceChecker.isFindOperator(this._value)) return this._value.useParameter;
    return this._useParameter;
  }
  /**
   * Indicates if multiple parameters must be used for this operator.
   * Extracts final value if value is another find operator.
   */
  get multipleParameters() {
    if (InstanceChecker.isFindOperator(this._value)) return this._value.multipleParameters;
    return this._multipleParameters;
  }
  /**
   * Gets the Type of this FindOperator
   */
  get type() {
    return this._type;
  }
  /**
   * Gets the final value needs to be used as parameter value.
   */
  get value() {
    if (InstanceChecker.isFindOperator(this._value)) return this._value.value;
    return this._value;
  }
  /**
   * Gets ObjectLiteral parameters.
   */
  get objectLiteralParameters() {
    if (InstanceChecker.isFindOperator(this._value)) return this._value.objectLiteralParameters;
    return this._objectLiteralParameters;
  }
  /**
   * Gets the child FindOperator if it exists
   */
  get child() {
    if (InstanceChecker.isFindOperator(this._value)) return this._value;
    return void 0;
  }
  /**
   * Gets the SQL generator
   */
  get getSql() {
    if (InstanceChecker.isFindOperator(this._value)) return this._value.getSql;
    return this._getSql;
  }
  transformValue(transformer) {
    if (this._value instanceof _FindOperator) {
      this._value.transformValue(transformer);
    } else {
      this._value = Array.isArray(this._value) && this._multipleParameters ? this._value.map((v) => transformer && ApplyValueTransformers.transformTo(transformer, v)) : ApplyValueTransformers.transformTo(transformer, this._value);
    }
  }
};

// ../node_modules/typeorm/browser/find-options/operator/In.js
function In(value) {
  return new FindOperator("in", value, true, true);
}

// ../node_modules/typeorm/browser/util/escapeRegExp.js
var ESCAPE_REGEXP = /[.*+\-?^${}()|[\]\\]/g;
var escapeRegExp = (s) => s.replace(ESCAPE_REGEXP, "\\$&");

// ../node_modules/typeorm/browser/query-builder/QueryBuilder.js
var QueryBuilder = class _QueryBuilder {
  /**
   * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.
   */
  constructor(connectionOrQueryBuilder, queryRunner) {
    this["@instanceof"] = Symbol.for("QueryBuilder");
    this.parameterIndex = 0;
    if (InstanceChecker.isDataSource(connectionOrQueryBuilder)) {
      this.connection = connectionOrQueryBuilder;
      this.queryRunner = queryRunner;
      this.expressionMap = new QueryExpressionMap(this.connection);
    } else {
      this.connection = connectionOrQueryBuilder.connection;
      this.queryRunner = connectionOrQueryBuilder.queryRunner;
      this.expressionMap = connectionOrQueryBuilder.expressionMap.clone();
    }
  }
  static registerQueryBuilderClass(name, factory) {
    _QueryBuilder.queryBuilderRegistry[name] = factory;
  }
  // -------------------------------------------------------------------------
  // Accessors
  // -------------------------------------------------------------------------
  /**
   * Gets the main alias string used in this query builder.
   */
  get alias() {
    if (!this.expressionMap.mainAlias) throw new TypeORMError(`Main alias is not set`);
    return this.expressionMap.mainAlias.name;
  }
  /**
   * Creates SELECT query and selects given data.
   * Replaces all previous selections if they exist.
   */
  select(selection, selectionAliasName) {
    this.expressionMap.queryType = "select";
    if (Array.isArray(selection)) {
      this.expressionMap.selects = selection.map((selection2) => ({
        selection: selection2
      }));
    } else if (selection) {
      this.expressionMap.selects = [{
        selection,
        aliasName: selectionAliasName
      }];
    }
    if (InstanceChecker.isSelectQueryBuilder(this)) return this;
    return _QueryBuilder.queryBuilderRegistry["SelectQueryBuilder"](this);
  }
  /**
   * Creates INSERT query.
   */
  insert() {
    this.expressionMap.queryType = "insert";
    if (InstanceChecker.isInsertQueryBuilder(this)) return this;
    return _QueryBuilder.queryBuilderRegistry["InsertQueryBuilder"](this);
  }
  /**
   * Creates UPDATE query and applies given update values.
   */
  update(entityOrTableNameUpdateSet, maybeUpdateSet) {
    const updateSet = maybeUpdateSet ? maybeUpdateSet : entityOrTableNameUpdateSet;
    entityOrTableNameUpdateSet = InstanceChecker.isEntitySchema(entityOrTableNameUpdateSet) ? entityOrTableNameUpdateSet.options.name : entityOrTableNameUpdateSet;
    if (typeof entityOrTableNameUpdateSet === "function" || typeof entityOrTableNameUpdateSet === "string") {
      const mainAlias = this.createFromAlias(entityOrTableNameUpdateSet);
      this.expressionMap.setMainAlias(mainAlias);
    }
    this.expressionMap.queryType = "update";
    this.expressionMap.valuesSet = updateSet;
    if (InstanceChecker.isUpdateQueryBuilder(this)) return this;
    return _QueryBuilder.queryBuilderRegistry["UpdateQueryBuilder"](this);
  }
  /**
   * Creates DELETE query.
   */
  delete() {
    this.expressionMap.queryType = "delete";
    if (InstanceChecker.isDeleteQueryBuilder(this)) return this;
    return _QueryBuilder.queryBuilderRegistry["DeleteQueryBuilder"](this);
  }
  softDelete() {
    this.expressionMap.queryType = "soft-delete";
    if (InstanceChecker.isSoftDeleteQueryBuilder(this)) return this;
    return _QueryBuilder.queryBuilderRegistry["SoftDeleteQueryBuilder"](this);
  }
  restore() {
    this.expressionMap.queryType = "restore";
    if (InstanceChecker.isSoftDeleteQueryBuilder(this)) return this;
    return _QueryBuilder.queryBuilderRegistry["SoftDeleteQueryBuilder"](this);
  }
  /**
   * Sets entity's relation with which this query builder gonna work.
   */
  relation(entityTargetOrPropertyPath, maybePropertyPath) {
    const entityTarget = arguments.length === 2 ? entityTargetOrPropertyPath : void 0;
    const propertyPath = arguments.length === 2 ? maybePropertyPath : entityTargetOrPropertyPath;
    this.expressionMap.queryType = "relation";
    this.expressionMap.relationPropertyPath = propertyPath;
    if (entityTarget) {
      const mainAlias = this.createFromAlias(entityTarget);
      this.expressionMap.setMainAlias(mainAlias);
    }
    if (InstanceChecker.isRelationQueryBuilder(this)) return this;
    return _QueryBuilder.queryBuilderRegistry["RelationQueryBuilder"](this);
  }
  /**
   * Checks if given relation or relations exist in the entity.
   * Returns true if relation exists, false otherwise.
   *
   * todo: move this method to manager? or create a shortcut?
   */
  hasRelation(target, relation) {
    const entityMetadata = this.connection.getMetadata(target);
    const relations = Array.isArray(relation) ? relation : [relation];
    return relations.every((relation2) => {
      return !!entityMetadata.findRelationWithPropertyPath(relation2);
    });
  }
  /**
   * Check the existence of a parameter for this query builder.
   */
  hasParameter(key) {
    return this.parentQueryBuilder?.hasParameter(key) || key in this.expressionMap.parameters;
  }
  /**
   * Sets parameter name and its value.
   *
   * The key for this parameter may contain numbers, letters, underscores, or periods.
   */
  setParameter(key, value) {
    if (typeof value === "function") {
      throw new TypeORMError(`Function parameter isn't supported in the parameters. Please check "${key}" parameter.`);
    }
    if (!key.match(/^([A-Za-z0-9_.]+)$/)) {
      throw new TypeORMError("QueryBuilder parameter keys may only contain numbers, letters, underscores, or periods.");
    }
    if (this.parentQueryBuilder) {
      this.parentQueryBuilder.setParameter(key, value);
    }
    this.expressionMap.parameters[key] = value;
    return this;
  }
  /**
   * Adds all parameters from the given object.
   */
  setParameters(parameters) {
    for (const [key, value] of Object.entries(parameters)) {
      this.setParameter(key, value);
    }
    return this;
  }
  createParameter(value) {
    let parameterName;
    do {
      parameterName = `orm_param_${this.parameterIndex++}`;
    } while (this.hasParameter(parameterName));
    this.setParameter(parameterName, value);
    return `:${parameterName}`;
  }
  /**
   * Adds native parameters from the given object.
   *
   * @deprecated Use `setParameters` instead
   */
  setNativeParameters(parameters) {
    if (this.parentQueryBuilder) {
      this.parentQueryBuilder.setNativeParameters(parameters);
    }
    Object.keys(parameters).forEach((key) => {
      this.expressionMap.nativeParameters[key] = parameters[key];
    });
    return this;
  }
  /**
   * Gets all parameters.
   */
  getParameters() {
    const parameters = Object.assign({}, this.expressionMap.parameters);
    if (this.expressionMap.mainAlias && this.expressionMap.mainAlias.hasMetadata) {
      const metadata = this.expressionMap.mainAlias.metadata;
      if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {
        const values = metadata.childEntityMetadatas.filter((childMetadata) => childMetadata.discriminatorColumn).map((childMetadata) => childMetadata.discriminatorValue);
        values.push(metadata.discriminatorValue);
        parameters["discriminatorColumnValues"] = values;
      }
    }
    return parameters;
  }
  /**
   * Prints sql to stdout using console.log.
   */
  printSql() {
    const [query, parameters] = this.getQueryAndParameters();
    this.connection.logger.logQuery(query, parameters);
    return this;
  }
  /**
   * Gets generated sql that will be executed.
   * Parameters in the query are escaped for the currently used driver.
   */
  getSql() {
    return this.getQueryAndParameters()[0];
  }
  /**
   * Gets query to be executed with all parameters used in it.
   */
  getQueryAndParameters() {
    const query = this.getQuery();
    const parameters = this.getParameters();
    return this.connection.driver.escapeQueryWithParameters(query, parameters, this.expressionMap.nativeParameters);
  }
  /**
   * Executes sql generated by query builder and returns raw database results.
   */
  execute() {
    return __async(this, null, function* () {
      const [sql, parameters] = this.getQueryAndParameters();
      const queryRunner = this.obtainQueryRunner();
      try {
        return yield queryRunner.query(sql, parameters);
      } finally {
        if (queryRunner !== this.queryRunner) {
          yield queryRunner.release();
        }
      }
    });
  }
  /**
   * Creates a completely new query builder.
   * Uses same query runner as current QueryBuilder.
   */
  createQueryBuilder(queryRunner) {
    return new this.constructor(this.connection, queryRunner ?? this.queryRunner);
  }
  /**
   * Clones query builder as it is.
   * Note: it uses new query runner, if you want query builder that uses exactly same query runner,
   * you can create query builder using its constructor, for example new SelectQueryBuilder(queryBuilder)
   * where queryBuilder is cloned QueryBuilder.
   */
  clone() {
    return new this.constructor(this);
  }
  /**
   * Includes a Query comment in the query builder.  This is helpful for debugging purposes,
   * such as finding a specific query in the database server's logs, or for categorization using
   * an APM product.
   */
  comment(comment) {
    this.expressionMap.comment = comment;
    return this;
  }
  /**
   * Disables escaping.
   */
  disableEscaping() {
    this.expressionMap.disableEscaping = false;
    return this;
  }
  /**
   * Escapes table name, column name or alias name using current database's escaping character.
   */
  escape(name) {
    if (!this.expressionMap.disableEscaping) return name;
    return this.connection.driver.escape(name);
  }
  /**
   * Sets or overrides query builder's QueryRunner.
   */
  setQueryRunner(queryRunner) {
    this.queryRunner = queryRunner;
    return this;
  }
  /**
   * Indicates if listeners and subscribers must be called before and after query execution.
   * Enabled by default.
   */
  callListeners(enabled) {
    this.expressionMap.callListeners = enabled;
    return this;
  }
  /**
   * If set to true the query will be wrapped into a transaction.
   */
  useTransaction(enabled) {
    this.expressionMap.useTransaction = enabled;
    return this;
  }
  /**
   * Adds CTE to query
   */
  addCommonTableExpression(queryBuilder, alias, options) {
    this.expressionMap.commonTableExpressions.push({
      queryBuilder,
      alias,
      options: options || {}
    });
    return this;
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Gets escaped table name with schema name if SqlServer driver used with custom
   * schema name, otherwise returns escaped table name.
   */
  getTableName(tablePath) {
    return tablePath.split(".").map((i) => {
      if (i === "") return i;
      return this.escape(i);
    }).join(".");
  }
  /**
   * Gets name of the table where insert should be performed.
   */
  getMainTableName() {
    if (!this.expressionMap.mainAlias) throw new TypeORMError(`Entity where values should be inserted is not specified. Call "qb.into(entity)" method to specify it.`);
    if (this.expressionMap.mainAlias.hasMetadata) return this.expressionMap.mainAlias.metadata.tablePath;
    return this.expressionMap.mainAlias.tablePath;
  }
  /**
   * Specifies FROM which entity's table select/update/delete will be executed.
   * Also sets a main string alias of the selection data.
   */
  createFromAlias(entityTarget, aliasName) {
    if (this.connection.hasMetadata(entityTarget)) {
      const metadata = this.connection.getMetadata(entityTarget);
      return this.expressionMap.createAlias({
        type: "from",
        name: aliasName,
        metadata: this.connection.getMetadata(entityTarget),
        tablePath: metadata.tablePath
      });
    } else {
      if (typeof entityTarget === "string") {
        const isSubquery = entityTarget.substr(0, 1) === "(" && entityTarget.substr(-1) === ")";
        return this.expressionMap.createAlias({
          type: "from",
          name: aliasName,
          tablePath: !isSubquery ? entityTarget : void 0,
          subQuery: isSubquery ? entityTarget : void 0
        });
      }
      const subQueryBuilder = entityTarget(this.subQuery());
      this.setParameters(subQueryBuilder.getParameters());
      const subquery = subQueryBuilder.getQuery();
      return this.expressionMap.createAlias({
        type: "from",
        name: aliasName,
        subQuery: subquery
      });
    }
  }
  /**
   * @deprecated this way of replace property names is too slow.
   *  Instead, we'll replace property names at the end - once query is build.
   */
  replacePropertyNames(statement) {
    return statement;
  }
  /**
   * Replaces all entity's propertyName to name in the given SQL string.
   */
  replacePropertyNamesForTheWholeQuery(statement) {
    const replacements = {};
    for (const alias of this.expressionMap.aliases) {
      if (!alias.hasMetadata) continue;
      const replaceAliasNamePrefix = this.expressionMap.aliasNamePrefixingEnabled && alias.name ? `${alias.name}.` : "";
      if (!replacements[replaceAliasNamePrefix]) {
        replacements[replaceAliasNamePrefix] = {};
      }
      for (const relation of alias.metadata.relations) {
        if (relation.joinColumns.length > 0) replacements[replaceAliasNamePrefix][relation.propertyPath] = relation.joinColumns[0].databaseName;
      }
      for (const relation of alias.metadata.relations) {
        const allColumns = [...relation.joinColumns, ...relation.inverseJoinColumns];
        for (const joinColumn of allColumns) {
          const propertyKey = `${relation.propertyPath}.${joinColumn.referencedColumn.propertyPath}`;
          replacements[replaceAliasNamePrefix][propertyKey] = joinColumn.databaseName;
        }
      }
      for (const column of alias.metadata.columns) {
        replacements[replaceAliasNamePrefix][column.databaseName] = column.databaseName;
      }
      for (const column of alias.metadata.columns) {
        replacements[replaceAliasNamePrefix][column.propertyName] = column.databaseName;
      }
      for (const column of alias.metadata.columns) {
        replacements[replaceAliasNamePrefix][column.propertyPath] = column.databaseName;
      }
    }
    const replacementKeys = Object.keys(replacements);
    const replaceAliasNamePrefixes = replacementKeys.map((key) => escapeRegExp(key)).join("|");
    if (replacementKeys.length > 0) {
      statement = statement.replace(new RegExp(
        // Avoid a lookbehind here since it's not well supported
        `([ =(]|^.{0})${replaceAliasNamePrefixes ? "(" + replaceAliasNamePrefixes + ")" : ""}([^ =(),]+)(?=[ =),]|.{0}$)`,
        "gm"
      ), (...matches) => {
        let match, pre, p;
        if (replaceAliasNamePrefixes) {
          match = matches[0];
          pre = matches[1];
          p = matches[3];
          if (replacements[matches[2]][p]) {
            return `${pre}${this.escape(matches[2].substring(0, matches[2].length - 1))}.${this.escape(replacements[matches[2]][p])}`;
          }
        } else {
          match = matches[0];
          pre = matches[1];
          p = matches[2];
          if (replacements[""][p]) {
            return `${pre}${this.escape(replacements[""][p])}`;
          }
        }
        return match;
      });
    }
    return statement;
  }
  createComment() {
    if (!this.expressionMap.comment) {
      return "";
    }
    return `/* ${this.expressionMap.comment.replace(/\*\//g, "")} */ `;
  }
  /**
   * Time travel queries for CockroachDB
   */
  createTimeTravelQuery() {
    if (this.expressionMap.queryType === "select" && this.expressionMap.timeTravel) {
      return ` AS OF SYSTEM TIME ${this.expressionMap.timeTravel}`;
    }
    return "";
  }
  /**
   * Creates "WHERE" expression.
   */
  createWhereExpression() {
    const conditionsArray = [];
    const whereExpression = this.createWhereClausesExpression(this.expressionMap.wheres);
    if (whereExpression.length > 0 && whereExpression !== "1=1") {
      conditionsArray.push(this.replacePropertyNames(whereExpression));
    }
    if (this.expressionMap.mainAlias.hasMetadata) {
      const metadata = this.expressionMap.mainAlias.metadata;
      if (this.expressionMap.queryType === "select" && !this.expressionMap.withDeleted && metadata.deleteDateColumn) {
        const column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + "." + metadata.deleteDateColumn.propertyName : metadata.deleteDateColumn.propertyName;
        const condition2 = `${this.replacePropertyNames(column)} IS NULL`;
        conditionsArray.push(condition2);
      }
      if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {
        const column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + "." + metadata.discriminatorColumn.databaseName : metadata.discriminatorColumn.databaseName;
        const condition2 = `${this.replacePropertyNames(column)} IN (:...discriminatorColumnValues)`;
        conditionsArray.push(condition2);
      }
    }
    if (this.expressionMap.extraAppendedAndWhereCondition) {
      const condition2 = this.replacePropertyNames(this.expressionMap.extraAppendedAndWhereCondition);
      conditionsArray.push(condition2);
    }
    let condition = "";
    condition += this.createTimeTravelQuery();
    if (!conditionsArray.length) {
      condition += "";
    } else if (conditionsArray.length === 1) {
      condition += ` WHERE ${conditionsArray[0]}`;
    } else {
      condition += ` WHERE ( ${conditionsArray.join(" ) AND ( ")} )`;
    }
    return condition;
  }
  /**
   * Creates "RETURNING" / "OUTPUT" expression.
   */
  createReturningExpression(returningType) {
    const columns = this.getReturningColumns();
    const driver = this.connection.driver;
    if (typeof this.expressionMap.returning !== "string" && this.expressionMap.extraReturningColumns.length > 0 && driver.isReturningSqlSupported(returningType)) {
      columns.push(...this.expressionMap.extraReturningColumns.filter((column) => {
        return columns.indexOf(column) === -1;
      }));
    }
    if (columns.length) {
      let columnsExpression = columns.map((column) => {
        const name = this.escape(column.databaseName);
        if (driver.options.type === "mssql") {
          if (this.expressionMap.queryType === "insert" || this.expressionMap.queryType === "update" || this.expressionMap.queryType === "soft-delete" || this.expressionMap.queryType === "restore") {
            return "INSERTED." + name;
          } else {
            return this.escape(this.getMainTableName()) + "." + name;
          }
        } else {
          return name;
        }
      }).join(", ");
      if (driver.options.type === "oracle") {
        columnsExpression += " INTO " + columns.map((column) => {
          return this.createParameter({
            type: driver.columnTypeToNativeParameter(column.type),
            dir: driver.oracle.BIND_OUT
          });
        }).join(", ");
      }
      if (driver.options.type === "mssql") {
        if (this.expressionMap.queryType === "insert" || this.expressionMap.queryType === "update") {
          columnsExpression += " INTO @OutputTable";
        }
      }
      return columnsExpression;
    } else if (typeof this.expressionMap.returning === "string") {
      return this.expressionMap.returning;
    }
    return "";
  }
  /**
   * If returning / output cause is set to array of column names,
   * then this method will return all column metadatas of those column names.
   */
  getReturningColumns() {
    const columns = [];
    if (Array.isArray(this.expressionMap.returning)) {
      ;
      this.expressionMap.returning.forEach((columnName) => {
        if (this.expressionMap.mainAlias.hasMetadata) {
          columns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnName));
        }
      });
    }
    return columns;
  }
  createWhereClausesExpression(clauses) {
    return clauses.map((clause, index) => {
      const expression = this.createWhereConditionExpression(clause.condition);
      switch (clause.type) {
        case "and":
          return (index > 0 ? "AND " : "") + `${this.connection.options.isolateWhereStatements ? "(" : ""}${expression}${this.connection.options.isolateWhereStatements ? ")" : ""}`;
        case "or":
          return (index > 0 ? "OR " : "") + `${this.connection.options.isolateWhereStatements ? "(" : ""}${expression}${this.connection.options.isolateWhereStatements ? ")" : ""}`;
      }
      return expression;
    }).join(" ").trim();
  }
  /**
   * Computes given where argument - transforms to a where string all forms it can take.
   */
  createWhereConditionExpression(condition, alwaysWrap = false) {
    if (typeof condition === "string") return condition;
    if (Array.isArray(condition)) {
      if (condition.length === 0) {
        return "1=1";
      }
      if (condition.length === 1 && !alwaysWrap) {
        return this.createWhereClausesExpression(condition);
      }
      return "(" + this.createWhereClausesExpression(condition) + ")";
    }
    const {
      driver
    } = this.connection;
    switch (condition.operator) {
      case "lessThan":
        return `${condition.parameters[0]} < ${condition.parameters[1]}`;
      case "lessThanOrEqual":
        return `${condition.parameters[0]} <= ${condition.parameters[1]}`;
      case "arrayContains":
        return `${condition.parameters[0]} @> ${condition.parameters[1]}`;
      case "jsonContains":
        return `${condition.parameters[0]} ::jsonb @> ${condition.parameters[1]}`;
      case "arrayContainedBy":
        return `${condition.parameters[0]} <@ ${condition.parameters[1]}`;
      case "arrayOverlap":
        return `${condition.parameters[0]} && ${condition.parameters[1]}`;
      case "moreThan":
        return `${condition.parameters[0]} > ${condition.parameters[1]}`;
      case "moreThanOrEqual":
        return `${condition.parameters[0]} >= ${condition.parameters[1]}`;
      case "notEqual":
        return `${condition.parameters[0]} != ${condition.parameters[1]}`;
      case "equal":
        return `${condition.parameters[0]} = ${condition.parameters[1]}`;
      case "ilike":
        if (driver.options.type === "postgres" || driver.options.type === "cockroachdb") {
          return `${condition.parameters[0]} ILIKE ${condition.parameters[1]}`;
        }
        return `UPPER(${condition.parameters[0]}) LIKE UPPER(${condition.parameters[1]})`;
      case "like":
        return `${condition.parameters[0]} LIKE ${condition.parameters[1]}`;
      case "between":
        return `${condition.parameters[0]} BETWEEN ${condition.parameters[1]} AND ${condition.parameters[2]}`;
      case "in":
        if (condition.parameters.length <= 1) {
          return "0=1";
        }
        return `${condition.parameters[0]} IN (${condition.parameters.slice(1).join(", ")})`;
      case "any":
        if (driver.options.type === "cockroachdb") {
          return `${condition.parameters[0]}::STRING = ANY(${condition.parameters[1]}::STRING[])`;
        }
        return `${condition.parameters[0]} = ANY(${condition.parameters[1]})`;
      case "isNull":
        return `${condition.parameters[0]} IS NULL`;
      case "not":
        return `NOT(${this.createWhereConditionExpression(condition.condition)})`;
      case "brackets":
        return `${this.createWhereConditionExpression(condition.condition, true)}`;
      case "and":
        return "(" + condition.parameters.join(" AND ") + ")";
      case "or":
        return "(" + condition.parameters.join(" OR ") + ")";
    }
    throw new TypeError(`Unsupported FindOperator ${FindOperator.constructor.name}`);
  }
  createCteExpression() {
    if (!this.hasCommonTableExpressions()) {
      return "";
    }
    const databaseRequireRecusiveHint = this.connection.driver.cteCapabilities.requiresRecursiveHint;
    const cteStrings = this.expressionMap.commonTableExpressions.map((cte) => {
      let cteBodyExpression = typeof cte.queryBuilder === "string" ? cte.queryBuilder : "";
      if (typeof cte.queryBuilder !== "string") {
        if (cte.queryBuilder.hasCommonTableExpressions()) {
          throw new TypeORMError(`Nested CTEs aren't supported (CTE: ${cte.alias})`);
        }
        cteBodyExpression = cte.queryBuilder.getQuery();
        if (!this.connection.driver.cteCapabilities.writable && !InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)) {
          throw new TypeORMError(`Only select queries are supported in CTEs in ${this.connection.options.type} (CTE: ${cte.alias})`);
        }
        this.setParameters(cte.queryBuilder.getParameters());
      }
      let cteHeader = this.escape(cte.alias);
      if (cte.options.columnNames) {
        const escapedColumnNames = cte.options.columnNames.map((column) => this.escape(column));
        if (InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)) {
          if (cte.queryBuilder.expressionMap.selects.length && cte.options.columnNames.length !== cte.queryBuilder.expressionMap.selects.length) {
            throw new TypeORMError(`cte.options.columnNames length (${cte.options.columnNames.length}) doesn't match subquery select list length ${cte.queryBuilder.expressionMap.selects.length} (CTE: ${cte.alias})`);
          }
        }
        cteHeader += `(${escapedColumnNames.join(", ")})`;
      }
      const recursiveClause = cte.options.recursive && databaseRequireRecusiveHint ? "RECURSIVE" : "";
      let materializeClause = "";
      if (this.connection.driver.cteCapabilities.materializedHint && cte.options.materialized !== void 0) {
        materializeClause = cte.options.materialized ? "MATERIALIZED" : "NOT MATERIALIZED";
      }
      return [recursiveClause, cteHeader, "AS", materializeClause, `(${cteBodyExpression})`].filter(Boolean).join(" ");
    });
    return "WITH " + cteStrings.join(", ") + " ";
  }
  /**
   * Creates "WHERE" condition for an in-ids condition.
   */
  getWhereInIdsCondition(ids) {
    const metadata = this.expressionMap.mainAlias.metadata;
    const normalized = (Array.isArray(ids) ? ids : [ids]).map((id) => metadata.ensureEntityIdMap(id));
    if (!metadata.hasMultiplePrimaryKeys) {
      const primaryColumn = metadata.primaryColumns[0];
      if (!primaryColumn.transformer && !primaryColumn.relationMetadata && !primaryColumn.embeddedMetadata) {
        return {
          [primaryColumn.propertyName]: In(normalized.map((id) => primaryColumn.getEntityValue(id, false)))
        };
      }
    }
    return new Brackets((qb) => {
      for (const data of normalized) {
        qb.orWhere(new Brackets((qb2) => qb2.where(data)));
      }
    });
  }
  getExistsCondition(subQuery) {
    const query = subQuery.clone().orderBy().groupBy().offset(void 0).limit(void 0).skip(void 0).take(void 0).select("1").setOption("disable-global-order");
    return [`EXISTS (${query.getQuery()})`, query.getParameters()];
  }
  findColumnsForPropertyPath(propertyPath) {
    let alias = this.expressionMap.mainAlias;
    const root = [];
    const propertyPathParts = propertyPath.split(".");
    while (propertyPathParts.length > 1) {
      const part = propertyPathParts[0];
      if (!alias?.hasMetadata) {
        break;
      }
      if (alias.metadata.hasEmbeddedWithPropertyPath(part)) {
        propertyPathParts.unshift(`${propertyPathParts.shift()}.${propertyPathParts.shift()}`);
        continue;
      }
      if (alias.metadata.hasRelationWithPropertyPath(part)) {
        const joinAttr = this.expressionMap.joinAttributes.find((joinAttr2) => joinAttr2.relationPropertyPath === part);
        if (!joinAttr?.alias) {
          const fullRelationPath = root.length > 0 ? `${root.join(".")}.${part}` : part;
          throw new Error(`Cannot find alias for relation at ${fullRelationPath}`);
        }
        alias = joinAttr.alias;
        root.push(...part.split("."));
        propertyPathParts.shift();
        continue;
      }
      break;
    }
    if (!alias) {
      throw new Error(`Cannot find alias for property ${propertyPath}`);
    }
    const aliasPropertyPath = propertyPathParts.join(".");
    const columns = alias.metadata.findColumnsWithPropertyPath(aliasPropertyPath);
    if (!columns.length) {
      throw new EntityPropertyNotFoundError(propertyPath, alias.metadata);
    }
    return [alias, root, columns];
  }
  /**
   * Creates a property paths for a given ObjectLiteral.
   */
  createPropertyPath(metadata, entity, prefix = "") {
    const paths = [];
    for (const key of Object.keys(entity)) {
      const path = prefix ? `${prefix}.${key}` : key;
      if (entity[key] === null || typeof entity[key] !== "object" || InstanceChecker.isFindOperator(entity[key])) {
        paths.push(path);
        continue;
      }
      if (metadata.hasEmbeddedWithPropertyPath(path)) {
        const subPaths = this.createPropertyPath(metadata, entity[key], path);
        paths.push(...subPaths);
        continue;
      }
      if (metadata.hasRelationWithPropertyPath(path)) {
        const relation = metadata.findRelationWithPropertyPath(path);
        if (relation.relationType === "one-to-one" || relation.relationType === "many-to-one") {
          const joinColumns = relation.joinColumns.map((j) => j.referencedColumn).filter((j) => !!j);
          const hasAllJoinColumns = joinColumns.length > 0 && joinColumns.every((column) => column.getEntityValue(entity[key], false));
          if (hasAllJoinColumns) {
            paths.push(path);
            continue;
          }
        }
        if (relation.relationType === "one-to-many" || relation.relationType === "many-to-many") {
          throw new Error(`Cannot query across ${relation.relationType} for property ${path}`);
        }
        const primaryColumns = relation.inverseEntityMetadata.primaryColumns;
        const hasAllPrimaryKeys = primaryColumns.length > 0 && primaryColumns.every((column) => column.getEntityValue(entity[key], false));
        if (hasAllPrimaryKeys) {
          const subPaths2 = primaryColumns.map((column) => `${path}.${column.propertyPath}`);
          paths.push(...subPaths2);
          continue;
        }
        const subPaths = this.createPropertyPath(relation.inverseEntityMetadata, entity[key]).map((p) => `${path}.${p}`);
        paths.push(...subPaths);
        continue;
      }
      paths.push(path);
    }
    return paths;
  }
  *getPredicates(where) {
    if (this.expressionMap.mainAlias.hasMetadata) {
      const propertyPaths = this.createPropertyPath(this.expressionMap.mainAlias.metadata, where);
      for (const propertyPath of propertyPaths) {
        const [alias, aliasPropertyPath, columns] = this.findColumnsForPropertyPath(propertyPath);
        for (const column of columns) {
          let containedWhere = where;
          for (const part of aliasPropertyPath) {
            if (!containedWhere || !(part in containedWhere)) {
              containedWhere = {};
              break;
            }
            containedWhere = containedWhere[part];
          }
          const aliasPath = this.expressionMap.aliasNamePrefixingEnabled ? `${alias.name}.${column.propertyPath}` : column.propertyPath;
          const parameterValue = column.getEntityValue(containedWhere, true);
          yield [aliasPath, parameterValue];
        }
      }
    } else {
      for (const key of Object.keys(where)) {
        const parameterValue = where[key];
        const aliasPath = this.expressionMap.aliasNamePrefixingEnabled ? `${this.alias}.${key}` : key;
        yield [aliasPath, parameterValue];
      }
    }
  }
  getWherePredicateCondition(aliasPath, parameterValue) {
    if (InstanceChecker.isFindOperator(parameterValue)) {
      let parameters = [];
      if (parameterValue.useParameter) {
        if (parameterValue.objectLiteralParameters) {
          this.setParameters(parameterValue.objectLiteralParameters);
        } else if (parameterValue.multipleParameters) {
          for (const v of parameterValue.value) {
            parameters.push(this.createParameter(v));
          }
        } else {
          parameters.push(this.createParameter(parameterValue.value));
        }
      }
      if (parameterValue.type === "raw") {
        if (parameterValue.getSql) {
          return parameterValue.getSql(aliasPath);
        } else {
          return {
            operator: "equal",
            parameters: [aliasPath, parameterValue.value]
          };
        }
      } else if (parameterValue.type === "not") {
        if (parameterValue.child) {
          return {
            operator: parameterValue.type,
            condition: this.getWherePredicateCondition(aliasPath, parameterValue.child)
          };
        } else {
          return {
            operator: "notEqual",
            parameters: [aliasPath, ...parameters]
          };
        }
      } else if (parameterValue.type === "and") {
        const values = parameterValue.value;
        return {
          operator: parameterValue.type,
          parameters: values.map((operator) => this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, operator)))
        };
      } else if (parameterValue.type === "or") {
        const values = parameterValue.value;
        return {
          operator: parameterValue.type,
          parameters: values.map((operator) => this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, operator)))
        };
      } else {
        return {
          operator: parameterValue.type,
          parameters: [aliasPath, ...parameters]
        };
      }
    } else {
      return {
        operator: "equal",
        parameters: [aliasPath, this.createParameter(parameterValue)]
      };
    }
  }
  getWhereCondition(where) {
    if (typeof where === "string") {
      return where;
    }
    if (InstanceChecker.isBrackets(where)) {
      const whereQueryBuilder = this.createQueryBuilder();
      whereQueryBuilder.parentQueryBuilder = this;
      whereQueryBuilder.expressionMap.mainAlias = this.expressionMap.mainAlias;
      whereQueryBuilder.expressionMap.aliasNamePrefixingEnabled = this.expressionMap.aliasNamePrefixingEnabled;
      whereQueryBuilder.expressionMap.parameters = this.expressionMap.parameters;
      whereQueryBuilder.expressionMap.nativeParameters = this.expressionMap.nativeParameters;
      whereQueryBuilder.expressionMap.wheres = [];
      where.whereFactory(whereQueryBuilder);
      return {
        operator: InstanceChecker.isNotBrackets(where) ? "not" : "brackets",
        condition: whereQueryBuilder.expressionMap.wheres
      };
    }
    if (typeof where === "function") {
      return where(this);
    }
    const wheres = Array.isArray(where) ? where : [where];
    const clauses = [];
    for (const where2 of wheres) {
      const conditions = [];
      for (const [aliasPath, parameterValue] of this.getPredicates(where2)) {
        conditions.push({
          type: "and",
          condition: this.getWherePredicateCondition(aliasPath, parameterValue)
        });
      }
      clauses.push({
        type: "or",
        condition: conditions
      });
    }
    if (clauses.length === 1) {
      return clauses[0].condition;
    }
    return clauses;
  }
  /**
   * Creates a query builder used to execute sql queries inside this query builder.
   */
  obtainQueryRunner() {
    return this.queryRunner || this.connection.createQueryRunner();
  }
  hasCommonTableExpressions() {
    return this.expressionMap.commonTableExpressions.length > 0;
  }
};
QueryBuilder.queryBuilderRegistry = {};

// ../node_modules/typeorm/browser/query-builder/result/DeleteResult.js
var DeleteResult = class {
  static from(queryResult) {
    const result = new this();
    result.raw = queryResult.records;
    result.affected = queryResult.affected;
    return result;
  }
};

// ../node_modules/typeorm/browser/query-builder/DeleteQueryBuilder.js
var DeleteQueryBuilder = class extends QueryBuilder {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connectionOrQueryBuilder, queryRunner) {
    super(connectionOrQueryBuilder, queryRunner);
    this["@instanceof"] = Symbol.for("DeleteQueryBuilder");
    this.expressionMap.aliasNamePrefixingEnabled = false;
  }
  // -------------------------------------------------------------------------
  // Public Implemented Methods
  // -------------------------------------------------------------------------
  /**
   * Gets generated SQL query without parameters being replaced.
   */
  getQuery() {
    let sql = this.createComment();
    sql += this.createCteExpression();
    sql += this.createDeleteExpression();
    return this.replacePropertyNamesForTheWholeQuery(sql.trim());
  }
  /**
   * Executes sql generated by query builder and returns raw database results.
   */
  execute() {
    return __async(this, null, function* () {
      const [sql, parameters] = this.getQueryAndParameters();
      const queryRunner = this.obtainQueryRunner();
      let transactionStartedByUs = false;
      try {
        if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
          yield queryRunner.startTransaction();
          transactionStartedByUs = true;
        }
        if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
          yield queryRunner.broadcaster.broadcast("BeforeRemove", this.expressionMap.mainAlias.metadata);
        }
        const queryResult = yield queryRunner.query(sql, parameters, true);
        const deleteResult = DeleteResult.from(queryResult);
        if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
          yield queryRunner.broadcaster.broadcast("AfterRemove", this.expressionMap.mainAlias.metadata);
        }
        if (transactionStartedByUs) yield queryRunner.commitTransaction();
        return deleteResult;
      } catch (error) {
        if (transactionStartedByUs) {
          try {
            yield queryRunner.rollbackTransaction();
          } catch (rollbackError) {
          }
        }
        throw error;
      } finally {
        if (queryRunner !== this.queryRunner) {
          yield queryRunner.release();
        }
      }
    });
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Specifies FROM which entity's table select/update/delete will be executed.
   * Also sets a main string alias of the selection data.
   */
  from(entityTarget, aliasName) {
    entityTarget = InstanceChecker.isEntitySchema(entityTarget) ? entityTarget.options.name : entityTarget;
    const mainAlias = this.createFromAlias(entityTarget, aliasName);
    this.expressionMap.setMainAlias(mainAlias);
    return this;
  }
  /**
   * Sets WHERE condition in the query builder.
   * If you had previously WHERE expression defined,
   * calling this function will override previously set WHERE conditions.
   * Additionally you can add parameters used in where expression.
   */
  where(where, parameters) {
    this.expressionMap.wheres = [];
    const condition = this.getWhereCondition(where);
    if (condition) this.expressionMap.wheres = [{
      type: "simple",
      condition
    }];
    if (parameters) this.setParameters(parameters);
    return this;
  }
  /**
   * Adds new AND WHERE condition in the query builder.
   * Additionally you can add parameters used in where expression.
   */
  andWhere(where, parameters) {
    this.expressionMap.wheres.push({
      type: "and",
      condition: this.getWhereCondition(where)
    });
    if (parameters) this.setParameters(parameters);
    return this;
  }
  /**
   * Adds new OR WHERE condition in the query builder.
   * Additionally you can add parameters used in where expression.
   */
  orWhere(where, parameters) {
    this.expressionMap.wheres.push({
      type: "or",
      condition: this.getWhereCondition(where)
    });
    if (parameters) this.setParameters(parameters);
    return this;
  }
  /**
   * Sets WHERE condition in the query builder with a condition for the given ids.
   * If you had previously WHERE expression defined,
   * calling this function will override previously set WHERE conditions.
   */
  whereInIds(ids) {
    return this.where(this.getWhereInIdsCondition(ids));
  }
  /**
   * Adds new AND WHERE with conditions for the given ids.
   */
  andWhereInIds(ids) {
    return this.andWhere(this.getWhereInIdsCondition(ids));
  }
  /**
   * Adds new OR WHERE with conditions for the given ids.
   */
  orWhereInIds(ids) {
    return this.orWhere(this.getWhereInIdsCondition(ids));
  }
  /**
   * Optional returning/output clause.
   */
  output(output) {
    return this.returning(output);
  }
  /**
   * Optional returning/output clause.
   */
  returning(returning) {
    if (!this.connection.driver.isReturningSqlSupported("delete")) {
      throw new ReturningStatementNotSupportedError();
    }
    this.expressionMap.returning = returning;
    return this;
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Creates DELETE express used to perform query.
   */
  createDeleteExpression() {
    const tableName = this.getTableName(this.getMainTableName());
    const whereExpression = this.createWhereExpression();
    const returningExpression = this.createReturningExpression("delete");
    if (returningExpression === "") {
      return `DELETE FROM ${tableName}${whereExpression}`;
    }
    if (this.connection.driver.options.type === "mssql") {
      return `DELETE FROM ${tableName} OUTPUT ${returningExpression}${whereExpression}`;
    }
    return `DELETE FROM ${tableName}${whereExpression} RETURNING ${returningExpression}`;
  }
};

// ../node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// ../node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// ../node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
}
var parse_default = parse;

// ../node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// ../node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// ../node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i = 0; i < input.length * 4; i++) {
    bytes[i] = input[i >> 2] >>> i % 4 * 8 & 255;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x = xpad;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return Uint32Array.of(a, b, c, d);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i = 0; i < input.length; i++) {
    output[i >> 2] |= (input[i] & 255) << i % 4 * 8;
  }
  return output;
}
function safeAdd(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// ../node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(version, hash2, value, namespace, buf, offset) {
  const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if (namespace?.length !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash2(bytes);
  bytes[6] = bytes[6] & 15 | version;
  bytes[8] = bytes[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}

// ../node_modules/uuid/dist/esm-browser/v3.js
function v3(value, namespace, buf, offset) {
  return v35(48, md5_default, value, namespace, buf, offset);
}
v3.DNS = DNS;
v3.URL = URL;

// ../node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// ../node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? options.rng?.() ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// ../node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 128;
  bytes = newBytes;
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
}
var sha1_default = sha1;

// ../node_modules/uuid/dist/esm-browser/v5.js
function v5(value, namespace, buf, offset) {
  return v35(80, sha1_default, value, namespace, buf, offset);
}
v5.DNS = DNS;
v5.URL = URL;

// ../node_modules/typeorm/browser/subscriber/BroadcasterResult.js
var BroadcasterResult = class {
  constructor() {
    this.count = 0;
    this.promises = [];
  }
  /**
   * Wait for all promises to settle
   */
  wait() {
    return __async(this, null, function* () {
      if (this.promises.length > 0) {
        yield Promise.all(this.promises);
      }
      return this;
    });
  }
};

// ../node_modules/typeorm/browser/query-builder/result/InsertResult.js
var InsertResult = class {
  constructor() {
    this.identifiers = [];
    this.generatedMaps = [];
  }
  static from(queryResult) {
    const result = new this();
    result.raw = queryResult.raw;
    return result;
  }
};

// ../node_modules/typeorm/browser/query-builder/ReturningResultsEntityUpdator.js
var ReturningResultsEntityUpdator = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(queryRunner, expressionMap) {
    this.queryRunner = queryRunner;
    this.expressionMap = expressionMap;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Updates entities with a special columns after updation query execution.
   */
  update(updateResult, entities) {
    return __async(this, null, function* () {
      const metadata = this.expressionMap.mainAlias.metadata;
      yield Promise.all(entities.map((entity, entityIndex) => __async(this, null, function* () {
        if (this.queryRunner.connection.driver.isReturningSqlSupported("update")) {
          if (this.queryRunner.connection.driver.options.type === "oracle" && Array.isArray(updateResult.raw) && this.expressionMap.extraReturningColumns.length > 0) {
            updateResult.raw = updateResult.raw.reduce((newRaw, rawItem, rawItemIndex) => {
              newRaw[this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];
              return newRaw;
            }, {});
          }
          const result = Array.isArray(updateResult.raw) ? updateResult.raw[entityIndex] : updateResult.raw;
          const returningColumns = this.queryRunner.connection.driver.createGeneratedMap(metadata, result);
          if (returningColumns) {
            this.queryRunner.manager.merge(metadata.target, entity, returningColumns);
            updateResult.generatedMaps.push(returningColumns);
          }
        } else {
          const updationColumns = this.expressionMap.extraReturningColumns;
          if (updationColumns.length > 0) {
            const entityId = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity);
            if (!entityId) throw new TypeORMError(`Cannot update entity because entity id is not set in the entity.`);
            const loadedReturningColumns = yield this.queryRunner.manager.createQueryBuilder().select(metadata.primaryColumns.map((column) => metadata.targetName + "." + column.propertyPath)).addSelect(updationColumns.map((column) => metadata.targetName + "." + column.propertyPath)).from(metadata.target, metadata.targetName).where(entityId).withDeleted().setOption("create-pojo").getOne();
            if (loadedReturningColumns) {
              this.queryRunner.manager.merge(metadata.target, entity, loadedReturningColumns);
              updateResult.generatedMaps.push(loadedReturningColumns);
            }
          }
        }
      })));
    });
  }
  /**
   * Updates entities with a special columns after insertion query execution.
   */
  insert(insertResult, entities) {
    return __async(this, null, function* () {
      const metadata = this.expressionMap.mainAlias.metadata;
      let insertionColumns = metadata.getInsertionReturningColumns();
      const needToCheckGenerated = this.queryRunner.connection.driver.isReturningSqlSupported("insert");
      insertionColumns = insertionColumns.filter((column) => {
        if (!column.isGenerated) return true;
        return needToCheckGenerated === true;
      });
      const generatedMaps = entities.map((entity, entityIndex) => {
        if (this.queryRunner.connection.driver.options.type === "oracle" && Array.isArray(insertResult.raw) && this.expressionMap.extraReturningColumns.length > 0) {
          insertResult.raw = insertResult.raw.reduce((newRaw, rawItem, rawItemIndex) => {
            newRaw[this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];
            return newRaw;
          }, {});
        }
        const result = Array.isArray(insertResult.raw) ? insertResult.raw[entityIndex] : insertResult.raw;
        const generatedMap = this.queryRunner.connection.driver.createGeneratedMap(metadata, result, entityIndex, entities.length) || {};
        if (entityIndex in this.expressionMap.locallyGenerated) {
          this.queryRunner.manager.merge(metadata.target, generatedMap, this.expressionMap.locallyGenerated[entityIndex]);
        }
        this.queryRunner.manager.merge(metadata.target, entity, generatedMap);
        return generatedMap;
      });
      if (insertionColumns.length > 0 && !this.queryRunner.connection.driver.isReturningSqlSupported("insert")) {
        const entityIds = entities.map((entity) => {
          const entityId = metadata.getEntityIdMap(entity);
          if (!entityId) throw new TypeORMError(`Cannot update entity because entity id is not set in the entity.`);
          return entityId;
        });
        const returningResult = yield this.queryRunner.manager.createQueryBuilder().select(metadata.primaryColumns.map((column) => metadata.targetName + "." + column.propertyPath)).addSelect(insertionColumns.map((column) => metadata.targetName + "." + column.propertyPath)).from(metadata.target, metadata.targetName).where(entityIds).setOption("create-pojo").getMany();
        entities.forEach((entity, entityIndex) => {
          this.queryRunner.manager.merge(metadata.target, generatedMaps[entityIndex], returningResult[entityIndex]);
          this.queryRunner.manager.merge(metadata.target, entity, returningResult[entityIndex]);
        });
      }
      entities.forEach((entity, entityIndex) => {
        const entityId = metadata.getEntityIdMap(entity);
        insertResult.identifiers.push(entityId);
        insertResult.generatedMaps.push(generatedMaps[entityIndex]);
      });
    });
  }
  /**
   * Columns we need to be returned from the database when we update entity.
   */
  getUpdationReturningColumns() {
    return this.expressionMap.mainAlias.metadata.columns.filter((column) => {
      return column.asExpression !== void 0 || column.isUpdateDate || column.isVersion;
    });
  }
  /**
   * Columns we need to be returned from the database when we soft delete and restore entity.
   */
  getSoftDeletionReturningColumns() {
    return this.expressionMap.mainAlias.metadata.columns.filter((column) => {
      return column.asExpression !== void 0 || column.isUpdateDate || column.isVersion || column.isDeleteDate;
    });
  }
};

// ../node_modules/typeorm/browser/query-builder/InsertQueryBuilder.js
var InsertQueryBuilder = class extends QueryBuilder {
  constructor() {
    super(...arguments);
    this["@instanceof"] = Symbol.for("InsertQueryBuilder");
  }
  // -------------------------------------------------------------------------
  // Public Implemented Methods
  // -------------------------------------------------------------------------
  /**
   * Gets generated SQL query without parameters being replaced.
   */
  getQuery() {
    let sql = this.createComment();
    sql += this.createCteExpression();
    sql += this.createInsertExpression();
    return this.replacePropertyNamesForTheWholeQuery(sql.trim());
  }
  /**
   * Executes sql generated by query builder and returns raw database results.
   */
  execute() {
    return __async(this, null, function* () {
      const valueSets = this.getValueSets();
      if (valueSets.length === 0) return new InsertResult();
      const queryRunner = this.obtainQueryRunner();
      let transactionStartedByUs = false;
      try {
        if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
          yield queryRunner.startTransaction();
          transactionStartedByUs = true;
        }
        if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
          const broadcastResult = new BroadcasterResult();
          valueSets.forEach((valueSet) => {
            queryRunner.broadcaster.broadcastBeforeInsertEvent(broadcastResult, this.expressionMap.mainAlias.metadata, valueSet);
          });
          yield broadcastResult.wait();
        }
        let declareSql = null;
        let selectOutputSql = null;
        const returningResultsEntityUpdator = new ReturningResultsEntityUpdator(queryRunner, this.expressionMap);
        const returningColumns = [];
        if (Array.isArray(this.expressionMap.returning) && this.expressionMap.mainAlias.hasMetadata) {
          for (const columnPath of this.expressionMap.returning) {
            returningColumns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnPath));
          }
        }
        if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata) {
          if (!(valueSets.length > 1 && this.connection.driver.options.type === "oracle")) {
            this.expressionMap.extraReturningColumns = this.expressionMap.mainAlias.metadata.getInsertionReturningColumns();
          }
          returningColumns.push(...this.expressionMap.extraReturningColumns.filter((c) => !returningColumns.includes(c)));
        }
        if (returningColumns.length > 0 && this.connection.driver.options.type === "mssql") {
          declareSql = this.connection.driver.buildTableVariableDeclaration("@OutputTable", returningColumns);
          selectOutputSql = `SELECT * FROM @OutputTable`;
        }
        const [insertSql, parameters] = this.getQueryAndParameters();
        const statements = [declareSql, insertSql, selectOutputSql];
        const sql = statements.filter((s) => s != null).join(";\n\n");
        const queryResult = yield queryRunner.query(sql, parameters, true);
        const insertResult = InsertResult.from(queryResult);
        if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata) {
          yield returningResultsEntityUpdator.insert(insertResult, valueSets);
        }
        if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
          const broadcastResult = new BroadcasterResult();
          valueSets.forEach((valueSet) => {
            queryRunner.broadcaster.broadcastAfterInsertEvent(broadcastResult, this.expressionMap.mainAlias.metadata, valueSet);
          });
          yield broadcastResult.wait();
        }
        if (transactionStartedByUs) {
          yield queryRunner.commitTransaction();
        }
        return insertResult;
      } catch (error) {
        if (transactionStartedByUs) {
          try {
            yield queryRunner.rollbackTransaction();
          } catch (rollbackError) {
          }
        }
        throw error;
      } finally {
        if (queryRunner !== this.queryRunner) {
          yield queryRunner.release();
        }
      }
    });
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Specifies INTO which entity's table insertion will be executed.
   */
  into(entityTarget, columns) {
    entityTarget = InstanceChecker.isEntitySchema(entityTarget) ? entityTarget.options.name : entityTarget;
    const mainAlias = this.createFromAlias(entityTarget);
    this.expressionMap.setMainAlias(mainAlias);
    this.expressionMap.insertColumns = columns || [];
    return this;
  }
  /**
   * Values needs to be inserted into table.
   */
  values(values) {
    this.expressionMap.valuesSet = values;
    return this;
  }
  /**
   * Optional returning/output clause.
   */
  output(output) {
    return this.returning(output);
  }
  /**
   * Optional returning/output clause.
   */
  returning(returning) {
    if (!this.connection.driver.isReturningSqlSupported("insert")) {
      throw new ReturningStatementNotSupportedError();
    }
    this.expressionMap.returning = returning;
    return this;
  }
  /**
   * Indicates if entity must be updated after insertion operations.
   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).
   * Enabled by default.
   */
  updateEntity(enabled) {
    this.expressionMap.updateEntity = enabled;
    return this;
  }
  /**
   * Adds additional ON CONFLICT statement supported in postgres and cockroach.
   *
   * @deprecated Use `orIgnore` or `orUpdate`
   */
  onConflict(statement) {
    this.expressionMap.onConflict = statement;
    return this;
  }
  /**
   * Adds additional ignore statement supported in databases.
   */
  orIgnore(statement = true) {
    this.expressionMap.onIgnore = !!statement;
    return this;
  }
  /**
   * Adds additional update statement supported in databases.
   */
  orUpdate(statementOrOverwrite, conflictTarget, orUpdateOptions) {
    if (!Array.isArray(statementOrOverwrite)) {
      this.expressionMap.onUpdate = {
        conflict: statementOrOverwrite?.conflict_target,
        columns: statementOrOverwrite?.columns,
        overwrite: statementOrOverwrite?.overwrite,
        skipUpdateIfNoValuesChanged: orUpdateOptions?.skipUpdateIfNoValuesChanged,
        upsertType: orUpdateOptions?.upsertType
      };
      return this;
    }
    this.expressionMap.onUpdate = {
      overwrite: statementOrOverwrite,
      conflict: conflictTarget,
      skipUpdateIfNoValuesChanged: orUpdateOptions?.skipUpdateIfNoValuesChanged,
      indexPredicate: orUpdateOptions?.indexPredicate,
      upsertType: orUpdateOptions?.upsertType
    };
    return this;
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Creates INSERT express used to perform insert query.
   */
  createInsertExpression() {
    const tableName = this.getTableName(this.getMainTableName());
    const valuesExpression = this.createValuesExpression();
    const returningExpression = this.connection.driver.options.type === "oracle" && this.getValueSets().length > 1 ? null : this.createReturningExpression("insert");
    const columnsExpression = this.createColumnNamesExpression();
    let query = "INSERT ";
    if (this.expressionMap.onUpdate?.upsertType === "primary-key") {
      query = "UPSERT ";
    }
    if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") {
      query += `${this.expressionMap.onIgnore ? " IGNORE " : ""}`;
    }
    query += `INTO ${tableName}`;
    if (this.alias !== this.getMainTableName() && DriverUtils.isPostgresFamily(this.connection.driver)) {
      query += ` AS "${this.alias}"`;
    }
    if (columnsExpression) {
      query += `(${columnsExpression})`;
    } else {
      if (!valuesExpression && (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql"))
        query += "()";
    }
    if (returningExpression && this.connection.driver.options.type === "mssql") {
      query += ` OUTPUT ${returningExpression}`;
    }
    if (valuesExpression) {
      if ((this.connection.driver.options.type === "oracle" || this.connection.driver.options.type === "sap") && this.getValueSets().length > 1) {
        query += ` ${valuesExpression}`;
      } else {
        query += ` VALUES ${valuesExpression}`;
      }
    } else {
      if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") {
        query += " VALUES ()";
      } else {
        query += ` DEFAULT VALUES`;
      }
    }
    if (this.expressionMap.onUpdate?.upsertType !== "primary-key") {
      if (this.connection.driver.supportedUpsertTypes.includes("on-conflict-do-update")) {
        if (this.expressionMap.onIgnore) {
          query += " ON CONFLICT DO NOTHING ";
        } else if (this.expressionMap.onConflict) {
          query += ` ON CONFLICT ${this.expressionMap.onConflict} `;
        } else if (this.expressionMap.onUpdate) {
          const {
            overwrite,
            columns,
            conflict,
            skipUpdateIfNoValuesChanged,
            indexPredicate
          } = this.expressionMap.onUpdate;
          let conflictTarget = "ON CONFLICT";
          if (Array.isArray(conflict)) {
            conflictTarget += ` ( ${conflict.map((column) => this.escape(column)).join(", ")} )`;
            if (indexPredicate && !DriverUtils.isPostgresFamily(this.connection.driver)) {
              throw new TypeORMError(`indexPredicate option is not supported by the current database driver`);
            }
            if (indexPredicate && DriverUtils.isPostgresFamily(this.connection.driver)) {
              conflictTarget += ` WHERE ( ${indexPredicate} )`;
            }
          } else if (conflict) {
            conflictTarget += ` ON CONSTRAINT ${this.escape(conflict)}`;
          }
          const updatePart = [];
          if (Array.isArray(overwrite)) {
            updatePart.push(...overwrite.map((column) => `${this.escape(column)} = EXCLUDED.${this.escape(column)}`));
          } else if (columns) {
            updatePart.push(...columns.map((column) => `${this.escape(column)} = :${column}`));
          }
          if (updatePart.length > 0) {
            query += ` ${conflictTarget} DO UPDATE SET `;
            updatePart.push(...this.expressionMap.mainAlias.metadata.columns.filter((column) => column.isUpdateDate && !overwrite?.includes(column.databaseName) && !(this.connection.driver.options.type === "oracle" && this.getValueSets().length > 1 || DriverUtils.isSQLiteFamily(this.connection.driver) || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner")).map((column) => `${this.escape(column.databaseName)} = DEFAULT`));
            query += updatePart.join(", ");
            query += " ";
          }
          if (Array.isArray(overwrite) && skipUpdateIfNoValuesChanged && DriverUtils.isPostgresFamily(this.connection.driver)) {
            query += ` WHERE (`;
            query += overwrite.map((column) => `${tableName}.${this.escape(column)} IS DISTINCT FROM EXCLUDED.${this.escape(column)}`).join(" OR ");
            query += ") ";
          }
        }
      } else if (this.connection.driver.supportedUpsertTypes.includes("on-duplicate-key-update")) {
        if (this.expressionMap.onUpdate) {
          const {
            overwrite,
            columns
          } = this.expressionMap.onUpdate;
          if (Array.isArray(overwrite)) {
            query += " ON DUPLICATE KEY UPDATE ";
            query += overwrite.map((column) => `${this.escape(column)} = VALUES(${this.escape(column)})`).join(", ");
            query += " ";
          } else if (Array.isArray(columns)) {
            query += " ON DUPLICATE KEY UPDATE ";
            query += columns.map((column) => `${this.escape(column)} = :${column}`).join(", ");
            query += " ";
          }
        }
      } else {
        if (this.expressionMap.onUpdate) {
          throw new TypeORMError(`onUpdate is not supported by the current database driver`);
        }
      }
    }
    if (returningExpression && (DriverUtils.isPostgresFamily(this.connection.driver) || this.connection.driver.options.type === "oracle" || this.connection.driver.options.type === "cockroachdb" || DriverUtils.isMySQLFamily(this.connection.driver))) {
      query += ` RETURNING ${returningExpression}`;
    }
    if (this.connection.driver.options.type === "mssql" && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.mainAlias.metadata.columns.filter((column) => this.expressionMap.insertColumns.length > 0 ? this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1 : column.isInsert).some((column) => this.isOverridingAutoIncrementBehavior(column))) {
      query = `SET IDENTITY_INSERT ${tableName} ON; ${query}; SET IDENTITY_INSERT ${tableName} OFF`;
    }
    return query;
  }
  /**
   * Gets list of columns where values must be inserted to.
   */
  getInsertedColumns() {
    if (!this.expressionMap.mainAlias.hasMetadata) return [];
    return this.expressionMap.mainAlias.metadata.columns.filter((column) => {
      if (this.expressionMap.insertColumns.length) return this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1;
      if (!column.isInsert) {
        return false;
      }
      if (column.isGenerated && column.generationStrategy === "increment" && !(this.connection.driver.options.type === "spanner") && !(this.connection.driver.options.type === "oracle") && !DriverUtils.isSQLiteFamily(this.connection.driver) && !DriverUtils.isMySQLFamily(this.connection.driver) && !(this.connection.driver.options.type === "aurora-mysql") && !(this.connection.driver.options.type === "mssql" && this.isOverridingAutoIncrementBehavior(column))) return false;
      return true;
    });
  }
  /**
   * Creates a columns string where values must be inserted to for INSERT INTO expression.
   */
  createColumnNamesExpression() {
    const columns = this.getInsertedColumns();
    if (columns.length > 0) return columns.map((column) => this.escape(column.databaseName)).join(", ");
    if (!this.expressionMap.mainAlias.hasMetadata && !this.expressionMap.insertColumns.length) {
      const valueSets = this.getValueSets();
      if (valueSets.length === 1) return Object.keys(valueSets[0]).map((columnName) => this.escape(columnName)).join(", ");
    }
    return this.expressionMap.insertColumns.map((columnName) => this.escape(columnName)).join(", ");
  }
  /**
   * Creates list of values needs to be inserted in the VALUES expression.
   */
  createValuesExpression() {
    const valueSets = this.getValueSets();
    const columns = this.getInsertedColumns();
    if (columns.length > 0) {
      let expression = "";
      valueSets.forEach((valueSet, valueSetIndex) => {
        columns.forEach((column, columnIndex) => {
          if (columnIndex === 0) {
            if (this.connection.driver.options.type === "oracle" && valueSets.length > 1) {
              expression += " SELECT ";
            } else if (this.connection.driver.options.type === "sap" && valueSets.length > 1) {
              expression += " SELECT ";
            } else {
              expression += "(";
            }
          }
          let value = column.getEntityValue(valueSet);
          if (!(typeof value === "function")) {
            value = this.connection.driver.preparePersistentValue(value, column);
          }
          if (column.isVersion && value === void 0) {
            expression += "1";
          } else if (column.isDiscriminator) {
            expression += this.createParameter(this.expressionMap.mainAlias.metadata.discriminatorValue);
          } else if (column.isGenerated && column.generationStrategy === "uuid" && !this.connection.driver.isUUIDGenerationSupported() && value === void 0) {
            value = v4_default();
            expression += this.createParameter(value);
            if (!(valueSetIndex in this.expressionMap.locallyGenerated)) {
              this.expressionMap.locallyGenerated[valueSetIndex] = {};
            }
            column.setEntityValue(this.expressionMap.locallyGenerated[valueSetIndex], value);
          } else if (value === void 0) {
            if (this.connection.driver.options.type === "oracle" && valueSets.length > 1 || DriverUtils.isSQLiteFamily(this.connection.driver) || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") {
              if (column.default !== void 0 && column.default !== null) {
                expression += this.connection.driver.normalizeDefault(column);
              } else {
                expression += "NULL";
              }
            } else {
              expression += "DEFAULT";
            }
          } else if (value === null && this.connection.driver.options.type === "spanner") {
            expression += "NULL";
          } else if (typeof value === "function") {
            expression += value();
          } else {
            if (this.connection.driver.options.type === "mssql") value = this.connection.driver.parametrizeValue(column, value);
            const paramName = this.createParameter(value);
            if ((DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
              const useLegacy = this.connection.driver.options.legacySpatialSupport;
              const geomFromText = useLegacy ? "GeomFromText" : "ST_GeomFromText";
              if (column.srid != null) {
                expression += `${geomFromText}(${paramName}, ${column.srid})`;
              } else {
                expression += `${geomFromText}(${paramName})`;
              }
            } else if (DriverUtils.isPostgresFamily(this.connection.driver) && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
              if (column.srid != null) {
                expression += `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`;
              } else {
                expression += `ST_GeomFromGeoJSON(${paramName})::${column.type}`;
              }
            } else if (this.connection.driver.options.type === "mssql" && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
              expression += column.type + "::STGeomFromText(" + paramName + ", " + (column.srid || "0") + ")";
            } else {
              expression += paramName;
            }
          }
          if (columnIndex === columns.length - 1) {
            if (valueSetIndex === valueSets.length - 1) {
              if (this.connection.driver.options.type === "oracle" && valueSets.length > 1) {
                expression += " FROM DUAL ";
              } else if (this.connection.driver.options.type === "sap" && valueSets.length > 1) {
                expression += " FROM dummy ";
              } else {
                expression += ")";
              }
            } else {
              if (this.connection.driver.options.type === "oracle" && valueSets.length > 1) {
                expression += " FROM DUAL UNION ALL ";
              } else if (this.connection.driver.options.type === "sap" && valueSets.length > 1) {
                expression += " FROM dummy UNION ALL ";
              } else {
                expression += "), ";
              }
            }
          } else {
            expression += ", ";
          }
        });
      });
      if (expression === "()") return "";
      return expression;
    } else {
      let expression = "";
      valueSets.forEach((valueSet, insertionIndex) => {
        const columns2 = Object.keys(valueSet);
        columns2.forEach((columnName, columnIndex) => {
          if (columnIndex === 0) {
            expression += "(";
          }
          const value = valueSet[columnName];
          if (typeof value === "function") {
            expression += value();
          } else if (value === void 0) {
            if (this.connection.driver.options.type === "oracle" && valueSets.length > 1 || DriverUtils.isSQLiteFamily(this.connection.driver) || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") {
              expression += "NULL";
            } else {
              expression += "DEFAULT";
            }
          } else if (value === null && this.connection.driver.options.type === "spanner") {
          } else {
            expression += this.createParameter(value);
          }
          if (columnIndex === Object.keys(valueSet).length - 1) {
            if (insertionIndex === valueSets.length - 1) {
              expression += ")";
            } else {
              expression += "), ";
            }
          } else {
            expression += ", ";
          }
        });
      });
      if (expression === "()") return "";
      return expression;
    }
  }
  /**
   * Gets array of values need to be inserted into the target table.
   */
  getValueSets() {
    if (Array.isArray(this.expressionMap.valuesSet)) return this.expressionMap.valuesSet;
    if (ObjectUtils.isObject(this.expressionMap.valuesSet)) return [this.expressionMap.valuesSet];
    throw new InsertValuesMissingError();
  }
  /**
   * Checks if column is an auto-generated primary key, but the current insertion specifies a value for it.
   *
   * @param column
   */
  isOverridingAutoIncrementBehavior(column) {
    return column.isPrimary && column.isGenerated && column.generationStrategy === "increment" && this.getValueSets().some((valueSet) => column.getEntityValue(valueSet) !== void 0 && column.getEntityValue(valueSet) !== null);
  }
};

// ../node_modules/typeorm/browser/query-builder/RelationUpdater.js
var RelationUpdater = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(queryBuilder, expressionMap) {
    this.queryBuilder = queryBuilder;
    this.expressionMap = expressionMap;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Performs set or add operation on a relation.
   */
  update(value) {
    return __async(this, null, function* () {
      const relation = this.expressionMap.relationMetadata;
      if (relation.isManyToOne || relation.isOneToOneOwner) {
        const updateSet = relation.joinColumns.reduce((updateSet2, joinColumn) => {
          const relationValue = ObjectUtils.isObject(value) ? joinColumn.referencedColumn.getEntityValue(value) : value;
          joinColumn.setEntityValue(updateSet2, relationValue);
          return updateSet2;
        }, {});
        if (!this.expressionMap.of || Array.isArray(this.expressionMap.of) && !this.expressionMap.of.length) return;
        yield this.queryBuilder.createQueryBuilder().update(relation.entityMetadata.target).set(updateSet).whereInIds(this.expressionMap.of).execute();
      } else if ((relation.isOneToOneNotOwner || relation.isOneToMany) && value === null) {
        const updateSet = {};
        relation.inverseRelation.joinColumns.forEach((column) => {
          updateSet[column.propertyName] = null;
        });
        const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];
        const parameters = {};
        const conditions = [];
        ofs.forEach((of, ofIndex) => {
          relation.inverseRelation.joinColumns.map((column, columnIndex) => {
            const parameterName = "joinColumn_" + ofIndex + "_" + columnIndex;
            parameters[parameterName] = ObjectUtils.isObject(of) ? column.referencedColumn.getEntityValue(of) : of;
            conditions.push(`${column.propertyPath} = :${parameterName}`);
          });
        });
        const condition = conditions.map((str) => "(" + str + ")").join(" OR ");
        if (!condition) return;
        yield this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).where(condition).setParameters(parameters).execute();
      } else if (relation.isOneToOneNotOwner || relation.isOneToMany) {
        if (Array.isArray(this.expressionMap.of)) throw new TypeORMError(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);
        const of = this.expressionMap.of;
        const updateSet = relation.inverseRelation.joinColumns.reduce((updateSet2, joinColumn) => {
          const relationValue = ObjectUtils.isObject(of) ? joinColumn.referencedColumn.getEntityValue(of) : of;
          joinColumn.setEntityValue(updateSet2, relationValue);
          return updateSet2;
        }, {});
        if (!value || Array.isArray(value) && !value.length) return;
        yield this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).whereInIds(value).execute();
      } else {
        const junctionMetadata = relation.junctionEntityMetadata;
        const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];
        const values = Array.isArray(value) ? value : [value];
        const firstColumnValues = relation.isManyToManyOwner ? ofs : values;
        const secondColumnValues = relation.isManyToManyOwner ? values : ofs;
        const bulkInserted = [];
        firstColumnValues.forEach((firstColumnVal) => {
          secondColumnValues.forEach((secondColumnVal) => {
            const inserted = {};
            junctionMetadata.ownerColumns.forEach((column) => {
              inserted[column.databaseName] = ObjectUtils.isObject(firstColumnVal) ? column.referencedColumn.getEntityValue(firstColumnVal) : firstColumnVal;
            });
            junctionMetadata.inverseColumns.forEach((column) => {
              inserted[column.databaseName] = ObjectUtils.isObject(secondColumnVal) ? column.referencedColumn.getEntityValue(secondColumnVal) : secondColumnVal;
            });
            bulkInserted.push(inserted);
          });
        });
        if (!bulkInserted.length) return;
        if (this.queryBuilder.connection.driver.options.type === "oracle" || this.queryBuilder.connection.driver.options.type === "sap") {
          yield Promise.all(bulkInserted.map((value2) => {
            return this.queryBuilder.createQueryBuilder().insert().into(junctionMetadata.tableName).values(value2).execute();
          }));
        } else {
          yield this.queryBuilder.createQueryBuilder().insert().into(junctionMetadata.tableName).values(bulkInserted).execute();
        }
      }
    });
  }
};

// ../node_modules/typeorm/browser/query-builder/RelationRemover.js
var RelationRemover = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(queryBuilder, expressionMap) {
    this.queryBuilder = queryBuilder;
    this.expressionMap = expressionMap;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Performs remove operation on a relation.
   */
  remove(value) {
    return __async(this, null, function* () {
      const relation = this.expressionMap.relationMetadata;
      if (relation.isOneToMany) {
        const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];
        const values = Array.isArray(value) ? value : [value];
        const updateSet = {};
        relation.inverseRelation.joinColumns.forEach((column) => {
          updateSet[column.propertyName] = null;
        });
        const parameters = {};
        const conditions = [];
        ofs.forEach((of, ofIndex) => {
          conditions.push(...values.map((value2, valueIndex) => {
            return [...relation.inverseRelation.joinColumns.map((column, columnIndex) => {
              const parameterName = "joinColumn_" + ofIndex + "_" + valueIndex + "_" + columnIndex;
              parameters[parameterName] = ObjectUtils.isObject(of) ? column.referencedColumn.getEntityValue(of) : of;
              return `${column.propertyPath} = :${parameterName}`;
            }), ...relation.inverseRelation.entityMetadata.primaryColumns.map((column, columnIndex) => {
              const parameterName = "primaryColumn_" + valueIndex + "_" + valueIndex + "_" + columnIndex;
              parameters[parameterName] = ObjectUtils.isObject(value2) ? column.getEntityValue(value2) : value2;
              return `${column.propertyPath} = :${parameterName}`;
            })].join(" AND ");
          }));
        });
        const condition = conditions.map((str) => "(" + str + ")").join(" OR ");
        if (!condition) return;
        yield this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).where(condition).setParameters(parameters).execute();
      } else {
        const junctionMetadata = relation.junctionEntityMetadata;
        const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];
        const values = Array.isArray(value) ? value : [value];
        const firstColumnValues = relation.isManyToManyOwner ? ofs : values;
        const secondColumnValues = relation.isManyToManyOwner ? values : ofs;
        const parameters = {};
        const conditions = [];
        firstColumnValues.forEach((firstColumnVal, firstColumnValIndex) => {
          conditions.push(...secondColumnValues.map((secondColumnVal, secondColumnValIndex) => {
            return [...junctionMetadata.ownerColumns.map((column, columnIndex) => {
              const parameterName = "firstValue_" + firstColumnValIndex + "_" + secondColumnValIndex + "_" + columnIndex;
              parameters[parameterName] = ObjectUtils.isObject(firstColumnVal) ? column.referencedColumn.getEntityValue(firstColumnVal) : firstColumnVal;
              return `${column.databaseName} = :${parameterName}`;
            }), ...junctionMetadata.inverseColumns.map((column, columnIndex) => {
              const parameterName = "secondValue_" + firstColumnValIndex + "_" + secondColumnValIndex + "_" + columnIndex;
              parameters[parameterName] = ObjectUtils.isObject(secondColumnVal) ? column.referencedColumn.getEntityValue(secondColumnVal) : secondColumnVal;
              return `${column.databaseName} = :${parameterName}`;
            })].join(" AND ");
          }));
        });
        const condition = conditions.map((str) => "(" + str + ")").join(" OR ");
        yield this.queryBuilder.createQueryBuilder().delete().from(junctionMetadata.tableName).where(condition).setParameters(parameters).execute();
      }
    });
  }
};

// ../node_modules/typeorm/browser/query-builder/RelationQueryBuilder.js
var RelationQueryBuilder = class extends QueryBuilder {
  constructor() {
    super(...arguments);
    this["@instanceof"] = Symbol.for("RelationQueryBuilder");
  }
  // -------------------------------------------------------------------------
  // Public Implemented Methods
  // -------------------------------------------------------------------------
  /**
   * Gets generated SQL query without parameters being replaced.
   */
  getQuery() {
    return "";
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Sets entity (target) which relations will be updated.
   */
  of(entity) {
    this.expressionMap.of = entity;
    return this;
  }
  /**
   * Sets entity relation's value.
   * Value can be entity, entity id or entity id map (if entity has composite ids).
   * Works only for many-to-one and one-to-one relations.
   * For many-to-many and one-to-many relations use #add and #remove methods instead.
   */
  set(value) {
    return __async(this, null, function* () {
      const relation = this.expressionMap.relationMetadata;
      if (!this.expressionMap.of)
        throw new TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);
      if (relation.isManyToMany || relation.isOneToMany) throw new TypeORMError(`Set operation is only supported for many-to-one and one-to-one relations. However given "${relation.propertyPath}" has ${relation.relationType} relation. Use .add() method instead.`);
      if (relation.joinColumns && relation.joinColumns.length > 1 && (!ObjectUtils.isObject(value) || Object.keys(value).length < relation.joinColumns.length)) throw new TypeORMError(`Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: "...", lastName: "..." })`);
      const updater = new RelationUpdater(this, this.expressionMap);
      return updater.update(value);
    });
  }
  /**
   * Adds (binds) given value to entity relation.
   * Value can be entity, entity id or entity id map (if entity has composite ids).
   * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).
   * Works only for many-to-many and one-to-many relations.
   * For many-to-one and one-to-one use #set method instead.
   */
  add(value) {
    return __async(this, null, function* () {
      if (Array.isArray(value) && value.length === 0) return;
      const relation = this.expressionMap.relationMetadata;
      if (!this.expressionMap.of)
        throw new TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);
      if (relation.isManyToOne || relation.isOneToOne) throw new TypeORMError(`Add operation is only supported for many-to-many and one-to-many relations. However given "${relation.propertyPath}" has ${relation.relationType} relation. Use .set() method instead.`);
      if (relation.joinColumns && relation.joinColumns.length > 1 && (!ObjectUtils.isObject(value) || Object.keys(value).length < relation.joinColumns.length)) throw new TypeORMError(`Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: "...", lastName: "..." })`);
      const updater = new RelationUpdater(this, this.expressionMap);
      return updater.update(value);
    });
  }
  /**
   * Removes (unbinds) given value from entity relation.
   * Value can be entity, entity id or entity id map (if entity has composite ids).
   * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).
   * Works only for many-to-many and one-to-many relations.
   * For many-to-one and one-to-one use #set method instead.
   */
  remove(value) {
    return __async(this, null, function* () {
      if (Array.isArray(value) && value.length === 0) return;
      const relation = this.expressionMap.relationMetadata;
      if (!this.expressionMap.of)
        throw new TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);
      if (relation.isManyToOne || relation.isOneToOne) throw new TypeORMError(`Add operation is only supported for many-to-many and one-to-many relations. However given "${relation.propertyPath}" has ${relation.relationType} relation. Use .set(null) method instead.`);
      const remover = new RelationRemover(this, this.expressionMap);
      return remover.remove(value);
    });
  }
  /**
   * Adds (binds) and removes (unbinds) given values to/from entity relation.
   * Value can be entity, entity id or entity id map (if entity has composite ids).
   * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).
   * Works only for many-to-many and one-to-many relations.
   * For many-to-one and one-to-one use #set method instead.
   */
  addAndRemove(added, removed) {
    return __async(this, null, function* () {
      yield this.remove(removed);
      yield this.add(added);
    });
  }
  /**
   * Gets entity's relation id.
  async getId(): Promise<any> {
   }*/
  /**
   * Gets entity's relation ids.
  async getIds(): Promise<any[]> {
      return [];
  }*/
  /**
   * Loads a single entity (relational) from the relation.
   * You can also provide id of relational entity to filter by.
   */
  loadOne() {
    return __async(this, null, function* () {
      return this.loadMany().then((results) => results[0]);
    });
  }
  /**
   * Loads many entities (relational) from the relation.
   * You can also provide ids of relational entities to filter by.
   */
  loadMany() {
    return __async(this, null, function* () {
      let of = this.expressionMap.of;
      if (!ObjectUtils.isObject(of)) {
        const metadata = this.expressionMap.mainAlias.metadata;
        if (metadata.hasMultiplePrimaryKeys) throw new TypeORMError(`Cannot load entity because only one primary key was specified, however entity contains multiple primary keys`);
        of = metadata.primaryColumns[0].createValueMap(of);
      }
      return this.connection.relationLoader.load(this.expressionMap.relationMetadata, of, this.queryRunner);
    });
  }
};

// ../node_modules/typeorm/browser/util/OrmUtils.js
var OrmUtils = class _OrmUtils {
  // -------------------------------------------------------------------------
  // Public methods
  // -------------------------------------------------------------------------
  /**
   * Chunks array into pieces.
   */
  static chunk(array, size) {
    return Array.from(Array(Math.ceil(array.length / size)), (_, i) => {
      return array.slice(i * size, i * size + size);
    });
  }
  static splitClassesAndStrings(classesAndStrings) {
    return [classesAndStrings.filter((cls) => typeof cls !== "string"), classesAndStrings.filter((str) => typeof str === "string")];
  }
  static groupBy(array, propertyCallback) {
    return array.reduce((groupedArray, value) => {
      const key = propertyCallback(value);
      let grouped = groupedArray.find((i) => i.id === key);
      if (!grouped) {
        grouped = {
          id: key,
          items: []
        };
        groupedArray.push(grouped);
      }
      grouped.items.push(value);
      return groupedArray;
    }, []);
  }
  static uniq(array, criteriaOrProperty) {
    return array.reduce((uniqueArray, item) => {
      let found = false;
      if (typeof criteriaOrProperty === "function") {
        const itemValue = criteriaOrProperty(item);
        found = !!uniqueArray.find((uniqueItem) => criteriaOrProperty(uniqueItem) === itemValue);
      } else if (typeof criteriaOrProperty === "string") {
        found = !!uniqueArray.find((uniqueItem) => uniqueItem[criteriaOrProperty] === item[criteriaOrProperty]);
      } else {
        found = uniqueArray.indexOf(item) !== -1;
      }
      if (!found) uniqueArray.push(item);
      return uniqueArray;
    }, []);
  }
  // Checks if it's an object made by Object.create(null), {} or new Object()
  static isPlainObject(item) {
    if (item === null || item === void 0) {
      return false;
    }
    return !item.constructor || item.constructor === Object;
  }
  static mergeArrayKey(target, key, value, memo) {
    if (memo.has(value)) {
      target[key] = memo.get(value);
      return;
    }
    if (value instanceof Promise) {
      return;
    }
    if (!this.isPlainObject(value) && !Array.isArray(value)) {
      target[key] = value;
      return;
    }
    if (!target[key]) {
      target[key] = Array.isArray(value) ? [] : {};
    }
    memo.set(value, target[key]);
    this.merge(target[key], value, memo);
    memo.delete(value);
  }
  static mergeObjectKey(target, key, value, memo) {
    if (memo.has(value)) {
      Object.assign(target, {
        [key]: memo.get(value)
      });
      return;
    }
    if (value instanceof Promise) {
      return;
    }
    if (!this.isPlainObject(value) && !Array.isArray(value)) {
      Object.assign(target, {
        [key]: value
      });
      return;
    }
    if (!target[key]) {
      Object.assign(target, {
        [key]: Array.isArray(value) ? [] : {}
      });
    }
    memo.set(value, target[key]);
    this.merge(target[key], value, memo);
    memo.delete(value);
  }
  static merge(target, source, memo = /* @__PURE__ */ new Map()) {
    if (this.isPlainObject(target) && this.isPlainObject(source)) {
      for (const key of Object.keys(source)) {
        if (key === "__proto__") continue;
        this.mergeObjectKey(target, key, source[key], memo);
      }
    }
    if (Array.isArray(target) && Array.isArray(source)) {
      for (let key = 0; key < source.length; key++) {
        this.mergeArrayKey(target, key, source[key], memo);
      }
    }
  }
  /**
   * Deep Object.assign.
   */
  static mergeDeep(target, ...sources) {
    if (!sources.length) {
      return target;
    }
    for (const source of sources) {
      _OrmUtils.merge(target, source);
    }
    return target;
  }
  /**
   * Deep compare objects.
   *
   * @see http://stackoverflow.com/a/1144249
   */
  static deepCompare(...args) {
    let i, l, leftChain, rightChain;
    if (arguments.length < 1) {
      return true;
    }
    for (i = 1, l = arguments.length; i < l; i++) {
      leftChain = [];
      rightChain = [];
      if (!this.compare2Objects(leftChain, rightChain, arguments[0], arguments[i])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Gets deeper value of object.
   */
  static deepValue(obj, path) {
    const segments = path.split(".");
    for (let i = 0, len = segments.length; i < len; i++) {
      obj = obj[segments[i]];
    }
    return obj;
  }
  static replaceEmptyObjectsWithBooleans(obj) {
    for (let key in obj) {
      if (obj[key] && typeof obj[key] === "object") {
        if (Object.keys(obj[key]).length === 0) {
          obj[key] = true;
        } else {
          this.replaceEmptyObjectsWithBooleans(obj[key]);
        }
      }
    }
  }
  static propertyPathsToTruthyObject(paths) {
    let obj = {};
    for (let path of paths) {
      const props = path.split(".");
      if (!props.length) continue;
      if (!obj[props[0]] || obj[props[0]] === true) {
        obj[props[0]] = {};
      }
      let recursiveChild = obj[props[0]];
      for (let [key, prop] of props.entries()) {
        if (key === 0) continue;
        if (recursiveChild[prop]) {
          recursiveChild = recursiveChild[prop];
        } else if (key === props.length - 1) {
          recursiveChild[prop] = {};
          recursiveChild = null;
        } else {
          recursiveChild[prop] = {};
          recursiveChild = recursiveChild[prop];
        }
      }
    }
    this.replaceEmptyObjectsWithBooleans(obj);
    return obj;
  }
  /**
   * Check if two entity-id-maps are the same
   */
  static compareIds(firstId, secondId) {
    if (firstId === void 0 || firstId === null || secondId === void 0 || secondId === null) return false;
    if ((typeof firstId.id === "string" && typeof secondId.id === "string" || typeof firstId.id === "number" && typeof secondId.id === "number") && Object.keys(firstId).length === 1 && Object.keys(secondId).length === 1) {
      return firstId.id === secondId.id;
    }
    return _OrmUtils.deepCompare(firstId, secondId);
  }
  /**
   * Transforms given value into boolean value.
   */
  static toBoolean(value) {
    if (typeof value === "boolean") return value;
    if (typeof value === "string") return value === "true" || value === "1";
    if (typeof value === "number") return value > 0;
    return false;
  }
  /**
   * Composes an object from the given array of keys and values.
   */
  static zipObject(keys, values) {
    return keys.reduce((object, column, index) => {
      object[column] = values[index];
      return object;
    }, {});
  }
  /**
   * Compares two arrays.
   */
  static isArraysEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) return false;
    return arr1.every((element) => {
      return arr2.indexOf(element) !== -1;
    });
  }
  static areMutuallyExclusive(...lists) {
    const haveSharedObjects = lists.some((list) => {
      const otherLists = lists.filter((otherList) => otherList !== list);
      return list.some((item) => otherLists.some((otherList) => otherList.includes(item)));
    });
    return !haveSharedObjects;
  }
  /**
   * Parses the CHECK constraint on the specified column and returns
   * all values allowed by the constraint or undefined if the constraint
   * is not present.
   */
  static parseSqlCheckExpression(sql, columnName) {
    const enumMatch = sql.match(new RegExp(`"${columnName}" varchar CHECK\\s*\\(\\s*"${columnName}"\\s+IN\\s*`));
    if (enumMatch && enumMatch.index) {
      const afterMatch = sql.substring(enumMatch.index + enumMatch[0].length);
      const chars = afterMatch;
      let currentQuotes = "";
      let nextValue = "";
      const enumValues = [];
      for (let idx = 0; idx < chars.length; idx++) {
        const char = chars[idx];
        switch (char) {
          case ",":
            if (currentQuotes == "") {
              enumValues.push(nextValue);
              nextValue = "";
            } else {
              nextValue += char;
            }
            break;
          case "'":
            if (currentQuotes == char) {
              const isNextCharQuote = chars[idx + 1] === char;
              if (isNextCharQuote) {
                nextValue += char;
                idx += 1;
              } else {
                currentQuotes = "";
              }
            } else {
              currentQuotes = char;
            }
            break;
          case ")":
            if (currentQuotes == "") {
              enumValues.push(nextValue);
              return enumValues;
            } else {
              nextValue += char;
            }
            break;
          default:
            if (currentQuotes != "") {
              nextValue += char;
            }
        }
      }
    }
    return void 0;
  }
  // -------------------------------------------------------------------------
  // Private methods
  // -------------------------------------------------------------------------
  static compare2Objects(leftChain, rightChain, x, y) {
    let p;
    if (Number.isNaN(x) && Number.isNaN(y)) return true;
    if (x === y) return true;
    if (x === null || y === null || x === void 0 || y === void 0) return false;
    if ((typeof x.equals === "function" || typeof x.equals === "function") && x.equals(y)) return true;
    if (typeof x === "function" && typeof y === "function" || x instanceof Date && y instanceof Date || x instanceof RegExp && y instanceof RegExp || typeof x === "string" && typeof y === "string" || typeof x === "number" && typeof y === "number") return x.toString() === y.toString();
    if (!(typeof x === "object" && typeof y === "object")) return false;
    if (Object.prototype.isPrototypeOf.call(x, y) || Object.prototype.isPrototypeOf.call(y, x)) return false;
    if (x.constructor !== y.constructor) return false;
    if (x.prototype !== y.prototype) return false;
    if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) return false;
    for (p in y) {
      if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
        return false;
      } else if (typeof y[p] !== typeof x[p]) {
        return false;
      }
    }
    for (p in x) {
      if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
        return false;
      } else if (typeof y[p] !== typeof x[p]) {
        return false;
      }
      switch (typeof x[p]) {
        case "object":
        case "function":
          leftChain.push(x);
          rightChain.push(y);
          if (!this.compare2Objects(leftChain, rightChain, x[p], y[p])) {
            return false;
          }
          leftChain.pop();
          rightChain.pop();
          break;
        default:
          if (x[p] !== y[p]) {
            return false;
          }
          break;
      }
    }
    return true;
  }
};

// ../node_modules/typeorm/browser/query-builder/transformer/RawSqlResultsToEntityTransformer.js
var RawSqlResultsToEntityTransformer = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(expressionMap, driver, rawRelationIdResults, rawRelationCountResults, queryRunner) {
    this.expressionMap = expressionMap;
    this.driver = driver;
    this.rawRelationIdResults = rawRelationIdResults;
    this.rawRelationCountResults = rawRelationCountResults;
    this.queryRunner = queryRunner;
    this.pojo = this.expressionMap.options.includes("create-pojo");
    this.selections = new Set(this.expressionMap.selects.map((s) => s.selection));
    this.aliasCache = /* @__PURE__ */ new Map();
    this.columnsCache = /* @__PURE__ */ new Map();
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated
   * we need to group our result and we must have some unique id (primary key in our case)
   */
  transform(rawResults, alias) {
    const group = this.group(rawResults, alias);
    const entities = [];
    for (const results of group.values()) {
      const entity = this.transformRawResultsGroup(results, alias);
      if (entity !== void 0) entities.push(entity);
    }
    return entities;
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Build an alias from a name and column name.
   */
  buildAlias(aliasName, columnName) {
    let aliases = this.aliasCache.get(aliasName);
    if (!aliases) {
      aliases = /* @__PURE__ */ new Map();
      this.aliasCache.set(aliasName, aliases);
    }
    let columnAlias = aliases.get(columnName);
    if (!columnAlias) {
      columnAlias = DriverUtils.buildAlias(this.driver, void 0, aliasName, columnName);
      aliases.set(columnName, columnAlias);
    }
    return columnAlias;
  }
  /**
   * Groups given raw results by ids of given alias.
   */
  group(rawResults, alias) {
    const map = /* @__PURE__ */ new Map();
    const keys = [];
    if (alias.metadata.tableType === "view") {
      keys.push(...alias.metadata.columns.map((column) => this.buildAlias(alias.name, column.databaseName)));
    } else {
      keys.push(...alias.metadata.primaryColumns.map((column) => this.buildAlias(alias.name, column.databaseName)));
    }
    for (const rawResult of rawResults) {
      const id = keys.map((key) => {
        const keyValue = rawResult[key];
        if (Buffer.isBuffer(keyValue)) {
          return keyValue.toString("hex");
        }
        if (ObjectUtils.isObject(keyValue)) {
          return JSON.stringify(keyValue);
        }
        return keyValue;
      }).join("_");
      const items = map.get(id);
      if (!items) {
        map.set(id, [rawResult]);
      } else {
        items.push(rawResult);
      }
    }
    return map;
  }
  /**
   * Transforms set of data results into single entity.
   */
  transformRawResultsGroup(rawResults, alias) {
    let metadata = alias.metadata;
    if (metadata.discriminatorColumn) {
      const discriminatorValues = rawResults.map((result) => result[this.buildAlias(alias.name, alias.metadata.discriminatorColumn.databaseName)]);
      const discriminatorMetadata = metadata.childEntityMetadatas.find((childEntityMetadata) => {
        return typeof discriminatorValues.find((value) => value === childEntityMetadata.discriminatorValue) !== "undefined";
      });
      if (discriminatorMetadata) metadata = discriminatorMetadata;
    }
    let entity = metadata.create(this.queryRunner, {
      fromDeserializer: true,
      pojo: this.pojo
    });
    const hasColumns = this.transformColumns(rawResults, alias, entity, metadata);
    const hasRelations = this.transformJoins(rawResults, entity, alias, metadata);
    const hasRelationIds = this.transformRelationIds(rawResults, alias, entity, metadata);
    const hasRelationCounts = this.transformRelationCounts(rawResults, alias, entity);
    if (hasColumns) return entity;
    const hasOnlyVirtualPrimaryColumns = metadata.primaryColumns.every((column) => column.isVirtual === true);
    if (hasOnlyVirtualPrimaryColumns && (hasRelations || hasRelationIds || hasRelationCounts)) return entity;
    return void 0;
  }
  // get value from columns selections and put them into object
  transformColumns(rawResults, alias, entity, metadata) {
    let hasData = false;
    const result = rawResults[0];
    for (const [key, column] of this.getColumnsToProcess(alias.name, metadata)) {
      const value = result[key];
      if (value === void 0) continue;
      else if (value !== null) hasData = true;
      column.setEntityValue(entity, this.driver.prepareHydratedValue(value, column));
    }
    return hasData;
  }
  /**
   * Transforms joined entities in the given raw results by a given alias and stores to the given (parent) entity
   */
  transformJoins(rawResults, entity, alias, metadata) {
    let hasData = false;
    for (const join of this.expressionMap.joinAttributes) {
      if (!join.metadata) continue;
      if (!join.isSelected) continue;
      if (join.relation && !metadata.relations.find((relation) => relation === join.relation)) continue;
      if (join.mapToProperty) {
        if (join.mapToPropertyParentAlias !== alias.name) continue;
      } else {
        if (!join.relation || join.parentAlias !== alias.name || join.relationPropertyPath !== join.relation.propertyPath) continue;
      }
      let result = this.transform(rawResults, join.alias);
      result = !join.isMany ? result[0] : result;
      result = !join.isMany && result === void 0 ? null : result;
      if (result === void 0) continue;
      if (join.mapToPropertyPropertyName) {
        entity[join.mapToPropertyPropertyName] = result;
      } else {
        join.relation.setEntityValue(entity, result);
      }
      hasData = true;
    }
    return hasData;
  }
  transformRelationIds(rawSqlResults, alias, entity, metadata) {
    let hasData = false;
    for (const [index, rawRelationIdResult] of this.rawRelationIdResults.entries()) {
      if (rawRelationIdResult.relationIdAttribute.parentAlias !== alias.name) continue;
      const relation = rawRelationIdResult.relationIdAttribute.relation;
      const valueMap = this.createValueMapFromJoinColumns(relation, rawRelationIdResult.relationIdAttribute.parentAlias, rawSqlResults);
      if (valueMap === void 0 || valueMap === null) {
        continue;
      }
      this.prepareDataForTransformRelationIds();
      const hash2 = this.hashEntityIds(relation, valueMap);
      const idMaps = this.relationIdMaps[index][hash2] || [];
      const properties = rawRelationIdResult.relationIdAttribute.mapToPropertyPropertyPath.split(".");
      const mapToProperty = (properties2, map, value) => {
        const property = properties2.shift();
        if (property && properties2.length === 0) {
          map[property] = value;
          return map;
        }
        if (property && properties2.length > 0) {
          mapToProperty(properties2, map[property], value);
        } else {
          return map;
        }
      };
      if (relation.isOneToOne || relation.isManyToOne) {
        if (idMaps[0] !== void 0) {
          mapToProperty(properties, entity, idMaps[0]);
          hasData = true;
        }
      } else {
        mapToProperty(properties, entity, idMaps);
        hasData = hasData || idMaps.length > 0;
      }
    }
    return hasData;
  }
  transformRelationCounts(rawSqlResults, alias, entity) {
    let hasData = false;
    for (const rawRelationCountResult of this.rawRelationCountResults) {
      if (rawRelationCountResult.relationCountAttribute.parentAlias !== alias.name) continue;
      const relation = rawRelationCountResult.relationCountAttribute.relation;
      let referenceColumnName;
      if (relation.isOneToMany) {
        referenceColumnName = relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;
      } else {
        referenceColumnName = relation.isOwning ? relation.joinColumns[0].referencedColumn.databaseName : relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;
      }
      const referenceColumnValue = rawSqlResults[0][this.buildAlias(alias.name, referenceColumnName)];
      if (referenceColumnValue !== void 0 && referenceColumnValue !== null) {
        entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = 0;
        for (const result of rawRelationCountResult.results) {
          if (result["parentId"] !== referenceColumnValue) continue;
          entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = parseInt(result["cnt"]);
          hasData = true;
        }
      }
    }
    return hasData;
  }
  getColumnsToProcess(aliasName, metadata) {
    let metadatas = this.columnsCache.get(aliasName);
    if (!metadatas) {
      metadatas = /* @__PURE__ */ new Map();
      this.columnsCache.set(aliasName, metadatas);
    }
    let columns = metadatas.get(metadata);
    if (!columns) {
      columns = metadata.columns.filter((column) => !column.isVirtual && // if user does not selected the whole entity or he used partial selection and does not select this particular column
      // then we don't add this column and its value into the entity
      (this.selections.has(aliasName) || this.selections.has(`${aliasName}.${column.propertyPath}`)) && // if table inheritance is used make sure this column is not child's column
      !metadata.childEntityMetadatas.some((childMetadata) => childMetadata.target === column.target)).map((column) => [this.buildAlias(aliasName, column.databaseName), column]);
      metadatas.set(metadata, columns);
    }
    return columns;
  }
  createValueMapFromJoinColumns(relation, parentAlias, rawSqlResults) {
    let columns;
    if (relation.isManyToOne || relation.isOneToOneOwner) {
      columns = relation.entityMetadata.primaryColumns.map((joinColumn) => joinColumn);
    } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
      columns = relation.inverseRelation.joinColumns.map((joinColumn) => joinColumn);
    } else {
      if (relation.isOwning) {
        columns = relation.joinColumns.map((joinColumn) => joinColumn);
      } else {
        columns = relation.inverseRelation.inverseJoinColumns.map((joinColumn) => joinColumn);
      }
    }
    return columns.reduce((valueMap, column) => {
      for (const rawSqlResult of rawSqlResults) {
        if (relation.isManyToOne || relation.isOneToOneOwner) {
          valueMap[column.databaseName] = this.driver.prepareHydratedValue(rawSqlResult[this.buildAlias(parentAlias, column.databaseName)], column);
        } else {
          valueMap[column.databaseName] = this.driver.prepareHydratedValue(rawSqlResult[this.buildAlias(parentAlias, column.referencedColumn.databaseName)], column.referencedColumn);
        }
      }
      return valueMap;
    }, {});
  }
  extractEntityPrimaryIds(relation, relationIdRawResult) {
    let columns;
    if (relation.isManyToOne || relation.isOneToOneOwner) {
      columns = relation.entityMetadata.primaryColumns.map((joinColumn) => joinColumn);
    } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
      columns = relation.inverseRelation.joinColumns.map((joinColumn) => joinColumn);
    } else {
      if (relation.isOwning) {
        columns = relation.joinColumns.map((joinColumn) => joinColumn);
      } else {
        columns = relation.inverseRelation.inverseJoinColumns.map((joinColumn) => joinColumn);
      }
    }
    return columns.reduce((data, column) => {
      data[column.databaseName] = relationIdRawResult[column.databaseName];
      return data;
    }, {});
  }
  /*private removeVirtualColumns(entity: ObjectLiteral, alias: Alias) {
      const virtualColumns = this.expressionMap.selects
          .filter(select => select.virtual)
          .map(select => select.selection.replace(alias.name + ".", ""));
       virtualColumns.forEach(virtualColumn => delete entity[virtualColumn]);
  }*/
  /** Prepare data to run #transformRelationIds, as a lot of result independent data is needed in every call */
  prepareDataForTransformRelationIds() {
    if (this.relationIdMaps) {
      return;
    }
    this.relationIdMaps = this.rawRelationIdResults.map((rawRelationIdResult) => {
      const relation = rawRelationIdResult.relationIdAttribute.relation;
      let columns;
      if (relation.isManyToOne || relation.isOneToOneOwner) {
        columns = relation.joinColumns;
      } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
        columns = relation.inverseEntityMetadata.primaryColumns;
      } else {
        if (relation.isOwning) {
          columns = relation.inverseJoinColumns;
        } else {
          columns = relation.inverseRelation.joinColumns;
        }
      }
      return rawRelationIdResult.results.reduce((agg, result) => {
        let idMap = columns.reduce((idMap2, column) => {
          let value = result[column.databaseName];
          if (relation.isOneToMany || relation.isOneToOneNotOwner) {
            if (column.isVirtual && column.referencedColumn && column.referencedColumn.propertyName !== column.propertyName) {
              value = column.referencedColumn.createValueMap(value);
            }
            return OrmUtils.mergeDeep(idMap2, column.createValueMap(value));
          }
          if (!column.isPrimary && column.referencedColumn.referencedColumn) {
            value = column.referencedColumn.referencedColumn.createValueMap(value);
          }
          return OrmUtils.mergeDeep(idMap2, column.referencedColumn.createValueMap(value));
        }, {});
        if (columns.length === 1 && !rawRelationIdResult.relationIdAttribute.disableMixedMap) {
          if (relation.isOneToMany || relation.isOneToOneNotOwner) {
            idMap = columns[0].getEntityValue(idMap);
          } else {
            idMap = columns[0].referencedColumn.getEntityValue(idMap);
          }
        }
        if (idMap !== void 0) {
          const hash2 = this.hashEntityIds(relation, result);
          if (agg[hash2]) {
            agg[hash2].push(idMap);
          } else {
            agg[hash2] = [idMap];
          }
        }
        return agg;
      }, {});
    });
  }
  /**
   * Use a simple JSON.stringify to create a simple hash of the primary ids of an entity.
   * As this.extractEntityPrimaryIds always creates the primary id object in the same order, if the same relation is
   * given, a simple JSON.stringify should be enough to get a unique hash per entity!
   */
  hashEntityIds(relation, data) {
    const entityPrimaryIds = this.extractEntityPrimaryIds(relation, data);
    return JSON.stringify(entityPrimaryIds);
  }
};

// ../node_modules/typeorm/browser/query-builder/relation-id/RelationIdLoader.js
var RelationIdLoader = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection, queryRunner, relationIdAttributes) {
    this.connection = connection;
    this.queryRunner = queryRunner;
    this.relationIdAttributes = relationIdAttributes;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  load(rawEntities) {
    return __async(this, null, function* () {
      const promises = this.relationIdAttributes.map((relationIdAttr) => __async(this, null, function* () {
        if (relationIdAttr.relation.isManyToOne || relationIdAttr.relation.isOneToOneOwner) {
          if (relationIdAttr.queryBuilderFactory) throw new TypeORMError("Additional condition can not be used with ManyToOne or OneToOne owner relations.");
          const duplicates = {};
          const results = rawEntities.map((rawEntity) => {
            const result = {};
            const duplicateParts = [];
            relationIdAttr.relation.joinColumns.forEach((joinColumn) => {
              result[joinColumn.databaseName] = this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils.buildAlias(this.connection.driver, void 0, relationIdAttr.parentAlias, joinColumn.databaseName)], joinColumn.referencedColumn);
              const duplicatePart = `${joinColumn.databaseName}:${result[joinColumn.databaseName]}`;
              if (duplicateParts.indexOf(duplicatePart) === -1) {
                duplicateParts.push(duplicatePart);
              }
            });
            relationIdAttr.relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {
              result[primaryColumn.databaseName] = this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils.buildAlias(this.connection.driver, void 0, relationIdAttr.parentAlias, primaryColumn.databaseName)], primaryColumn);
              const duplicatePart = `${primaryColumn.databaseName}:${result[primaryColumn.databaseName]}`;
              if (duplicateParts.indexOf(duplicatePart) === -1) {
                duplicateParts.push(duplicatePart);
              }
            });
            duplicateParts.sort();
            const duplicate = duplicateParts.join("::");
            if (duplicates[duplicate]) {
              return null;
            }
            duplicates[duplicate] = true;
            return result;
          }).filter((v) => v);
          return {
            relationIdAttribute: relationIdAttr,
            results
          };
        } else if (relationIdAttr.relation.isOneToMany || relationIdAttr.relation.isOneToOneNotOwner) {
          const relation = relationIdAttr.relation;
          const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.joinColumns;
          const table = relation.inverseEntityMetadata.target;
          const tableName = relation.inverseEntityMetadata.tableName;
          const tableAlias = relationIdAttr.alias || tableName;
          const duplicates = {};
          const parameters = {};
          const condition = rawEntities.map((rawEntity, index) => {
            const duplicateParts = [];
            const parameterParts = {};
            const queryPart = joinColumns.map((joinColumn) => {
              const parameterName = joinColumn.databaseName + index;
              const parameterValue = rawEntity[DriverUtils.buildAlias(this.connection.driver, void 0, relationIdAttr.parentAlias, joinColumn.referencedColumn.databaseName)];
              const duplicatePart = `${tableAlias}:${joinColumn.propertyPath}:${parameterValue}`;
              if (duplicateParts.indexOf(duplicatePart) !== -1) {
                return "";
              }
              duplicateParts.push(duplicatePart);
              parameterParts[parameterName] = parameterValue;
              return tableAlias + "." + joinColumn.propertyPath + " = :" + parameterName;
            }).filter((v) => v).join(" AND ");
            duplicateParts.sort();
            const duplicate = duplicateParts.join("::");
            if (duplicates[duplicate]) {
              return "";
            }
            duplicates[duplicate] = true;
            Object.assign(parameters, parameterParts);
            return queryPart;
          }).filter((v) => v).map((condition2) => "(" + condition2 + ")").join(" OR ");
          if (!condition) return {
            relationIdAttribute: relationIdAttr,
            results: []
          };
          const qb = this.connection.createQueryBuilder(this.queryRunner);
          const columns = OrmUtils.uniq([...joinColumns, ...relation.inverseRelation.entityMetadata.primaryColumns], (column) => column.propertyPath);
          columns.forEach((joinColumn) => {
            qb.addSelect(tableAlias + "." + joinColumn.propertyPath, joinColumn.databaseName);
          });
          qb.from(table, tableAlias).where("(" + condition + ")").setParameters(parameters);
          if (relationIdAttr.queryBuilderFactory) relationIdAttr.queryBuilderFactory(qb);
          const results = yield qb.getRawMany();
          results.forEach((result) => {
            joinColumns.forEach((column) => {
              result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn);
            });
            relation.inverseRelation.entityMetadata.primaryColumns.forEach((column) => {
              result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column);
            });
          });
          return {
            relationIdAttribute: relationIdAttr,
            results
          };
        } else {
          const relation = relationIdAttr.relation;
          const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.inverseJoinColumns;
          const inverseJoinColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation.joinColumns;
          const junctionAlias = relationIdAttr.junctionAlias;
          const inverseSideTableName = relationIdAttr.joinInverseSideMetadata.tableName;
          const inverseSideTableAlias = relationIdAttr.alias || inverseSideTableName;
          const junctionTableName = relation.isOwning ? relation.junctionEntityMetadata.tableName : relation.inverseRelation.junctionEntityMetadata.tableName;
          const mappedColumns = rawEntities.map((rawEntity) => {
            return joinColumns.reduce((map, joinColumn) => {
              map[joinColumn.propertyPath] = rawEntity[DriverUtils.buildAlias(this.connection.driver, void 0, relationIdAttr.parentAlias, joinColumn.referencedColumn.databaseName)];
              return map;
            }, {});
          });
          if (mappedColumns.length === 0) return {
            relationIdAttribute: relationIdAttr,
            results: []
          };
          const parameters = {};
          const duplicates = {};
          const joinColumnConditions = mappedColumns.map((mappedColumn, index) => {
            const duplicateParts = [];
            const parameterParts = {};
            const queryPart = Object.keys(mappedColumn).map((key) => {
              const parameterName = key + index;
              const parameterValue = mappedColumn[key];
              const duplicatePart = `${junctionAlias}:${key}:${parameterValue}`;
              if (duplicateParts.indexOf(duplicatePart) !== -1) {
                return "";
              }
              duplicateParts.push(duplicatePart);
              parameterParts[parameterName] = parameterValue;
              return junctionAlias + "." + key + " = :" + parameterName;
            }).filter((s) => s).join(" AND ");
            duplicateParts.sort();
            const duplicate = duplicateParts.join("::");
            if (duplicates[duplicate]) {
              return "";
            }
            duplicates[duplicate] = true;
            Object.assign(parameters, parameterParts);
            return queryPart;
          }).filter((s) => s);
          const inverseJoinColumnCondition = inverseJoinColumns.map((joinColumn) => {
            return junctionAlias + "." + joinColumn.propertyPath + " = " + inverseSideTableAlias + "." + joinColumn.referencedColumn.propertyPath;
          }).join(" AND ");
          const condition = joinColumnConditions.map((condition2) => {
            return "(" + condition2 + " AND " + inverseJoinColumnCondition + ")";
          }).join(" OR ");
          const qb = this.connection.createQueryBuilder(this.queryRunner);
          inverseJoinColumns.forEach((joinColumn) => {
            qb.addSelect(junctionAlias + "." + joinColumn.propertyPath, joinColumn.databaseName).addOrderBy(junctionAlias + "." + joinColumn.propertyPath);
          });
          joinColumns.forEach((joinColumn) => {
            qb.addSelect(junctionAlias + "." + joinColumn.propertyPath, joinColumn.databaseName).addOrderBy(junctionAlias + "." + joinColumn.propertyPath);
          });
          qb.from(inverseSideTableName, inverseSideTableAlias).innerJoin(junctionTableName, junctionAlias, condition).setParameters(parameters);
          if (relationIdAttr.queryBuilderFactory) relationIdAttr.queryBuilderFactory(qb);
          const results = yield qb.getRawMany();
          results.forEach((result) => {
            ;
            [...joinColumns, ...inverseJoinColumns].forEach((column) => {
              result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn);
            });
          });
          return {
            relationIdAttribute: relationIdAttr,
            results
          };
        }
      }));
      return Promise.all(promises);
    });
  }
};

// ../node_modules/typeorm/browser/query-builder/RelationIdLoader.js
var RelationIdLoader2 = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection, queryRunner) {
    this.connection = connection;
    this.queryRunner = queryRunner;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Loads relation ids of the given entity or entities.
   */
  load(relation, entityOrEntities, relatedEntityOrRelatedEntities) {
    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];
    const relatedEntities = Array.isArray(relatedEntityOrRelatedEntities) ? relatedEntityOrRelatedEntities : relatedEntityOrRelatedEntities ? [relatedEntityOrRelatedEntities] : void 0;
    if (relation.isManyToMany) {
      return this.loadForManyToMany(relation, entities, relatedEntities);
    } else if (relation.isManyToOne || relation.isOneToOneOwner) {
      return this.loadForManyToOneAndOneToOneOwner(relation, entities, relatedEntities);
    } else {
      return this.loadForOneToManyAndOneToOneNotOwner(relation, entities, relatedEntities);
    }
  }
  /**
   * Loads relation ids of the given entities and groups them into the object with parent and children.
   *
   * todo: extract this method?
   */
  loadManyToManyRelationIdsAndGroup(relation, entitiesOrEntities, relatedEntityOrEntities, queryBuilder) {
    return __async(this, null, function* () {
      const isMany = relation.isManyToMany || relation.isOneToMany;
      const entities = Array.isArray(entitiesOrEntities) ? entitiesOrEntities : [entitiesOrEntities];
      if (!relatedEntityOrEntities) {
        relatedEntityOrEntities = yield this.connection.relationLoader.load(relation, entitiesOrEntities, this.queryRunner, queryBuilder);
        if (!relatedEntityOrEntities.length) return entities.map((entity) => ({
          entity,
          related: isMany ? [] : void 0
        }));
      }
      const relationIds = yield this.load(relation, entitiesOrEntities, relatedEntityOrEntities);
      const relatedEntities = Array.isArray(relatedEntityOrEntities) ? relatedEntityOrEntities : [relatedEntityOrEntities];
      let columns = [], inverseColumns = [];
      if (relation.isManyToManyOwner) {
        columns = relation.junctionEntityMetadata.inverseColumns.map((column) => column.referencedColumn);
        inverseColumns = relation.junctionEntityMetadata.ownerColumns.map((column) => column.referencedColumn);
      } else if (relation.isManyToManyNotOwner) {
        columns = relation.junctionEntityMetadata.ownerColumns.map((column) => column.referencedColumn);
        inverseColumns = relation.junctionEntityMetadata.inverseColumns.map((column) => column.referencedColumn);
      } else if (relation.isManyToOne || relation.isOneToOneOwner) {
        columns = relation.joinColumns.map((column) => column.referencedColumn);
        inverseColumns = relation.entityMetadata.primaryColumns;
      } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
        columns = relation.inverseRelation.entityMetadata.primaryColumns;
        inverseColumns = relation.inverseRelation.joinColumns.map((column) => column.referencedColumn);
      } else {
      }
      return entities.map((entity) => {
        const group = {
          entity,
          related: isMany ? [] : void 0
        };
        const entityRelationIds = relationIds.filter((relationId) => {
          return inverseColumns.every((column) => {
            return column.compareEntityValue(entity, relationId[column.entityMetadata.name + "_" + column.propertyAliasName]);
          });
        });
        if (!entityRelationIds.length) return group;
        relatedEntities.forEach((relatedEntity) => {
          entityRelationIds.forEach((relationId) => {
            const relatedEntityMatched = columns.every((column) => {
              return column.compareEntityValue(relatedEntity, relationId[DriverUtils.buildAlias(this.connection.driver, void 0, column.entityMetadata.name + "_" + relation.propertyPath.replace(".", "_") + "_" + column.propertyPath.replace(".", "_"))]);
            });
            if (relatedEntityMatched) {
              if (isMany) {
                ;
                group.related.push(relatedEntity);
              } else {
                group.related = relatedEntity;
              }
            }
          });
        });
        return group;
      });
    });
  }
  /**
   * Loads relation ids of the given entities and maps them into the given entity property.
   async loadManyToManyRelationIdsAndMap(
   relation: RelationMetadata,
   entityOrEntities: ObjectLiteral|ObjectLiteral[],
   mapToEntityOrEntities: ObjectLiteral|ObjectLiteral[],
   propertyName: string
   ): Promise<void> {
      const relationIds = await this.loadManyToManyRelationIds(relation, entityOrEntities, mapToEntityOrEntities);
      const mapToEntities = mapToEntityOrEntities instanceof Array ? mapToEntityOrEntities : [mapToEntityOrEntities];
      const junctionMetadata = relation.junctionEntityMetadata!;
      const mainAlias = junctionMetadata.name;
      const columns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;
      const inverseColumns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;
      mapToEntities.forEach(mapToEntity => {
          mapToEntity[propertyName] = [];
          relationIds.forEach(relationId => {
              const match = inverseColumns.every(column => {
                  return column.referencedColumn!.getEntityValue(mapToEntity) === relationId[mainAlias + "_" + column.propertyName];
              });
              if (match) {
                  if (columns.length === 1) {
                      mapToEntity[propertyName].push(relationId[mainAlias + "_" + columns[0].propertyName]);
                  } else {
                      const value = {};
                      columns.forEach(column => {
                          column.referencedColumn!.setEntityValue(value, relationId[mainAlias + "_" + column.propertyName]);
                      });
                      mapToEntity[propertyName].push(value);
                  }
              }
          });
      });
  }*/
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Loads relation ids for the many-to-many relation.
   */
  loadForManyToMany(relation, entities, relatedEntities) {
    const junctionMetadata = relation.junctionEntityMetadata;
    const mainAlias = junctionMetadata.name;
    const columns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;
    const inverseColumns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;
    const qb = this.connection.createQueryBuilder(this.queryRunner);
    columns.forEach((column) => {
      const columnName = DriverUtils.buildAlias(this.connection.driver, void 0, column.referencedColumn.entityMetadata.name + "_" + column.referencedColumn.propertyPath.replace(".", "_"));
      qb.addSelect(mainAlias + "." + column.propertyPath, columnName);
    });
    inverseColumns.forEach((column) => {
      const columnName = DriverUtils.buildAlias(this.connection.driver, void 0, column.referencedColumn.entityMetadata.name + "_" + relation.propertyPath.replace(".", "_") + "_" + column.referencedColumn.propertyPath.replace(".", "_"));
      qb.addSelect(mainAlias + "." + column.propertyPath, columnName);
    });
    let condition1 = "";
    if (columns.length === 1) {
      const values = entities.map((entity) => columns[0].referencedColumn.getEntityValue(entity));
      const areAllNumbers = values.every((value) => typeof value === "number");
      if (areAllNumbers) {
        condition1 = `${mainAlias}.${columns[0].propertyPath} IN (${values.join(", ")})`;
      } else {
        qb.setParameter("values1", values);
        condition1 = mainAlias + "." + columns[0].propertyPath + " IN (:...values1)";
      }
    } else {
      condition1 = "(" + entities.map((entity, entityIndex) => {
        return columns.map((column) => {
          const paramName = "entity1_" + entityIndex + "_" + column.propertyName;
          qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity));
          return mainAlias + "." + column.propertyPath + " = :" + paramName;
        }).join(" AND ");
      }).map((condition3) => "(" + condition3 + ")").join(" OR ") + ")";
    }
    let condition2 = "";
    if (relatedEntities) {
      if (inverseColumns.length === 1) {
        const values = relatedEntities.map((entity) => inverseColumns[0].referencedColumn.getEntityValue(entity));
        const areAllNumbers = values.every((value) => typeof value === "number");
        if (areAllNumbers) {
          condition2 = `${mainAlias}.${inverseColumns[0].propertyPath} IN (${values.join(", ")})`;
        } else {
          qb.setParameter("values2", values);
          condition2 = mainAlias + "." + inverseColumns[0].propertyPath + " IN (:...values2)";
        }
      } else {
        condition2 = "(" + relatedEntities.map((entity, entityIndex) => {
          return inverseColumns.map((column) => {
            const paramName = "entity2_" + entityIndex + "_" + column.propertyName;
            qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity));
            return mainAlias + "." + column.propertyPath + " = :" + paramName;
          }).join(" AND ");
        }).map((condition3) => "(" + condition3 + ")").join(" OR ") + ")";
      }
    }
    const condition = [condition1, condition2].filter((v) => v.length > 0).join(" AND ");
    return qb.from(junctionMetadata.target, mainAlias).where(condition).getRawMany();
  }
  /**
   * Loads relation ids for the many-to-one and one-to-one owner relations.
   */
  loadForManyToOneAndOneToOneOwner(relation, entities, relatedEntities) {
    const mainAlias = relation.entityMetadata.targetName;
    const hasAllJoinColumnsInEntity = relation.joinColumns.every((joinColumn) => {
      return !!relation.entityMetadata.nonVirtualColumns.find((column) => column === joinColumn);
    });
    if (relatedEntities && hasAllJoinColumnsInEntity) {
      let relationIdMaps = [];
      entities.forEach((entity) => {
        let relationIdMap = {};
        relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {
          const key = primaryColumn.entityMetadata.name + "_" + primaryColumn.propertyPath.replace(".", "_");
          relationIdMap[key] = primaryColumn.getEntityValue(entity);
        });
        relatedEntities.forEach((relatedEntity) => {
          relation.joinColumns.forEach((joinColumn) => {
            const entityColumnValue = joinColumn.getEntityValue(entity);
            const relatedEntityColumnValue = joinColumn.referencedColumn.getEntityValue(relatedEntity);
            if (entityColumnValue === void 0 || relatedEntityColumnValue === void 0) return;
            if (entityColumnValue === relatedEntityColumnValue) {
              const key = joinColumn.referencedColumn.entityMetadata.name + "_" + relation.propertyPath.replace(".", "_") + "_" + joinColumn.referencedColumn.propertyPath.replace(".", "_");
              relationIdMap[key] = relatedEntityColumnValue;
            }
          });
        });
        if (Object.keys(relationIdMap).length === relation.entityMetadata.primaryColumns.length + relation.joinColumns.length) {
          relationIdMaps.push(relationIdMap);
        }
      });
      if (relationIdMaps.length === entities.length) return Promise.resolve(relationIdMaps);
    }
    const qb = this.connection.createQueryBuilder(this.queryRunner);
    relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {
      const columnName = DriverUtils.buildAlias(this.connection.driver, void 0, primaryColumn.entityMetadata.name + "_" + primaryColumn.propertyPath.replace(".", "_"));
      qb.addSelect(mainAlias + "." + primaryColumn.propertyPath, columnName);
    });
    relation.joinColumns.forEach((column) => {
      const columnName = DriverUtils.buildAlias(this.connection.driver, void 0, column.referencedColumn.entityMetadata.name + "_" + relation.propertyPath.replace(".", "_") + "_" + column.referencedColumn.propertyPath.replace(".", "_"));
      qb.addSelect(mainAlias + "." + column.propertyPath, columnName);
    });
    let condition = "";
    if (relation.entityMetadata.primaryColumns.length === 1) {
      const values = entities.map((entity) => relation.entityMetadata.primaryColumns[0].getEntityValue(entity));
      const areAllNumbers = values.every((value) => typeof value === "number");
      if (areAllNumbers) {
        condition = `${mainAlias}.${relation.entityMetadata.primaryColumns[0].propertyPath} IN (${values.join(", ")})`;
      } else {
        qb.setParameter("values", values);
        condition = mainAlias + "." + relation.entityMetadata.primaryColumns[0].propertyPath + " IN (:...values)";
      }
    } else {
      condition = entities.map((entity, entityIndex) => {
        return relation.entityMetadata.primaryColumns.map((column, columnIndex) => {
          const paramName = "entity" + entityIndex + "_" + columnIndex;
          qb.setParameter(paramName, column.getEntityValue(entity));
          return mainAlias + "." + column.propertyPath + " = :" + paramName;
        }).join(" AND ");
      }).map((condition2) => "(" + condition2 + ")").join(" OR ");
    }
    return qb.from(relation.entityMetadata.target, mainAlias).where(condition).getRawMany();
  }
  /**
   * Loads relation ids for the one-to-many and one-to-one not owner relations.
   */
  loadForOneToManyAndOneToOneNotOwner(relation, entities, relatedEntities) {
    relation = relation.inverseRelation;
    if (relation.entityMetadata.primaryColumns.length === relation.joinColumns.length) {
      const sameReferencedColumns = relation.entityMetadata.primaryColumns.every((column) => {
        return relation.joinColumns.indexOf(column) !== -1;
      });
      if (sameReferencedColumns) {
        return Promise.resolve(entities.map((entity) => {
          const result = {};
          relation.joinColumns.forEach(function(joinColumn) {
            const value = joinColumn.referencedColumn.getEntityValue(entity);
            const joinColumnName = joinColumn.referencedColumn.entityMetadata.name + "_" + joinColumn.referencedColumn.propertyPath.replace(".", "_");
            const primaryColumnName = joinColumn.entityMetadata.name + "_" + relation.inverseRelation.propertyPath.replace(".", "_") + "_" + joinColumn.propertyPath.replace(".", "_");
            result[joinColumnName] = value;
            result[primaryColumnName] = value;
          });
          return result;
        }));
      }
    }
    const mainAlias = relation.entityMetadata.targetName;
    const qb = this.connection.createQueryBuilder(this.queryRunner);
    relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {
      const columnName = DriverUtils.buildAlias(this.connection.driver, void 0, primaryColumn.entityMetadata.name + "_" + relation.inverseRelation.propertyPath.replace(".", "_") + "_" + primaryColumn.propertyPath.replace(".", "_"));
      qb.addSelect(mainAlias + "." + primaryColumn.propertyPath, columnName);
    });
    relation.joinColumns.forEach((column) => {
      const columnName = DriverUtils.buildAlias(this.connection.driver, void 0, column.referencedColumn.entityMetadata.name + "_" + column.referencedColumn.propertyPath.replace(".", "_"));
      qb.addSelect(mainAlias + "." + column.propertyPath, columnName);
    });
    let condition = "";
    if (relation.joinColumns.length === 1) {
      const values = entities.map((entity) => relation.joinColumns[0].referencedColumn.getEntityValue(entity));
      const areAllNumbers = values.every((value) => typeof value === "number");
      if (areAllNumbers) {
        condition = `${mainAlias}.${relation.joinColumns[0].propertyPath} IN (${values.join(", ")})`;
      } else {
        qb.setParameter("values", values);
        condition = mainAlias + "." + relation.joinColumns[0].propertyPath + " IN (:...values)";
      }
    } else {
      condition = entities.map((entity, entityIndex) => {
        return relation.joinColumns.map((joinColumn, joinColumnIndex) => {
          const paramName = "entity" + entityIndex + "_" + joinColumnIndex;
          qb.setParameter(paramName, joinColumn.referencedColumn.getEntityValue(entity));
          return mainAlias + "." + joinColumn.propertyPath + " = :" + paramName;
        }).join(" AND ");
      }).map((condition2) => "(" + condition2 + ")").join(" OR ");
    }
    return qb.from(relation.entityMetadata.target, mainAlias).where(condition).getRawMany();
  }
};

// ../node_modules/typeorm/browser/query-builder/relation-id/RelationIdMetadataToAttributeTransformer.js
var RelationIdMetadataToAttributeTransformer = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(expressionMap) {
    this.expressionMap = expressionMap;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  transform() {
    if (this.expressionMap.mainAlias) {
      this.expressionMap.mainAlias.metadata.relationIds.forEach((relationId) => {
        const attribute = this.metadataToAttribute(this.expressionMap.mainAlias.name, relationId);
        this.expressionMap.relationIdAttributes.push(attribute);
      });
    }
    this.expressionMap.joinAttributes.forEach((join) => {
      if (!join.metadata || join.metadata.isJunction) return;
      join.metadata.relationIds.forEach((relationId) => {
        const attribute = this.metadataToAttribute(join.alias.name, relationId);
        this.expressionMap.relationIdAttributes.push(attribute);
      });
    });
  }
  // -------------------------------------------------------------------------
  // Private Methods
  // -------------------------------------------------------------------------
  metadataToAttribute(parentAliasName, relationId) {
    return new RelationIdAttribute(this.expressionMap, {
      relationName: parentAliasName + "." + relationId.relation.propertyName,
      // category.images
      mapToProperty: parentAliasName + "." + relationId.propertyName,
      // category.imageIds
      alias: relationId.alias,
      queryBuilderFactory: relationId.queryBuilderFactory
    });
  }
};

// ../node_modules/typeorm/browser/query-builder/relation-count/RelationCountLoader.js
var RelationCountLoader = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection, queryRunner, relationCountAttributes) {
    this.connection = connection;
    this.queryRunner = queryRunner;
    this.relationCountAttributes = relationCountAttributes;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  load(rawEntities) {
    return __async(this, null, function* () {
      const onlyUnique = (value, index, self2) => {
        return self2.indexOf(value) === index;
      };
      const promises = this.relationCountAttributes.map((relationCountAttr) => __async(this, null, function* () {
        if (relationCountAttr.relation.isOneToMany) {
          const relation = relationCountAttr.relation;
          const inverseRelation = relation.inverseRelation;
          const referenceColumnName = inverseRelation.joinColumns[0].referencedColumn.propertyName;
          const inverseSideTable = relation.inverseEntityMetadata.target;
          const inverseSideTableName = relation.inverseEntityMetadata.tableName;
          const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName;
          const inverseSidePropertyName = inverseRelation.propertyName;
          let referenceColumnValues = rawEntities.map((rawEntity) => rawEntity[relationCountAttr.parentAlias + "_" + referenceColumnName]).filter((value) => !!value);
          referenceColumnValues = referenceColumnValues.filter(onlyUnique);
          if (referenceColumnValues.length === 0) return {
            relationCountAttribute: relationCountAttr,
            results: []
          };
          const qb = this.connection.createQueryBuilder(this.queryRunner);
          qb.select(inverseSideTableAlias + "." + inverseSidePropertyName, "parentId").addSelect("COUNT(*)", "cnt").from(inverseSideTable, inverseSideTableAlias).where(inverseSideTableAlias + "." + inverseSidePropertyName + " IN (:...ids)").addGroupBy(inverseSideTableAlias + "." + inverseSidePropertyName).setParameter("ids", referenceColumnValues);
          if (relationCountAttr.queryBuilderFactory) relationCountAttr.queryBuilderFactory(qb);
          return {
            relationCountAttribute: relationCountAttr,
            results: yield qb.getRawMany()
          };
        } else {
          let joinTableColumnName;
          let inverseJoinColumnName;
          let firstJunctionColumn;
          let secondJunctionColumn;
          if (relationCountAttr.relation.isOwning) {
            joinTableColumnName = relationCountAttr.relation.joinColumns[0].referencedColumn.databaseName;
            inverseJoinColumnName = relationCountAttr.relation.inverseJoinColumns[0].referencedColumn.databaseName;
            firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];
            secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];
          } else {
            joinTableColumnName = relationCountAttr.relation.inverseRelation.inverseJoinColumns[0].referencedColumn.databaseName;
            inverseJoinColumnName = relationCountAttr.relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;
            firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];
            secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];
          }
          let referenceColumnValues = rawEntities.map((rawEntity) => rawEntity[relationCountAttr.parentAlias + "_" + joinTableColumnName]).filter((value) => !!value);
          referenceColumnValues = referenceColumnValues.filter(onlyUnique);
          if (referenceColumnValues.length === 0) return {
            relationCountAttribute: relationCountAttr,
            results: []
          };
          const junctionAlias = relationCountAttr.junctionAlias;
          const inverseSideTableName = relationCountAttr.joinInverseSideMetadata.tableName;
          const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName;
          const junctionTableName = relationCountAttr.relation.junctionEntityMetadata.tableName;
          const condition = junctionAlias + "." + firstJunctionColumn.propertyName + " IN (" + referenceColumnValues.map((vals) => isNaN(vals) ? "'" + vals + "'" : vals) + ") AND " + junctionAlias + "." + secondJunctionColumn.propertyName + " = " + inverseSideTableAlias + "." + inverseJoinColumnName;
          const qb = this.connection.createQueryBuilder(this.queryRunner);
          qb.select(junctionAlias + "." + firstJunctionColumn.propertyName, "parentId").addSelect("COUNT(" + qb.escape(inverseSideTableAlias) + "." + qb.escape(inverseJoinColumnName) + ")", "cnt").from(inverseSideTableName, inverseSideTableAlias).innerJoin(junctionTableName, junctionAlias, condition).addGroupBy(junctionAlias + "." + firstJunctionColumn.propertyName);
          if (relationCountAttr.queryBuilderFactory) relationCountAttr.queryBuilderFactory(qb);
          return {
            relationCountAttribute: relationCountAttr,
            results: yield qb.getRawMany()
          };
        }
      }));
      return Promise.all(promises);
    });
  }
};

// ../node_modules/typeorm/browser/query-builder/relation-count/RelationCountMetadataToAttributeTransformer.js
var RelationCountMetadataToAttributeTransformer = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(expressionMap) {
    this.expressionMap = expressionMap;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  transform() {
    if (this.expressionMap.mainAlias) {
      this.expressionMap.mainAlias.metadata.relationCounts.forEach((relationCount) => {
        const attribute = this.metadataToAttribute(this.expressionMap.mainAlias.name, relationCount);
        this.expressionMap.relationCountAttributes.push(attribute);
      });
    }
    this.expressionMap.joinAttributes.forEach((join) => {
      if (!join.metadata || join.metadata.isJunction) return;
      join.metadata.relationCounts.forEach((relationCount) => {
        const attribute = this.metadataToAttribute(join.alias.name, relationCount);
        this.expressionMap.relationCountAttributes.push(attribute);
      });
    });
  }
  // -------------------------------------------------------------------------
  // Private Methods
  // -------------------------------------------------------------------------
  metadataToAttribute(parentAliasName, relationCount) {
    return new RelationCountAttribute(this.expressionMap, {
      relationName: parentAliasName + "." + relationCount.relation.propertyName,
      // category.images
      mapToProperty: parentAliasName + "." + relationCount.propertyName,
      // category.imageIds
      alias: relationCount.alias,
      queryBuilderFactory: relationCount.queryBuilderFactory
    });
  }
};

// ../node_modules/typeorm/browser/find-options/FindOptionsUtils.js
var FindOptionsUtils = class _FindOptionsUtils {
  // -------------------------------------------------------------------------
  // Public Static Methods
  // -------------------------------------------------------------------------
  /**
   * Checks if given object is really instance of FindOneOptions interface.
   */
  static isFindOneOptions(obj) {
    const possibleOptions = obj;
    return possibleOptions && (Array.isArray(possibleOptions.select) || Array.isArray(possibleOptions.relations) || typeof possibleOptions.select === "object" || typeof possibleOptions.relations === "object" || typeof possibleOptions.where === "object" || // typeof possibleOptions.where === "string" ||
    typeof possibleOptions.join === "object" || typeof possibleOptions.order === "object" || typeof possibleOptions.cache === "object" || typeof possibleOptions.cache === "boolean" || typeof possibleOptions.cache === "number" || typeof possibleOptions.comment === "string" || typeof possibleOptions.lock === "object" || typeof possibleOptions.loadRelationIds === "object" || typeof possibleOptions.loadRelationIds === "boolean" || typeof possibleOptions.loadEagerRelations === "boolean" || typeof possibleOptions.withDeleted === "boolean" || typeof possibleOptions.relationLoadStrategy === "string" || typeof possibleOptions.transaction === "boolean");
  }
  /**
   * Checks if given object is really instance of FindManyOptions interface.
   */
  static isFindManyOptions(obj) {
    const possibleOptions = obj;
    return possibleOptions && (this.isFindOneOptions(possibleOptions) || typeof possibleOptions.skip === "number" || typeof possibleOptions.take === "number" || typeof possibleOptions.skip === "string" || typeof possibleOptions.take === "string");
  }
  /**
   * Checks if given object is really instance of FindOptions interface.
   */
  static extractFindManyOptionsAlias(object) {
    if (this.isFindManyOptions(object) && object.join) return object.join.alias;
    return void 0;
  }
  /**
   * Applies give find many options to the given query builder.
   static applyFindManyOptionsOrConditionsToQueryBuilder<T>(qb: SelectQueryBuilder<T>, options: FindManyOptions<T>|Partial<T>|undefined): SelectQueryBuilder<T> {
      if (this.isFindManyOptions(options))
          return this.applyOptionsToQueryBuilder(qb, options);
       if (options)
          return qb.where(options);
       return qb;
  }*/
  /**
   * Applies give find options to the given query builder.
   static applyOptionsToQueryBuilder<T>(qb: SelectQueryBuilder<T>, options: FindOneOptions<T>|FindManyOptions<T>|undefined): SelectQueryBuilder<T> {
       // if options are not set then simply return query builder. This is made for simplicity of usage.
      if (!options || (!this.isFindOneOptions(options) && !this.isFindManyOptions(options)))
          return qb;
       if (options.transaction === true) {
          qb.expressionMap.useTransaction = true;
      }
       if (!qb.expressionMap.mainAlias || !qb.expressionMap.mainAlias.hasMetadata)
          return qb;
       const metadata = qb.expressionMap.mainAlias!.metadata;
       // apply all options from FindOptions
      if (options.comment) {
          qb.comment(options.comment);
      }
       if (options.withDeleted) {
          qb.withDeleted();
      }
       if (options.select) {
          qb.select([]);
          options.select.forEach(select => {
              if (!metadata.hasColumnWithPropertyPath(`${select}`))
                  throw new TypeORMError(`${select} column was not found in the ${metadata.name} entity.`);
               const columns = metadata.findColumnsWithPropertyPath(`${select}`);
               for (const column of columns) {
                  qb.addSelect(qb.alias + "." + column.propertyPath);
              }
          });
      }
       if (options.relations) {
          // Copy because `applyRelationsRecursively` modifies it
          const allRelations = [...options.relations];
          this.applyRelationsRecursively(qb, allRelations, qb.expressionMap.mainAlias!.name, qb.expressionMap.mainAlias!.metadata, "");
          // recursive removes found relations from allRelations array
          // if there are relations left in this array it means those relations were not found in the entity structure
          // so, we give an exception about not found relations
          if (allRelations.length > 0)
              throw new FindRelationsNotFoundError(allRelations);
      }
       if (options.join) {
          if (options.join.leftJoin)
              Object.keys(options.join.leftJoin).forEach(key => {
                  qb.leftJoin(options.join!.leftJoin![key], key);
              });
           if (options.join.innerJoin)
              Object.keys(options.join.innerJoin).forEach(key => {
                  qb.innerJoin(options.join!.innerJoin![key], key);
              });
           if (options.join.leftJoinAndSelect)
              Object.keys(options.join.leftJoinAndSelect).forEach(key => {
                  qb.leftJoinAndSelect(options.join!.leftJoinAndSelect![key], key);
              });
           if (options.join.innerJoinAndSelect)
              Object.keys(options.join.innerJoinAndSelect).forEach(key => {
                  qb.innerJoinAndSelect(options.join!.innerJoinAndSelect![key], key);
              });
      }
       if (options.cache) {
          if (options.cache instanceof Object) {
              const cache = options.cache as { id: any, milliseconds: number };
              qb.cache(cache.id, cache.milliseconds);
          } else {
              qb.cache(options.cache);
          }
      }
       if (options.lock) {
          if (options.lock.mode === "optimistic") {
              qb.setLock(options.lock.mode, options.lock.version);
          } else if (
              options.lock.mode === "pessimistic_read" ||
              options.lock.mode === "pessimistic_write" ||
              options.lock.mode === "dirty_read" ||
              options.lock.mode === "pessimistic_partial_write" ||
              options.lock.mode === "pessimistic_write_or_fail" ||
              options.lock.mode === "for_no_key_update" ||
              options.lock.mode === "for_key_share"
          ) {
              const tableNames = options.lock.tables ? options.lock.tables.map((table) => {
                  const tableAlias = qb.expressionMap.aliases.find((alias) => {
                      return alias.metadata.tableNameWithoutPrefix === table;
                  });
                  if (!tableAlias) {
                      throw new TypeORMError(`"${table}" is not part of this query`);
                  }
                  return qb.escape(tableAlias.name);
              }) : undefined;
              qb.setLock(options.lock.mode, undefined, tableNames);
          }
      }
       if (options.loadRelationIds === true) {
          qb.loadAllRelationIds();
       } else if (options.loadRelationIds instanceof Object) {
          qb.loadAllRelationIds(options.loadRelationIds as any);
      }
       if (options.where)
          qb.where(options.where);
       if ((options as FindManyOptions<T>).skip)
          qb.skip((options as FindManyOptions<T>).skip!);
       if ((options as FindManyOptions<T>).take)
          qb.take((options as FindManyOptions<T>).take!);
       if (options.order)
          Object.keys(options.order).forEach(key => {
              const order = ((options as FindOneOptions<T>).order as any)[key as any];
               if (!metadata.findColumnWithPropertyPath(key))
                  throw new Error(`${key} column was not found in the ${metadata.name} entity.`);
               switch (order) {
                  case 1:
                      qb.addOrderBy(qb.alias + "." + key, "ASC");
                      break;
                  case -1:
                      qb.addOrderBy(qb.alias + "." + key, "DESC");
                      break;
                  case "ASC":
                      qb.addOrderBy(qb.alias + "." + key, "ASC");
                      break;
                  case "DESC":
                      qb.addOrderBy(qb.alias + "." + key, "DESC");
                      break;
              }
          });
       return qb;
  }*/
  static applyOptionsToTreeQueryBuilder(qb, options) {
    if (options?.relations) {
      const allRelations = [...options.relations];
      _FindOptionsUtils.applyRelationsRecursively(qb, allRelations, qb.expressionMap.mainAlias.name, qb.expressionMap.mainAlias.metadata, "");
      if (allRelations.length > 0) throw new FindRelationsNotFoundError(allRelations);
    }
    return qb;
  }
  // -------------------------------------------------------------------------
  // Protected Static Methods
  // -------------------------------------------------------------------------
  /**
   * Adds joins for all relations and sub-relations of the given relations provided in the find options.
   */
  static applyRelationsRecursively(qb, allRelations, alias, metadata, prefix) {
    let matchedBaseRelations = [];
    if (prefix) {
      const regexp = new RegExp("^" + prefix.replace(".", "\\.") + "\\.");
      matchedBaseRelations = allRelations.filter((relation) => relation.match(regexp)).map((relation) => metadata.findRelationWithPropertyPath(relation.replace(regexp, ""))).filter((entity) => entity);
    } else {
      matchedBaseRelations = allRelations.map((relation) => metadata.findRelationWithPropertyPath(relation)).filter((entity) => entity);
    }
    matchedBaseRelations.forEach((relation) => {
      let relationAlias = DriverUtils.buildAlias(qb.connection.driver, {
        joiner: "__"
      }, alias, relation.propertyPath);
      const selection = alias + "." + relation.propertyPath;
      if (qb.expressionMap.relationLoadStrategy === "query") {
        qb.concatRelationMetadata(relation);
      } else {
        qb.leftJoinAndSelect(selection, relationAlias);
      }
      allRelations.splice(allRelations.indexOf(prefix ? prefix + "." + relation.propertyPath : relation.propertyPath), 1);
      let relationMetadata;
      let relationName;
      if (qb.expressionMap.relationLoadStrategy === "query") {
        relationMetadata = relation.inverseEntityMetadata;
        relationName = relationAlias;
      } else {
        const join = qb.expressionMap.joinAttributes.find((join2) => join2.entityOrProperty === selection);
        relationMetadata = join.metadata;
        relationName = join.alias.name;
      }
      if (!relationName || !relationMetadata) {
        throw new EntityPropertyNotFoundError(relation.propertyPath, metadata);
      }
      this.applyRelationsRecursively(qb, allRelations, relationName, relationMetadata, prefix ? prefix + "." + relation.propertyPath : relation.propertyPath);
      if (qb.expressionMap.relationLoadStrategy === "join") {
        const relMetadata = metadata.relations.find((metadata2) => metadata2.propertyName === relation.propertyPath);
        if (relMetadata) {
          this.joinEagerRelations(qb, relationAlias, relMetadata.inverseEntityMetadata);
        }
      }
    });
  }
  static joinEagerRelations(qb, alias, metadata) {
    metadata.eagerRelations.forEach((relation) => {
      let relationAlias = DriverUtils.buildAlias(qb.connection.driver, {
        joiner: "__"
      }, alias, relation.propertyName);
      let addJoin = true;
      for (const join of qb.expressionMap.joinAttributes) {
        if (join.condition !== void 0 || join.mapToProperty !== void 0 || join.isMappingMany !== void 0 || join.direction !== "LEFT" || join.entityOrProperty !== `${alias}.${relation.propertyPath}`) {
          continue;
        }
        addJoin = false;
        relationAlias = join.alias.name;
        break;
      }
      const joinAlreadyAdded = Boolean(qb.expressionMap.joinAttributes.find((joinAttribute) => joinAttribute.alias.name === relationAlias));
      if (addJoin && !joinAlreadyAdded) {
        qb.leftJoin(alias + "." + relation.propertyPath, relationAlias);
      }
      let addSelect = true;
      for (const select of qb.expressionMap.selects) {
        if (select.aliasName !== void 0 || select.virtual !== void 0 || select.selection !== relationAlias) {
          continue;
        }
        addSelect = false;
        break;
      }
      if (addSelect) {
        qb.addSelect(relationAlias);
      }
      this.joinEagerRelations(qb, relationAlias, relation.inverseEntityMetadata);
    });
  }
};

// ../node_modules/typeorm/browser/query-builder/SelectQueryBuilder.js
var SelectQueryBuilder = class _SelectQueryBuilder extends QueryBuilder {
  constructor() {
    super(...arguments);
    this["@instanceof"] = Symbol.for("SelectQueryBuilder");
    this.findOptions = {};
    this.selects = [];
    this.joins = [];
    this.conditions = "";
    this.orderBys = [];
    this.relationMetadatas = [];
  }
  // -------------------------------------------------------------------------
  // Public Implemented Methods
  // -------------------------------------------------------------------------
  /**
   * Gets generated SQL query without parameters being replaced.
   */
  getQuery() {
    let sql = this.createComment();
    sql += this.createCteExpression();
    sql += this.createSelectExpression();
    sql += this.createJoinExpression();
    sql += this.createWhereExpression();
    sql += this.createGroupByExpression();
    sql += this.createHavingExpression();
    sql += this.createOrderByExpression();
    sql += this.createLimitOffsetExpression();
    sql += this.createLockExpression();
    sql = sql.trim();
    if (this.expressionMap.subQuery) sql = "(" + sql + ")";
    return this.replacePropertyNamesForTheWholeQuery(sql);
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  setFindOptions(findOptions) {
    this.findOptions = findOptions;
    this.applyFindOptions();
    return this;
  }
  /**
   * Creates a subquery - query that can be used inside other queries.
   */
  subQuery() {
    const qb = this.createQueryBuilder();
    qb.expressionMap.subQuery = true;
    qb.parentQueryBuilder = this;
    return qb;
  }
  /**
   * Creates SELECT query and selects given data.
   * Replaces all previous selections if they exist.
   */
  select(selection, selectionAliasName) {
    this.expressionMap.queryType = "select";
    if (Array.isArray(selection)) {
      this.expressionMap.selects = selection.map((selection2) => ({
        selection: selection2
      }));
    } else if (typeof selection === "function") {
      const subQueryBuilder = selection(this.subQuery());
      this.setParameters(subQueryBuilder.getParameters());
      this.expressionMap.selects.push({
        selection: subQueryBuilder.getQuery(),
        aliasName: selectionAliasName
      });
    } else if (selection) {
      this.expressionMap.selects = [{
        selection,
        aliasName: selectionAliasName
      }];
    }
    return this;
  }
  /**
   * Adds new selection to the SELECT query.
   */
  addSelect(selection, selectionAliasName) {
    if (!selection) return this;
    if (Array.isArray(selection)) {
      this.expressionMap.selects = this.expressionMap.selects.concat(selection.map((selection2) => ({
        selection: selection2
      })));
    } else if (typeof selection === "function") {
      const subQueryBuilder = selection(this.subQuery());
      this.setParameters(subQueryBuilder.getParameters());
      this.expressionMap.selects.push({
        selection: subQueryBuilder.getQuery(),
        aliasName: selectionAliasName
      });
    } else if (selection) {
      this.expressionMap.selects.push({
        selection,
        aliasName: selectionAliasName
      });
    }
    return this;
  }
  /**
   * Set max execution time.
   * @param milliseconds
   */
  maxExecutionTime(milliseconds) {
    this.expressionMap.maxExecutionTime = milliseconds;
    return this;
  }
  /**
   * Sets whether the selection is DISTINCT.
   */
  distinct(distinct = true) {
    this.expressionMap.selectDistinct = distinct;
    return this;
  }
  /**
   * Sets the distinct on clause for Postgres.
   */
  distinctOn(distinctOn) {
    this.expressionMap.selectDistinctOn = distinctOn;
    return this;
  }
  fromDummy() {
    return this.from(this.connection.driver.dummyTableName ?? "(SELECT 1 AS dummy_column)", "dummy_table");
  }
  /**
   * Specifies FROM which entity's table select/update/delete will be executed.
   * Also sets a main string alias of the selection data.
   * Removes all previously set from-s.
   */
  from(entityTarget, aliasName) {
    const mainAlias = this.createFromAlias(entityTarget, aliasName);
    this.expressionMap.setMainAlias(mainAlias);
    return this;
  }
  /**
   * Specifies FROM which entity's table select/update/delete will be executed.
   * Also sets a main string alias of the selection data.
   */
  addFrom(entityTarget, aliasName) {
    const alias = this.createFromAlias(entityTarget, aliasName);
    if (!this.expressionMap.mainAlias) this.expressionMap.setMainAlias(alias);
    return this;
  }
  /**
   * INNER JOINs (without selection).
   * You also need to specify an alias of the joined data.
   * Optionally, you can add condition and parameters used in condition.
   */
  innerJoin(entityOrProperty, alias, condition, parameters) {
    this.join("INNER", entityOrProperty, alias, condition, parameters);
    return this;
  }
  /**
   * LEFT JOINs (without selection).
   * You also need to specify an alias of the joined data.
   * Optionally, you can add condition and parameters used in condition.
   */
  leftJoin(entityOrProperty, alias, condition, parameters) {
    this.join("LEFT", entityOrProperty, alias, condition, parameters);
    return this;
  }
  /**
   * INNER JOINs and adds all selection properties to SELECT.
   * You also need to specify an alias of the joined data.
   * Optionally, you can add condition and parameters used in condition.
   */
  innerJoinAndSelect(entityOrProperty, alias, condition, parameters) {
    this.addSelect(alias);
    this.innerJoin(entityOrProperty, alias, condition, parameters);
    return this;
  }
  /**
   * LEFT JOINs and adds all selection properties to SELECT.
   * You also need to specify an alias of the joined data.
   * Optionally, you can add condition and parameters used in condition.
   */
  leftJoinAndSelect(entityOrProperty, alias, condition, parameters) {
    this.addSelect(alias);
    this.leftJoin(entityOrProperty, alias, condition, parameters);
    return this;
  }
  /**
   * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
   * This is extremely useful when you want to select some data and map it to some virtual property.
   * It will assume that there are multiple rows of selecting data, and mapped result will be an array.
   * You also need to specify an alias of the joined data.
   * Optionally, you can add condition and parameters used in condition.
   */
  innerJoinAndMapMany(mapToProperty, entityOrProperty, alias, condition, parameters) {
    this.addSelect(alias);
    this.join("INNER", entityOrProperty, alias, condition, parameters, mapToProperty, true);
    return this;
  }
  /**
   * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
   * This is extremely useful when you want to select some data and map it to some virtual property.
   * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.
   * You also need to specify an alias of the joined data.
   * Optionally, you can add condition and parameters used in condition.
   */
  innerJoinAndMapOne(mapToProperty, entityOrProperty, alias, condition, parameters, mapAsEntity) {
    this.addSelect(alias);
    this.join("INNER", entityOrProperty, alias, condition, parameters, mapToProperty, false, mapAsEntity);
    return this;
  }
  /**
   * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
   * This is extremely useful when you want to select some data and map it to some virtual property.
   * It will assume that there are multiple rows of selecting data, and mapped result will be an array.
   * You also need to specify an alias of the joined data.
   * Optionally, you can add condition and parameters used in condition.
   */
  leftJoinAndMapMany(mapToProperty, entityOrProperty, alias, condition, parameters) {
    this.addSelect(alias);
    this.join("LEFT", entityOrProperty, alias, condition, parameters, mapToProperty, true);
    return this;
  }
  /**
   * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
   * This is extremely useful when you want to select some data and map it to some virtual property.
   * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.
   * You also need to specify an alias of the joined data.
   * Optionally, you can add condition and parameters used in condition.
   */
  leftJoinAndMapOne(mapToProperty, entityOrProperty, alias, condition, parameters, mapAsEntity) {
    this.addSelect(alias);
    this.join("LEFT", entityOrProperty, alias, condition, parameters, mapToProperty, false, mapAsEntity);
    return this;
  }
  /**
   * LEFT JOINs relation id and maps it into some entity's property.
   * Optionally, you can add condition and parameters used in condition.
   */
  loadRelationIdAndMap(mapToProperty, relationName, aliasNameOrOptions, queryBuilderFactory) {
    const relationIdAttribute = new RelationIdAttribute(this.expressionMap);
    relationIdAttribute.mapToProperty = mapToProperty;
    relationIdAttribute.relationName = relationName;
    if (typeof aliasNameOrOptions === "string") relationIdAttribute.alias = aliasNameOrOptions;
    if (typeof aliasNameOrOptions === "object" && aliasNameOrOptions.disableMixedMap) relationIdAttribute.disableMixedMap = true;
    relationIdAttribute.queryBuilderFactory = queryBuilderFactory;
    this.expressionMap.relationIdAttributes.push(relationIdAttribute);
    if (relationIdAttribute.relation.junctionEntityMetadata) {
      this.expressionMap.createAlias({
        type: "other",
        name: relationIdAttribute.junctionAlias,
        metadata: relationIdAttribute.relation.junctionEntityMetadata
      });
    }
    return this;
  }
  /**
   * Counts number of entities of entity's relation and maps the value into some entity's property.
   * Optionally, you can add condition and parameters used in condition.
   */
  loadRelationCountAndMap(mapToProperty, relationName, aliasName, queryBuilderFactory) {
    const relationCountAttribute = new RelationCountAttribute(this.expressionMap);
    relationCountAttribute.mapToProperty = mapToProperty;
    relationCountAttribute.relationName = relationName;
    relationCountAttribute.alias = aliasName;
    relationCountAttribute.queryBuilderFactory = queryBuilderFactory;
    this.expressionMap.relationCountAttributes.push(relationCountAttribute);
    this.expressionMap.createAlias({
      type: "other",
      name: relationCountAttribute.junctionAlias
    });
    if (relationCountAttribute.relation.junctionEntityMetadata) {
      this.expressionMap.createAlias({
        type: "other",
        name: relationCountAttribute.junctionAlias,
        metadata: relationCountAttribute.relation.junctionEntityMetadata
      });
    }
    return this;
  }
  /**
   * Loads all relation ids for all relations of the selected entity.
   * All relation ids will be mapped to relation property themself.
   * If array of strings is given then loads only relation ids of the given properties.
   */
  loadAllRelationIds(options) {
    this.expressionMap.mainAlias.metadata.relations.forEach((relation) => {
      if (options !== void 0 && options.relations !== void 0 && options.relations.indexOf(relation.propertyPath) === -1) return;
      this.loadRelationIdAndMap(this.expressionMap.mainAlias.name + "." + relation.propertyPath, this.expressionMap.mainAlias.name + "." + relation.propertyPath, options);
    });
    return this;
  }
  /**
   * Sets WHERE condition in the query builder.
   * If you had previously WHERE expression defined,
   * calling this function will override previously set WHERE conditions.
   * Additionally you can add parameters used in where expression.
   */
  where(where, parameters) {
    this.expressionMap.wheres = [];
    const condition = this.getWhereCondition(where);
    if (condition) {
      this.expressionMap.wheres = [{
        type: "simple",
        condition
      }];
    }
    if (parameters) this.setParameters(parameters);
    return this;
  }
  /**
   * Adds new AND WHERE condition in the query builder.
   * Additionally you can add parameters used in where expression.
   */
  andWhere(where, parameters) {
    this.expressionMap.wheres.push({
      type: "and",
      condition: this.getWhereCondition(where)
    });
    if (parameters) this.setParameters(parameters);
    return this;
  }
  /**
   * Adds new OR WHERE condition in the query builder.
   * Additionally you can add parameters used in where expression.
   */
  orWhere(where, parameters) {
    this.expressionMap.wheres.push({
      type: "or",
      condition: this.getWhereCondition(where)
    });
    if (parameters) this.setParameters(parameters);
    return this;
  }
  /**
   * Sets a new where EXISTS clause
   */
  whereExists(subQuery) {
    return this.where(...this.getExistsCondition(subQuery));
  }
  /**
   * Adds a new AND where EXISTS clause
   */
  andWhereExists(subQuery) {
    return this.andWhere(...this.getExistsCondition(subQuery));
  }
  /**
   * Adds a new OR where EXISTS clause
   */
  orWhereExists(subQuery) {
    return this.orWhere(...this.getExistsCondition(subQuery));
  }
  /**
   * Adds new AND WHERE with conditions for the given ids.
   *
   * Ids are mixed.
   * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].
   * If you have multiple primary keys you need to pass object with property names and values specified,
   * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]
   */
  whereInIds(ids) {
    return this.where(this.getWhereInIdsCondition(ids));
  }
  /**
   * Adds new AND WHERE with conditions for the given ids.
   *
   * Ids are mixed.
   * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].
   * If you have multiple primary keys you need to pass object with property names and values specified,
   * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]
   */
  andWhereInIds(ids) {
    return this.andWhere(this.getWhereInIdsCondition(ids));
  }
  /**
   * Adds new OR WHERE with conditions for the given ids.
   *
   * Ids are mixed.
   * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].
   * If you have multiple primary keys you need to pass object with property names and values specified,
   * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]
   */
  orWhereInIds(ids) {
    return this.orWhere(this.getWhereInIdsCondition(ids));
  }
  /**
   * Sets HAVING condition in the query builder.
   * If you had previously HAVING expression defined,
   * calling this function will override previously set HAVING conditions.
   * Additionally you can add parameters used in where expression.
   */
  having(having, parameters) {
    this.expressionMap.havings.push({
      type: "simple",
      condition: having
    });
    if (parameters) this.setParameters(parameters);
    return this;
  }
  /**
   * Adds new AND HAVING condition in the query builder.
   * Additionally you can add parameters used in where expression.
   */
  andHaving(having, parameters) {
    this.expressionMap.havings.push({
      type: "and",
      condition: having
    });
    if (parameters) this.setParameters(parameters);
    return this;
  }
  /**
   * Adds new OR HAVING condition in the query builder.
   * Additionally you can add parameters used in where expression.
   */
  orHaving(having, parameters) {
    this.expressionMap.havings.push({
      type: "or",
      condition: having
    });
    if (parameters) this.setParameters(parameters);
    return this;
  }
  /**
   * Sets GROUP BY condition in the query builder.
   * If you had previously GROUP BY expression defined,
   * calling this function will override previously set GROUP BY conditions.
   */
  groupBy(groupBy) {
    if (groupBy) {
      this.expressionMap.groupBys = [groupBy];
    } else {
      this.expressionMap.groupBys = [];
    }
    return this;
  }
  /**
   * Adds GROUP BY condition in the query builder.
   */
  addGroupBy(groupBy) {
    this.expressionMap.groupBys.push(groupBy);
    return this;
  }
  /**
   * Enables time travelling for the current query (only supported by cockroach currently)
   */
  timeTravelQuery(timeTravelFn) {
    if (this.connection.driver.options.type === "cockroachdb") {
      if (timeTravelFn === void 0) {
        this.expressionMap.timeTravel = "follower_read_timestamp()";
      } else {
        this.expressionMap.timeTravel = timeTravelFn;
      }
    }
    return this;
  }
  /**
   * Sets ORDER BY condition in the query builder.
   * If you had previously ORDER BY expression defined,
   * calling this function will override previously set ORDER BY conditions.
   */
  orderBy(sort, order = "ASC", nulls) {
    if (order !== void 0 && order !== "ASC" && order !== "DESC") throw new TypeORMError(`SelectQueryBuilder.addOrderBy "order" can accept only "ASC" and "DESC" values.`);
    if (nulls !== void 0 && nulls !== "NULLS FIRST" && nulls !== "NULLS LAST") throw new TypeORMError(`SelectQueryBuilder.addOrderBy "nulls" can accept only "NULLS FIRST" and "NULLS LAST" values.`);
    if (sort) {
      if (typeof sort === "object") {
        this.expressionMap.orderBys = sort;
      } else {
        if (nulls) {
          this.expressionMap.orderBys = {
            [sort]: {
              order,
              nulls
            }
          };
        } else {
          this.expressionMap.orderBys = {
            [sort]: order
          };
        }
      }
    } else {
      this.expressionMap.orderBys = {};
    }
    return this;
  }
  /**
   * Adds ORDER BY condition in the query builder.
   */
  addOrderBy(sort, order = "ASC", nulls) {
    if (order !== void 0 && order !== "ASC" && order !== "DESC") throw new TypeORMError(`SelectQueryBuilder.addOrderBy "order" can accept only "ASC" and "DESC" values.`);
    if (nulls !== void 0 && nulls !== "NULLS FIRST" && nulls !== "NULLS LAST") throw new TypeORMError(`SelectQueryBuilder.addOrderBy "nulls" can accept only "NULLS FIRST" and "NULLS LAST" values.`);
    if (nulls) {
      this.expressionMap.orderBys[sort] = {
        order,
        nulls
      };
    } else {
      this.expressionMap.orderBys[sort] = order;
    }
    return this;
  }
  /**
   * Sets LIMIT - maximum number of rows to be selected.
   * NOTE that it may not work as you expect if you are using joins.
   * If you want to implement pagination, and you are having join in your query,
   * then use the take method instead.
   */
  limit(limit) {
    this.expressionMap.limit = this.normalizeNumber(limit);
    if (this.expressionMap.limit !== void 0 && isNaN(this.expressionMap.limit)) throw new TypeORMError(`Provided "limit" value is not a number. Please provide a numeric value.`);
    return this;
  }
  /**
   * Sets OFFSET - selection offset.
   * NOTE that it may not work as you expect if you are using joins.
   * If you want to implement pagination, and you are having join in your query,
   * then use the skip method instead.
   */
  offset(offset) {
    this.expressionMap.offset = this.normalizeNumber(offset);
    if (this.expressionMap.offset !== void 0 && isNaN(this.expressionMap.offset)) throw new TypeORMError(`Provided "offset" value is not a number. Please provide a numeric value.`);
    return this;
  }
  /**
   * Sets maximal number of entities to take.
   */
  take(take) {
    this.expressionMap.take = this.normalizeNumber(take);
    if (this.expressionMap.take !== void 0 && isNaN(this.expressionMap.take)) throw new TypeORMError(`Provided "take" value is not a number. Please provide a numeric value.`);
    return this;
  }
  /**
   * Sets number of entities to skip.
   */
  skip(skip) {
    this.expressionMap.skip = this.normalizeNumber(skip);
    if (this.expressionMap.skip !== void 0 && isNaN(this.expressionMap.skip)) throw new TypeORMError(`Provided "skip" value is not a number. Please provide a numeric value.`);
    return this;
  }
  /**
   * Set certain index to be used by the query.
   *
   * @param index Name of index to be used.
   */
  useIndex(index) {
    this.expressionMap.useIndex = index;
    return this;
  }
  /**
   * Sets locking mode.
   */
  setLock(lockMode, lockVersion, lockTables) {
    this.expressionMap.lockMode = lockMode;
    this.expressionMap.lockVersion = lockVersion;
    this.expressionMap.lockTables = lockTables;
    return this;
  }
  /**
   * Sets lock handling by adding NO WAIT or SKIP LOCKED.
   */
  setOnLocked(onLocked) {
    this.expressionMap.onLocked = onLocked;
    return this;
  }
  /**
   * Disables the global condition of "non-deleted" for the entity with delete date columns.
   */
  withDeleted() {
    this.expressionMap.withDeleted = true;
    return this;
  }
  /**
   * Gets first raw result returned by execution of generated query builder sql.
   */
  getRawOne() {
    return __async(this, null, function* () {
      return (yield this.getRawMany())[0];
    });
  }
  /**
   * Gets all raw results returned by execution of generated query builder sql.
   */
  getRawMany() {
    return __async(this, null, function* () {
      if (this.expressionMap.lockMode === "optimistic") throw new OptimisticLockCanNotBeUsedError();
      this.expressionMap.queryEntity = false;
      const queryRunner = this.obtainQueryRunner();
      let transactionStartedByUs = false;
      try {
        if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
          yield queryRunner.startTransaction();
          transactionStartedByUs = true;
        }
        const results = yield this.loadRawResults(queryRunner);
        if (transactionStartedByUs) {
          yield queryRunner.commitTransaction();
        }
        return results;
      } catch (error) {
        if (transactionStartedByUs) {
          try {
            yield queryRunner.rollbackTransaction();
          } catch (rollbackError) {
          }
        }
        throw error;
      } finally {
        if (queryRunner !== this.queryRunner) {
          yield queryRunner.release();
        }
      }
    });
  }
  /**
   * Executes sql generated by query builder and returns object with raw results and entities created from them.
   */
  getRawAndEntities() {
    return __async(this, null, function* () {
      const queryRunner = this.obtainQueryRunner();
      let transactionStartedByUs = false;
      try {
        if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
          yield queryRunner.startTransaction();
          transactionStartedByUs = true;
        }
        this.expressionMap.queryEntity = true;
        const results = yield this.executeEntitiesAndRawResults(queryRunner);
        if (transactionStartedByUs) {
          yield queryRunner.commitTransaction();
        }
        return results;
      } catch (error) {
        if (transactionStartedByUs) {
          try {
            yield queryRunner.rollbackTransaction();
          } catch (rollbackError) {
          }
        }
        throw error;
      } finally {
        if (queryRunner !== this.queryRunner)
          yield queryRunner.release();
      }
    });
  }
  /**
   * Gets single entity returned by execution of generated query builder sql.
   */
  getOne() {
    return __async(this, null, function* () {
      const results = yield this.getRawAndEntities();
      const result = results.entities[0];
      if (result && this.expressionMap.lockMode === "optimistic" && this.expressionMap.lockVersion) {
        const metadata = this.expressionMap.mainAlias.metadata;
        if (this.expressionMap.lockVersion instanceof Date) {
          const actualVersion = metadata.updateDateColumn.getEntityValue(result);
          if (actualVersion.getTime() !== this.expressionMap.lockVersion.getTime()) throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);
        } else {
          const actualVersion = metadata.versionColumn.getEntityValue(result);
          if (actualVersion !== this.expressionMap.lockVersion) throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);
        }
      }
      if (result === void 0) {
        return null;
      }
      return result;
    });
  }
  /**
   * Gets the first entity returned by execution of generated query builder sql or rejects the returned promise on error.
   */
  getOneOrFail() {
    return __async(this, null, function* () {
      const entity = yield this.getOne();
      if (!entity) {
        throw new EntityNotFoundError(this.expressionMap.mainAlias.target, this.expressionMap.parameters);
      }
      return entity;
    });
  }
  /**
   * Gets entities returned by execution of generated query builder sql.
   */
  getMany() {
    return __async(this, null, function* () {
      if (this.expressionMap.lockMode === "optimistic") throw new OptimisticLockCanNotBeUsedError();
      const results = yield this.getRawAndEntities();
      return results.entities;
    });
  }
  /**
   * Gets count - number of entities selected by sql generated by this query builder.
   * Count excludes all limitations set by offset, limit, skip, and take.
   */
  getCount() {
    return __async(this, null, function* () {
      if (this.expressionMap.lockMode === "optimistic") throw new OptimisticLockCanNotBeUsedError();
      const queryRunner = this.obtainQueryRunner();
      let transactionStartedByUs = false;
      try {
        if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
          yield queryRunner.startTransaction();
          transactionStartedByUs = true;
        }
        this.expressionMap.queryEntity = false;
        const results = yield this.executeCountQuery(queryRunner);
        if (transactionStartedByUs) {
          yield queryRunner.commitTransaction();
        }
        return results;
      } catch (error) {
        if (transactionStartedByUs) {
          try {
            yield queryRunner.rollbackTransaction();
          } catch (rollbackError) {
          }
        }
        throw error;
      } finally {
        if (queryRunner !== this.queryRunner)
          yield queryRunner.release();
      }
    });
  }
  /**
   * Gets exists
   * Returns whether any rows exists matching current query.
   */
  getExists() {
    return __async(this, null, function* () {
      if (this.expressionMap.lockMode === "optimistic") throw new OptimisticLockCanNotBeUsedError();
      const queryRunner = this.obtainQueryRunner();
      let transactionStartedByUs = false;
      try {
        if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
          yield queryRunner.startTransaction();
          transactionStartedByUs = true;
        }
        this.expressionMap.queryEntity = false;
        const results = yield this.executeExistsQuery(queryRunner);
        if (transactionStartedByUs) {
          yield queryRunner.commitTransaction();
        }
        return results;
      } catch (error) {
        if (transactionStartedByUs) {
          try {
            yield queryRunner.rollbackTransaction();
          } catch (rollbackError) {
          }
        }
        throw error;
      } finally {
        if (queryRunner !== this.queryRunner)
          yield queryRunner.release();
      }
    });
  }
  /**
   * Executes built SQL query and returns entities and overall entities count (without limitation).
   * This method is useful to build pagination.
   */
  getManyAndCount() {
    return __async(this, null, function* () {
      if (this.expressionMap.lockMode === "optimistic") throw new OptimisticLockCanNotBeUsedError();
      const queryRunner = this.obtainQueryRunner();
      let transactionStartedByUs = false;
      try {
        if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
          yield queryRunner.startTransaction();
          transactionStartedByUs = true;
        }
        this.expressionMap.queryEntity = true;
        const entitiesAndRaw = yield this.executeEntitiesAndRawResults(queryRunner);
        this.expressionMap.queryEntity = false;
        const cacheId = this.expressionMap.cacheId;
        this.expressionMap.cacheId = cacheId ? `${cacheId}-count` : cacheId;
        const count = yield this.executeCountQuery(queryRunner);
        const results = [entitiesAndRaw.entities, count];
        if (transactionStartedByUs) {
          yield queryRunner.commitTransaction();
        }
        return results;
      } catch (error) {
        if (transactionStartedByUs) {
          try {
            yield queryRunner.rollbackTransaction();
          } catch (rollbackError) {
          }
        }
        throw error;
      } finally {
        if (queryRunner !== this.queryRunner)
          yield queryRunner.release();
      }
    });
  }
  /**
   * Executes built SQL query and returns raw data stream.
   */
  stream() {
    return __async(this, null, function* () {
      this.expressionMap.queryEntity = false;
      const [sql, parameters] = this.getQueryAndParameters();
      const queryRunner = this.obtainQueryRunner();
      let transactionStartedByUs = false;
      try {
        if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
          yield queryRunner.startTransaction();
          transactionStartedByUs = true;
        }
        const releaseFn = () => {
          if (queryRunner !== this.queryRunner)
            return queryRunner.release();
          return;
        };
        const results = queryRunner.stream(sql, parameters, releaseFn, releaseFn);
        if (transactionStartedByUs) {
          yield queryRunner.commitTransaction();
        }
        return results;
      } catch (error) {
        if (transactionStartedByUs) {
          try {
            yield queryRunner.rollbackTransaction();
          } catch (rollbackError) {
          }
        }
        throw error;
      }
    });
  }
  /**
   * Enables or disables query result caching.
   */
  cache(enabledOrMillisecondsOrId, maybeMilliseconds) {
    if (typeof enabledOrMillisecondsOrId === "boolean") {
      this.expressionMap.cache = enabledOrMillisecondsOrId;
    } else if (typeof enabledOrMillisecondsOrId === "number") {
      this.expressionMap.cache = true;
      this.expressionMap.cacheDuration = enabledOrMillisecondsOrId;
    } else if (typeof enabledOrMillisecondsOrId === "string" || typeof enabledOrMillisecondsOrId === "number") {
      this.expressionMap.cache = true;
      this.expressionMap.cacheId = enabledOrMillisecondsOrId;
    }
    if (maybeMilliseconds) {
      this.expressionMap.cacheDuration = maybeMilliseconds;
    }
    return this;
  }
  /**
   * Sets extra options that can be used to configure how query builder works.
   */
  setOption(option) {
    this.expressionMap.options.push(option);
    return this;
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  join(direction, entityOrProperty, aliasName, condition, parameters, mapToProperty, isMappingMany, mapAsEntity) {
    if (parameters) {
      this.setParameters(parameters);
    }
    const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);
    joinAttribute.direction = direction;
    joinAttribute.mapAsEntity = mapAsEntity;
    joinAttribute.mapToProperty = mapToProperty;
    joinAttribute.isMappingMany = isMappingMany;
    joinAttribute.entityOrProperty = entityOrProperty;
    joinAttribute.condition = condition;
    this.expressionMap.joinAttributes.push(joinAttribute);
    const joinAttributeMetadata = joinAttribute.metadata;
    if (joinAttributeMetadata) {
      if (joinAttributeMetadata.deleteDateColumn && !this.expressionMap.withDeleted) {
        const conditionDeleteColumn = `${aliasName}.${joinAttributeMetadata.deleteDateColumn.propertyName} IS NULL`;
        joinAttribute.condition = joinAttribute.condition ? ` ${joinAttribute.condition} AND ${conditionDeleteColumn}` : `${conditionDeleteColumn}`;
      }
      joinAttribute.alias = this.expressionMap.createAlias({
        type: "join",
        name: aliasName,
        metadata: joinAttributeMetadata
      });
      if (joinAttribute.relation && joinAttribute.relation.junctionEntityMetadata) {
        this.expressionMap.createAlias({
          type: "join",
          name: joinAttribute.junctionAlias,
          metadata: joinAttribute.relation.junctionEntityMetadata
        });
      }
    } else {
      let subQuery = "";
      if (typeof entityOrProperty === "function") {
        const subQueryBuilder = entityOrProperty(this.subQuery());
        this.setParameters(subQueryBuilder.getParameters());
        subQuery = subQueryBuilder.getQuery();
      } else {
        subQuery = entityOrProperty;
      }
      const isSubQuery = typeof entityOrProperty === "function" || entityOrProperty.substr(0, 1) === "(" && entityOrProperty.substr(-1) === ")";
      joinAttribute.alias = this.expressionMap.createAlias({
        type: "join",
        name: aliasName,
        tablePath: isSubQuery === false ? entityOrProperty : void 0,
        subQuery: isSubQuery === true ? subQuery : void 0
      });
    }
  }
  /**
   * Creates "SELECT FROM" part of SQL query.
   */
  createSelectExpression() {
    if (!this.expressionMap.mainAlias) throw new TypeORMError("Cannot build query because main alias is not set (call qb#from method)");
    const allSelects = [];
    const excludedSelects = [];
    if (this.expressionMap.mainAlias.hasMetadata) {
      const metadata = this.expressionMap.mainAlias.metadata;
      allSelects.push(...this.buildEscapedEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));
      excludedSelects.push(...this.findEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));
    }
    this.expressionMap.joinAttributes.forEach((join) => {
      if (join.metadata) {
        allSelects.push(...this.buildEscapedEntityColumnSelects(join.alias.name, join.metadata));
        excludedSelects.push(...this.findEntityColumnSelects(join.alias.name, join.metadata));
      } else {
        const hasMainAlias = this.expressionMap.selects.some((select2) => select2.selection === join.alias.name);
        if (hasMainAlias) {
          allSelects.push({
            selection: this.escape(join.alias.name) + ".*"
          });
          const excludedSelect = this.expressionMap.selects.find((select2) => select2.selection === join.alias.name);
          excludedSelects.push(excludedSelect);
        }
      }
    });
    this.expressionMap.selects.filter((select2) => excludedSelects.indexOf(select2) === -1).forEach((select2) => allSelects.push({
      selection: this.replacePropertyNames(select2.selection),
      aliasName: select2.aliasName
    }));
    if (allSelects.length === 0) allSelects.push({
      selection: "*"
    });
    let useIndex = "";
    if (this.expressionMap.useIndex) {
      if (DriverUtils.isMySQLFamily(this.connection.driver)) {
        useIndex = ` USE INDEX (${this.expressionMap.useIndex})`;
      }
    }
    const froms = this.expressionMap.aliases.filter((alias) => alias.type === "from" && (alias.tablePath || alias.subQuery)).map((alias) => {
      if (alias.subQuery) return alias.subQuery + " " + this.escape(alias.name);
      return this.getTableName(alias.tablePath) + " " + this.escape(alias.name);
    });
    const select = this.createSelectDistinctExpression();
    const selection = allSelects.map((select2) => select2.selection + (select2.aliasName ? " AS " + this.escape(select2.aliasName) : "")).join(", ");
    return select + selection + " FROM " + froms.join(", ") + this.createTableLockExpression() + useIndex;
  }
  /**
   * Creates select | select distinct part of SQL query.
   */
  createSelectDistinctExpression() {
    const {
      selectDistinct,
      selectDistinctOn,
      maxExecutionTime
    } = this.expressionMap;
    const {
      driver
    } = this.connection;
    let select = "SELECT ";
    if (maxExecutionTime > 0) {
      if (DriverUtils.isMySQLFamily(driver)) {
        select += `/*+ MAX_EXECUTION_TIME(${this.expressionMap.maxExecutionTime}) */ `;
      }
    }
    if (DriverUtils.isPostgresFamily(driver) && selectDistinctOn.length > 0) {
      const selectDistinctOnMap = selectDistinctOn.map((on) => this.replacePropertyNames(on)).join(", ");
      select = `SELECT DISTINCT ON (${selectDistinctOnMap}) `;
    } else if (selectDistinct) {
      select = "SELECT DISTINCT ";
    }
    return select;
  }
  /**
   * Creates "JOIN" part of SQL query.
   */
  createJoinExpression() {
    const joins = this.expressionMap.joinAttributes.map((joinAttr) => {
      const relation = joinAttr.relation;
      const destinationTableName = joinAttr.tablePath;
      const destinationTableAlias = joinAttr.alias.name;
      let appendedCondition = joinAttr.condition ? " AND (" + joinAttr.condition + ")" : "";
      const parentAlias = joinAttr.parentAlias;
      if (!parentAlias || !relation) {
        const destinationJoin = joinAttr.alias.subQuery ? joinAttr.alias.subQuery : this.getTableName(destinationTableName);
        return " " + joinAttr.direction + " JOIN " + destinationJoin + " " + this.escape(destinationTableAlias) + this.createTableLockExpression() + (joinAttr.condition ? " ON " + this.replacePropertyNames(joinAttr.condition) : "");
      }
      if (relation.isManyToOne || relation.isOneToOneOwner) {
        const condition = relation.joinColumns.map((joinColumn) => {
          return destinationTableAlias + "." + joinColumn.referencedColumn.propertyPath + "=" + parentAlias + "." + relation.propertyPath + "." + joinColumn.referencedColumn.propertyPath;
        }).join(" AND ");
        return " " + joinAttr.direction + " JOIN " + this.getTableName(destinationTableName) + " " + this.escape(destinationTableAlias) + this.createTableLockExpression() + " ON " + this.replacePropertyNames(condition + appendedCondition);
      } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
        const condition = relation.inverseRelation.joinColumns.map((joinColumn) => {
          if (relation.inverseEntityMetadata.tableType === "entity-child" && relation.inverseEntityMetadata.discriminatorColumn) {
            appendedCondition += " AND " + destinationTableAlias + "." + relation.inverseEntityMetadata.discriminatorColumn.databaseName + "='" + relation.inverseEntityMetadata.discriminatorValue + "'";
          }
          return destinationTableAlias + "." + relation.inverseRelation.propertyPath + "." + joinColumn.referencedColumn.propertyPath + "=" + parentAlias + "." + joinColumn.referencedColumn.propertyPath;
        }).join(" AND ");
        if (!condition) throw new TypeORMError(`Relation ${relation.entityMetadata.name}.${relation.propertyName} does not have join columns.`);
        return " " + joinAttr.direction + " JOIN " + this.getTableName(destinationTableName) + " " + this.escape(destinationTableAlias) + this.createTableLockExpression() + " ON " + this.replacePropertyNames(condition + appendedCondition);
      } else {
        const junctionTableName = relation.junctionEntityMetadata.tablePath;
        const junctionAlias = joinAttr.junctionAlias;
        let junctionCondition = "", destinationCondition = "";
        if (relation.isOwning) {
          junctionCondition = relation.joinColumns.map((joinColumn) => {
            return junctionAlias + "." + joinColumn.propertyPath + "=" + parentAlias + "." + joinColumn.referencedColumn.propertyPath;
          }).join(" AND ");
          destinationCondition = relation.inverseJoinColumns.map((joinColumn) => {
            return destinationTableAlias + "." + joinColumn.referencedColumn.propertyPath + "=" + junctionAlias + "." + joinColumn.propertyPath;
          }).join(" AND ");
        } else {
          junctionCondition = relation.inverseRelation.inverseJoinColumns.map((joinColumn) => {
            return junctionAlias + "." + joinColumn.propertyPath + "=" + parentAlias + "." + joinColumn.referencedColumn.propertyPath;
          }).join(" AND ");
          destinationCondition = relation.inverseRelation.joinColumns.map((joinColumn) => {
            return destinationTableAlias + "." + joinColumn.referencedColumn.propertyPath + "=" + junctionAlias + "." + joinColumn.propertyPath;
          }).join(" AND ");
        }
        return " " + joinAttr.direction + " JOIN " + this.getTableName(junctionTableName) + " " + this.escape(junctionAlias) + this.createTableLockExpression() + " ON " + this.replacePropertyNames(junctionCondition) + " " + joinAttr.direction + " JOIN " + this.getTableName(destinationTableName) + " " + this.escape(destinationTableAlias) + this.createTableLockExpression() + " ON " + this.replacePropertyNames(destinationCondition + appendedCondition);
      }
    });
    return joins.join(" ");
  }
  /**
   * Creates "GROUP BY" part of SQL query.
   */
  createGroupByExpression() {
    if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length) return "";
    return " GROUP BY " + this.replacePropertyNames(this.expressionMap.groupBys.join(", "));
  }
  /**
   * Creates "ORDER BY" part of SQL query.
   */
  createOrderByExpression() {
    const orderBys = this.expressionMap.allOrderBys;
    if (Object.keys(orderBys).length === 0) return "";
    return " ORDER BY " + Object.keys(orderBys).map((columnName) => {
      const orderValue = typeof orderBys[columnName] === "string" ? orderBys[columnName] : orderBys[columnName].order + " " + orderBys[columnName].nulls;
      const selection = this.expressionMap.selects.find((s) => s.selection === columnName);
      if (selection && !selection.aliasName && columnName.indexOf(".") !== -1) {
        const criteriaParts = columnName.split(".");
        const aliasName = criteriaParts[0];
        const propertyPath = criteriaParts.slice(1).join(".");
        const alias = this.expressionMap.aliases.find((alias2) => alias2.name === aliasName);
        if (alias) {
          const column = alias.metadata.findColumnWithPropertyPath(propertyPath);
          if (column) {
            const orderAlias = DriverUtils.buildAlias(this.connection.driver, void 0, aliasName, column.databaseName);
            return this.escape(orderAlias) + " " + orderValue;
          }
        }
      }
      return this.replacePropertyNames(columnName) + " " + orderValue;
    }).join(", ");
  }
  /**
   * Creates "LIMIT" and "OFFSET" parts of SQL query.
   */
  createLimitOffsetExpression() {
    let offset = this.expressionMap.offset, limit = this.expressionMap.limit;
    if (!offset && !limit && this.expressionMap.joinAttributes.length === 0) {
      offset = this.expressionMap.skip;
      limit = this.expressionMap.take;
    }
    if (this.connection.driver.options.type === "mssql") {
      let prefix = "";
      if ((limit || offset) && Object.keys(this.expressionMap.allOrderBys).length <= 0) {
        prefix = " ORDER BY (SELECT NULL)";
      }
      if (limit && offset) return prefix + " OFFSET " + offset + " ROWS FETCH NEXT " + limit + " ROWS ONLY";
      if (limit) return prefix + " OFFSET 0 ROWS FETCH NEXT " + limit + " ROWS ONLY";
      if (offset) return prefix + " OFFSET " + offset + " ROWS";
    } else if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql" || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") {
      if (limit && offset) return " LIMIT " + limit + " OFFSET " + offset;
      if (limit) return " LIMIT " + limit;
      if (offset) throw new OffsetWithoutLimitNotSupportedError();
    } else if (DriverUtils.isSQLiteFamily(this.connection.driver)) {
      if (limit && offset) return " LIMIT " + limit + " OFFSET " + offset;
      if (limit) return " LIMIT " + limit;
      if (offset) return " LIMIT -1 OFFSET " + offset;
    } else if (this.connection.driver.options.type === "oracle") {
      if (limit && offset) return " OFFSET " + offset + " ROWS FETCH NEXT " + limit + " ROWS ONLY";
      if (limit) return " FETCH NEXT " + limit + " ROWS ONLY";
      if (offset) return " OFFSET " + offset + " ROWS";
    } else {
      if (limit && offset) return " LIMIT " + limit + " OFFSET " + offset;
      if (limit) return " LIMIT " + limit;
      if (offset) return " OFFSET " + offset;
    }
    return "";
  }
  /**
   * Creates "LOCK" part of SELECT Query after table Clause
   * ex.
   *  SELECT 1
   *  FROM USER U WITH (NOLOCK)
   *  JOIN ORDER O WITH (NOLOCK)
   *      ON U.ID=O.OrderID
   */
  createTableLockExpression() {
    if (this.connection.driver.options.type === "mssql") {
      switch (this.expressionMap.lockMode) {
        case "pessimistic_read":
          return " WITH (HOLDLOCK, ROWLOCK)";
        case "pessimistic_write":
          return " WITH (UPDLOCK, ROWLOCK)";
        case "dirty_read":
          return " WITH (NOLOCK)";
      }
    }
    return "";
  }
  /**
   * Creates "LOCK" part of SQL query.
   */
  createLockExpression() {
    const driver = this.connection.driver;
    let lockTablesClause = "";
    if (this.expressionMap.lockTables) {
      if (!(DriverUtils.isPostgresFamily(driver) || driver.options.type === "cockroachdb")) {
        throw new TypeORMError("Lock tables not supported in selected driver");
      }
      if (this.expressionMap.lockTables.length < 1) {
        throw new TypeORMError("lockTables cannot be an empty array");
      }
      lockTablesClause = " OF " + this.expressionMap.lockTables.join(", ");
    }
    let onLockExpression = "";
    if (this.expressionMap.onLocked === "nowait") {
      onLockExpression = " NOWAIT";
    } else if (this.expressionMap.onLocked === "skip_locked") {
      onLockExpression = " SKIP LOCKED";
    }
    switch (this.expressionMap.lockMode) {
      case "pessimistic_read":
        if (driver.options.type === "mysql" || driver.options.type === "aurora-mysql") {
          if (DriverUtils.isReleaseVersionOrGreater(driver, "8.0.0")) {
            return " FOR SHARE" + lockTablesClause + onLockExpression;
          } else {
            return " LOCK IN SHARE MODE";
          }
        } else if (driver.options.type === "mariadb") {
          return " LOCK IN SHARE MODE";
        } else if (DriverUtils.isPostgresFamily(driver)) {
          return " FOR SHARE" + lockTablesClause + onLockExpression;
        } else if (driver.options.type === "oracle") {
          return " FOR UPDATE";
        } else if (driver.options.type === "mssql") {
          return "";
        } else {
          throw new LockNotSupportedOnGivenDriverError();
        }
      case "pessimistic_write":
        if (DriverUtils.isMySQLFamily(driver) || driver.options.type === "aurora-mysql" || driver.options.type === "oracle") {
          return " FOR UPDATE" + onLockExpression;
        } else if (DriverUtils.isPostgresFamily(driver) || driver.options.type === "cockroachdb") {
          return " FOR UPDATE" + lockTablesClause + onLockExpression;
        } else if (driver.options.type === "mssql") {
          return "";
        } else {
          throw new LockNotSupportedOnGivenDriverError();
        }
      case "pessimistic_partial_write":
        if (DriverUtils.isPostgresFamily(driver)) {
          return " FOR UPDATE" + lockTablesClause + " SKIP LOCKED";
        } else if (DriverUtils.isMySQLFamily(driver)) {
          return " FOR UPDATE SKIP LOCKED";
        } else {
          throw new LockNotSupportedOnGivenDriverError();
        }
      case "pessimistic_write_or_fail":
        if (DriverUtils.isPostgresFamily(driver) || driver.options.type === "cockroachdb") {
          return " FOR UPDATE" + lockTablesClause + " NOWAIT";
        } else if (DriverUtils.isMySQLFamily(driver)) {
          return " FOR UPDATE NOWAIT";
        } else {
          throw new LockNotSupportedOnGivenDriverError();
        }
      case "for_no_key_update":
        if (DriverUtils.isPostgresFamily(driver) || driver.options.type === "cockroachdb") {
          return " FOR NO KEY UPDATE" + lockTablesClause + onLockExpression;
        } else {
          throw new LockNotSupportedOnGivenDriverError();
        }
      case "for_key_share":
        if (DriverUtils.isPostgresFamily(driver)) {
          return " FOR KEY SHARE" + lockTablesClause + onLockExpression;
        } else {
          throw new LockNotSupportedOnGivenDriverError();
        }
      default:
        return "";
    }
  }
  /**
   * Creates "HAVING" part of SQL query.
   */
  createHavingExpression() {
    if (!this.expressionMap.havings || !this.expressionMap.havings.length) return "";
    const conditions = this.expressionMap.havings.map((having, index) => {
      switch (having.type) {
        case "and":
          return (index > 0 ? "AND " : "") + this.replacePropertyNames(having.condition);
        case "or":
          return (index > 0 ? "OR " : "") + this.replacePropertyNames(having.condition);
        default:
          return this.replacePropertyNames(having.condition);
      }
    }).join(" ");
    if (!conditions.length) return "";
    return " HAVING " + conditions;
  }
  buildEscapedEntityColumnSelects(aliasName, metadata) {
    const hasMainAlias = this.expressionMap.selects.some((select) => select.selection === aliasName);
    const columns = [];
    if (hasMainAlias) {
      columns.push(...metadata.columns.filter((column) => column.isSelect === true));
    }
    columns.push(...metadata.columns.filter((column) => {
      return this.expressionMap.selects.some((select) => select.selection === aliasName + "." + column.propertyPath);
    }));
    if (columns.length === 0)
      return [];
    const nonSelectedPrimaryColumns = this.expressionMap.queryEntity ? metadata.primaryColumns.filter((primaryColumn) => columns.indexOf(primaryColumn) === -1) : [];
    const allColumns = [...columns, ...nonSelectedPrimaryColumns];
    const finalSelects = [];
    const escapedAliasName = this.escape(aliasName);
    allColumns.forEach((column) => {
      let selectionPath = escapedAliasName + "." + this.escape(column.databaseName);
      if (column.isVirtualProperty && column.query) {
        selectionPath = `(${column.query(escapedAliasName)})`;
      }
      if (this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
        if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") {
          const useLegacy = this.connection.driver.options.legacySpatialSupport;
          const asText = useLegacy ? "AsText" : "ST_AsText";
          selectionPath = `${asText}(${selectionPath})`;
        }
        if (DriverUtils.isPostgresFamily(this.connection.driver)) if (column.precision) {
          selectionPath = `ST_AsGeoJSON(${selectionPath}, ${column.precision})::json`;
        } else {
          selectionPath = `ST_AsGeoJSON(${selectionPath})::json`;
        }
        if (this.connection.driver.options.type === "mssql") selectionPath = `${selectionPath}.ToString()`;
      }
      const selections = this.expressionMap.selects.filter((select) => select.selection === aliasName + "." + column.propertyPath);
      if (selections.length) {
        selections.forEach((selection) => {
          finalSelects.push({
            selection: selectionPath,
            aliasName: selection.aliasName ? selection.aliasName : DriverUtils.buildAlias(this.connection.driver, void 0, aliasName, column.databaseName),
            // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!
            virtual: selection.virtual
          });
        });
      } else {
        if (column.isVirtualProperty) {
          return;
        }
        finalSelects.push({
          selection: selectionPath,
          aliasName: DriverUtils.buildAlias(this.connection.driver, void 0, aliasName, column.databaseName),
          // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!
          virtual: hasMainAlias
        });
      }
    });
    return finalSelects;
  }
  findEntityColumnSelects(aliasName, metadata) {
    const mainSelect = this.expressionMap.selects.find((select) => select.selection === aliasName);
    if (mainSelect) return [mainSelect];
    return this.expressionMap.selects.filter((select) => {
      return metadata.columns.some((column) => select.selection === aliasName + "." + column.propertyPath);
    });
  }
  computeCountExpression() {
    const mainAlias = this.expressionMap.mainAlias.name;
    const metadata = this.expressionMap.mainAlias.metadata;
    const primaryColumns = metadata.primaryColumns;
    const distinctAlias = this.escape(mainAlias);
    if (this.expressionMap.joinAttributes.length === 0 && this.expressionMap.relationIdAttributes.length === 0 && this.expressionMap.relationCountAttributes.length === 0) {
      return "COUNT(1)";
    }
    if (this.connection.driver.options.type === "cockroachdb" || DriverUtils.isPostgresFamily(this.connection.driver)) {
      return "COUNT(DISTINCT(" + primaryColumns.map((c) => `${distinctAlias}.${this.escape(c.databaseName)}`).join(", ") + "))";
    }
    if (DriverUtils.isMySQLFamily(this.connection.driver)) {
      return "COUNT(DISTINCT " + primaryColumns.map((c) => `${distinctAlias}.${this.escape(c.databaseName)}`).join(", ") + ")";
    }
    if (this.connection.driver.options.type === "mssql") {
      const columnsExpression = primaryColumns.map((primaryColumn) => `${distinctAlias}.${this.escape(primaryColumn.databaseName)}`).join(", '|;|', ");
      if (primaryColumns.length === 1) {
        return `COUNT(DISTINCT(${columnsExpression}))`;
      }
      return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;
    }
    if (this.connection.driver.options.type === "spanner") {
      if (primaryColumns.length === 1) {
        return `COUNT(DISTINCT(${distinctAlias}.${this.escape(primaryColumns[0].databaseName)}))`;
      }
      const columnsExpression = primaryColumns.map((primaryColumn) => `CAST(${distinctAlias}.${this.escape(primaryColumn.databaseName)} AS STRING)`).join(", '|;|', ");
      return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;
    }
    return `COUNT(DISTINCT(` + primaryColumns.map((c) => `${distinctAlias}.${this.escape(c.databaseName)}`).join(" || '|;|' || ") + "))";
  }
  executeCountQuery(queryRunner) {
    return __async(this, null, function* () {
      const countSql = this.computeCountExpression();
      const results = yield this.clone().orderBy().groupBy().offset(void 0).limit(void 0).skip(void 0).take(void 0).select(countSql, "cnt").setOption("disable-global-order").loadRawResults(queryRunner);
      if (!results || !results[0] || !results[0]["cnt"]) return 0;
      return parseInt(results[0]["cnt"]);
    });
  }
  executeExistsQuery(queryRunner) {
    return __async(this, null, function* () {
      const results = yield this.connection.createQueryBuilder().fromDummy().select("1", "row_exists").whereExists(this).limit(1).loadRawResults(queryRunner);
      return results.length > 0;
    });
  }
  applyFindOptions() {
    if (this.expressionMap.mainAlias.metadata) {
      if (this.findOptions.relationLoadStrategy) {
        this.expressionMap.relationLoadStrategy = this.findOptions.relationLoadStrategy;
      }
      if (this.findOptions.comment) {
        this.comment(this.findOptions.comment);
      }
      if (this.findOptions.withDeleted) {
        this.withDeleted();
      }
      if (this.findOptions.select) {
        const select = Array.isArray(this.findOptions.select) ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.select) : this.findOptions.select;
        this.buildSelect(select, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);
      }
      if (this.selects.length) {
        this.select(this.selects);
      }
      this.selects = [];
      if (this.findOptions.relations) {
        const relations = Array.isArray(this.findOptions.relations) ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.relations) : this.findOptions.relations;
        this.buildRelations(relations, typeof this.findOptions.select === "object" ? this.findOptions.select : void 0, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);
        if (this.findOptions.loadEagerRelations !== false && this.expressionMap.relationLoadStrategy === "join") {
          this.buildEagerRelations(relations, typeof this.findOptions.select === "object" ? this.findOptions.select : void 0, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);
        }
      }
      if (this.selects.length) {
        this.addSelect(this.selects);
      }
      if (this.findOptions.where) {
        this.conditions = this.buildWhere(this.findOptions.where, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);
        if (this.conditions.length) this.andWhere(this.conditions.substr(0, 1) !== "(" ? "(" + this.conditions + ")" : this.conditions);
      }
      if (this.findOptions.order) {
        this.buildOrder(this.findOptions.order, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);
      }
      if (this.joins.length) {
        this.joins.forEach((join) => {
          if (join.select && !join.selection) {
            if (join.type === "inner") {
              this.innerJoinAndSelect(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);
            } else {
              this.leftJoinAndSelect(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);
            }
          } else {
            if (join.type === "inner") {
              this.innerJoin(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);
            } else {
              this.leftJoin(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);
            }
          }
        });
      }
      if (this.findOptions.skip !== void 0) {
        this.skip(this.findOptions.skip);
      }
      if (this.findOptions.take !== void 0) {
        this.take(this.findOptions.take);
      }
      if (typeof this.findOptions.cache === "number") {
        this.cache(this.findOptions.cache);
      } else if (typeof this.findOptions.cache === "boolean") {
        this.cache(this.findOptions.cache);
      } else if (typeof this.findOptions.cache === "object") {
        this.cache(this.findOptions.cache.id, this.findOptions.cache.milliseconds);
      }
      if (this.findOptions.join) {
        if (this.findOptions.join.leftJoin) Object.keys(this.findOptions.join.leftJoin).forEach((key) => {
          this.leftJoin(this.findOptions.join.leftJoin[key], key);
        });
        if (this.findOptions.join.innerJoin) Object.keys(this.findOptions.join.innerJoin).forEach((key) => {
          this.innerJoin(this.findOptions.join.innerJoin[key], key);
        });
        if (this.findOptions.join.leftJoinAndSelect) Object.keys(this.findOptions.join.leftJoinAndSelect).forEach((key) => {
          this.leftJoinAndSelect(this.findOptions.join.leftJoinAndSelect[key], key);
        });
        if (this.findOptions.join.innerJoinAndSelect) Object.keys(this.findOptions.join.innerJoinAndSelect).forEach((key) => {
          this.innerJoinAndSelect(this.findOptions.join.innerJoinAndSelect[key], key);
        });
      }
      if (this.findOptions.lock) {
        if (this.findOptions.lock.mode === "optimistic") {
          this.setLock(this.findOptions.lock.mode, this.findOptions.lock.version);
        } else if (this.findOptions.lock.mode === "pessimistic_read" || this.findOptions.lock.mode === "pessimistic_write" || this.findOptions.lock.mode === "dirty_read" || this.findOptions.lock.mode === "pessimistic_partial_write" || this.findOptions.lock.mode === "pessimistic_write_or_fail" || this.findOptions.lock.mode === "for_no_key_update" || this.findOptions.lock.mode === "for_key_share") {
          const tableNames = this.findOptions.lock.tables ? this.findOptions.lock.tables.map((table) => {
            const tableAlias = this.expressionMap.aliases.find((alias) => {
              return alias.metadata.tableNameWithoutPrefix === table;
            });
            if (!tableAlias) {
              throw new TypeORMError(`"${table}" is not part of this query`);
            }
            return this.escape(tableAlias.name);
          }) : void 0;
          this.setLock(this.findOptions.lock.mode, void 0, tableNames);
          if (this.findOptions.lock.onLocked) {
            this.setOnLocked(this.findOptions.lock.onLocked);
          }
        }
      }
      if (this.findOptions.loadRelationIds === true) {
        this.loadAllRelationIds();
      } else if (typeof this.findOptions.loadRelationIds === "object") {
        this.loadAllRelationIds(this.findOptions.loadRelationIds);
      }
      if (this.findOptions.loadEagerRelations !== false) {
        FindOptionsUtils.joinEagerRelations(this, this.expressionMap.mainAlias.name, this.expressionMap.mainAlias.metadata);
      }
      if (this.findOptions.transaction === true) {
        this.expressionMap.useTransaction = true;
      }
    }
  }
  concatRelationMetadata(relationMetadata) {
    this.relationMetadatas.push(relationMetadata);
  }
  /**
   * Executes sql generated by query builder and returns object with raw results and entities created from them.
   */
  executeEntitiesAndRawResults(queryRunner) {
    return __async(this, null, function* () {
      if (!this.expressionMap.mainAlias) throw new TypeORMError(`Alias is not set. Use "from" method to set an alias.`);
      if ((this.expressionMap.lockMode === "pessimistic_read" || this.expressionMap.lockMode === "pessimistic_write" || this.expressionMap.lockMode === "pessimistic_partial_write" || this.expressionMap.lockMode === "pessimistic_write_or_fail" || this.expressionMap.lockMode === "for_no_key_update" || this.expressionMap.lockMode === "for_key_share") && !queryRunner.isTransactionActive) throw new PessimisticLockTransactionRequiredError();
      if (this.expressionMap.lockMode === "optimistic") {
        const metadata = this.expressionMap.mainAlias.metadata;
        if (!metadata.versionColumn && !metadata.updateDateColumn) throw new NoVersionOrUpdateDateColumnError(metadata.name);
      }
      const relationIdLoader = new RelationIdLoader(this.connection, queryRunner, this.expressionMap.relationIdAttributes);
      const relationCountLoader = new RelationCountLoader(this.connection, queryRunner, this.expressionMap.relationCountAttributes);
      const relationIdMetadataTransformer = new RelationIdMetadataToAttributeTransformer(this.expressionMap);
      relationIdMetadataTransformer.transform();
      const relationCountMetadataTransformer = new RelationCountMetadataToAttributeTransformer(this.expressionMap);
      relationCountMetadataTransformer.transform();
      let rawResults = [], entities = [];
      if ((this.expressionMap.skip || this.expressionMap.take) && this.expressionMap.joinAttributes.length > 0) {
        const [selects, orderBys] = this.createOrderByCombinedWithSelectExpression("distinctAlias");
        const metadata = this.expressionMap.mainAlias.metadata;
        const mainAliasName = this.expressionMap.mainAlias.name;
        const querySelects = metadata.primaryColumns.map((primaryColumn) => {
          const distinctAlias = this.escape("distinctAlias");
          const columnAlias = this.escape(DriverUtils.buildAlias(this.connection.driver, void 0, mainAliasName, primaryColumn.databaseName));
          if (!orderBys[columnAlias])
            orderBys[columnAlias] = "ASC";
          const alias = DriverUtils.buildAlias(this.connection.driver, void 0, "ids_" + mainAliasName, primaryColumn.databaseName);
          return `${distinctAlias}.${columnAlias} AS ${this.escape(alias)}`;
        });
        const originalQuery = this.clone();
        const originalQueryTimeTravel = originalQuery.expressionMap.timeTravel;
        rawResults = yield new _SelectQueryBuilder(this.connection, queryRunner).select(`DISTINCT ${querySelects.join(", ")}`).addSelect(selects).from(`(${originalQuery.orderBy().timeTravelQuery(false).getQuery()})`, "distinctAlias").timeTravelQuery(originalQueryTimeTravel).offset(this.expressionMap.skip).limit(this.expressionMap.take).orderBy(orderBys).cache(this.expressionMap.cache && this.expressionMap.cacheId ? `${this.expressionMap.cacheId}-pagination` : this.expressionMap.cache, this.expressionMap.cacheDuration).setParameters(this.getParameters()).setNativeParameters(this.expressionMap.nativeParameters).getRawMany();
        if (rawResults.length > 0) {
          let condition = "";
          const parameters = {};
          if (metadata.hasMultiplePrimaryKeys) {
            condition = rawResults.map((result, index) => {
              return metadata.primaryColumns.map((primaryColumn) => {
                const paramKey = `orm_distinct_ids_${index}_${primaryColumn.databaseName}`;
                const paramKeyResult = DriverUtils.buildAlias(this.connection.driver, void 0, "ids_" + mainAliasName, primaryColumn.databaseName);
                parameters[paramKey] = result[paramKeyResult];
                return `${mainAliasName}.${primaryColumn.propertyPath}=:${paramKey}`;
              }).join(" AND ");
            }).join(" OR ");
          } else {
            const alias = DriverUtils.buildAlias(this.connection.driver, void 0, "ids_" + mainAliasName, metadata.primaryColumns[0].databaseName);
            const ids = rawResults.map((result) => result[alias]);
            const areAllNumbers = ids.every((id) => typeof id === "number");
            if (areAllNumbers) {
              condition = `${mainAliasName}.${metadata.primaryColumns[0].propertyPath} IN (${ids.join(", ")})`;
            } else {
              parameters["orm_distinct_ids"] = ids;
              condition = mainAliasName + "." + metadata.primaryColumns[0].propertyPath + " IN (:...orm_distinct_ids)";
            }
          }
          rawResults = yield this.clone().mergeExpressionMap({
            extraAppendedAndWhereCondition: condition
          }).setParameters(parameters).loadRawResults(queryRunner);
        }
      } else {
        rawResults = yield this.loadRawResults(queryRunner);
      }
      if (rawResults.length > 0) {
        const rawRelationIdResults = yield relationIdLoader.load(rawResults);
        const rawRelationCountResults = yield relationCountLoader.load(rawResults);
        const transformer = new RawSqlResultsToEntityTransformer(this.expressionMap, this.connection.driver, rawRelationIdResults, rawRelationCountResults, this.queryRunner);
        entities = transformer.transform(rawResults, this.expressionMap.mainAlias);
        if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
          yield queryRunner.broadcaster.broadcast("Load", this.expressionMap.mainAlias.metadata, entities);
        }
      }
      if (this.expressionMap.relationLoadStrategy === "query") {
        const queryStrategyRelationIdLoader = new RelationIdLoader2(this.connection, queryRunner);
        yield Promise.all(this.relationMetadatas.map((relation) => __async(this, null, function* () {
          const relationTarget = relation.inverseEntityMetadata.target;
          const relationAlias = relation.inverseEntityMetadata.targetName;
          const select = Array.isArray(this.findOptions.select) ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.select) : this.findOptions.select;
          const relations = Array.isArray(this.findOptions.relations) ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.relations) : this.findOptions.relations;
          const queryBuilder = this.createQueryBuilder(queryRunner).select(relationAlias).from(relationTarget, relationAlias).setFindOptions({
            select: select ? OrmUtils.deepValue(select, relation.propertyPath) : void 0,
            order: this.findOptions.order ? OrmUtils.deepValue(this.findOptions.order, relation.propertyPath) : void 0,
            relations: relations ? OrmUtils.deepValue(relations, relation.propertyPath) : void 0,
            withDeleted: this.findOptions.withDeleted,
            relationLoadStrategy: this.findOptions.relationLoadStrategy
          });
          if (entities.length > 0) {
            const relatedEntityGroups = yield queryStrategyRelationIdLoader.loadManyToManyRelationIdsAndGroup(relation, entities, void 0, queryBuilder);
            entities.forEach((entity) => {
              const relatedEntityGroup = relatedEntityGroups.find((group) => group.entity === entity);
              if (relatedEntityGroup) {
                const value = relatedEntityGroup.related === void 0 ? null : relatedEntityGroup.related;
                relation.setEntityValue(entity, value);
              }
            });
          }
        })));
      }
      return {
        raw: rawResults,
        entities
      };
    });
  }
  createOrderByCombinedWithSelectExpression(parentAlias) {
    const orderBys = this.expressionMap.allOrderBys;
    const selectString = Object.keys(orderBys).map((orderCriteria) => {
      if (orderCriteria.indexOf(".") !== -1) {
        const criteriaParts = orderCriteria.split(".");
        const aliasName = criteriaParts[0];
        const propertyPath = criteriaParts.slice(1).join(".");
        const alias = this.expressionMap.findAliasByName(aliasName);
        const column = alias.metadata.findColumnWithPropertyPath(propertyPath);
        return this.escape(parentAlias) + "." + this.escape(DriverUtils.buildAlias(this.connection.driver, void 0, aliasName, column.databaseName));
      } else {
        if (this.expressionMap.selects.find((select) => select.selection === orderCriteria || select.aliasName === orderCriteria)) return this.escape(parentAlias) + "." + this.escape(orderCriteria);
        return "";
      }
    }).join(", ");
    const orderByObject = {};
    Object.keys(orderBys).forEach((orderCriteria) => {
      if (orderCriteria.indexOf(".") !== -1) {
        const criteriaParts = orderCriteria.split(".");
        const aliasName = criteriaParts[0];
        const propertyPath = criteriaParts.slice(1).join(".");
        const alias = this.expressionMap.findAliasByName(aliasName);
        const column = alias.metadata.findColumnWithPropertyPath(propertyPath);
        orderByObject[this.escape(parentAlias) + "." + this.escape(DriverUtils.buildAlias(this.connection.driver, void 0, aliasName, column.databaseName))] = orderBys[orderCriteria];
      } else {
        if (this.expressionMap.selects.find((select) => select.selection === orderCriteria || select.aliasName === orderCriteria)) {
          orderByObject[this.escape(parentAlias) + "." + this.escape(orderCriteria)] = orderBys[orderCriteria];
        } else {
          orderByObject[orderCriteria] = orderBys[orderCriteria];
        }
      }
    });
    return [selectString, orderByObject];
  }
  /**
   * Loads raw results from the database.
   */
  loadRawResults(queryRunner) {
    return __async(this, null, function* () {
      const [sql, parameters] = this.getQueryAndParameters();
      const queryId = sql + " -- PARAMETERS: " + JSON.stringify(parameters, (_, value) => typeof value === "bigint" ? value.toString() : value);
      const cacheOptions = typeof this.connection.options.cache === "object" ? this.connection.options.cache : {};
      let savedQueryResultCacheOptions = void 0;
      const isCachingEnabled = (
        // Caching is enabled globally and isn't disabled locally.
        cacheOptions.alwaysEnabled && this.expressionMap.cache !== false || // ...or it's enabled locally explicitly.
        this.expressionMap.cache === true
      );
      let cacheError = false;
      if (this.connection.queryResultCache && isCachingEnabled) {
        try {
          savedQueryResultCacheOptions = yield this.connection.queryResultCache.getFromCache({
            identifier: this.expressionMap.cacheId,
            query: queryId,
            duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1e3
          }, queryRunner);
          if (savedQueryResultCacheOptions && !this.connection.queryResultCache.isExpired(savedQueryResultCacheOptions)) {
            return JSON.parse(savedQueryResultCacheOptions.result);
          }
        } catch (error) {
          if (!cacheOptions.ignoreErrors) {
            throw error;
          }
          cacheError = true;
        }
      }
      const results = yield queryRunner.query(sql, parameters, true);
      if (!cacheError && this.connection.queryResultCache && isCachingEnabled) {
        try {
          yield this.connection.queryResultCache.storeInCache({
            identifier: this.expressionMap.cacheId,
            query: queryId,
            time: (/* @__PURE__ */ new Date()).getTime(),
            duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1e3,
            result: JSON.stringify(results.records)
          }, savedQueryResultCacheOptions, queryRunner);
        } catch (error) {
          if (!cacheOptions.ignoreErrors) {
            throw error;
          }
        }
      }
      return results.records;
    });
  }
  /**
   * Merges into expression map given expression map properties.
   */
  mergeExpressionMap(expressionMap) {
    ObjectUtils.assign(this.expressionMap, expressionMap);
    return this;
  }
  /**
   * Normalizes a give number - converts to int if possible.
   */
  normalizeNumber(num) {
    if (typeof num === "number" || num === void 0 || num === null) return num;
    return Number(num);
  }
  /**
   * Creates a query builder used to execute sql queries inside this query builder.
   */
  obtainQueryRunner() {
    return this.queryRunner || this.connection.createQueryRunner(this.connection.defaultReplicationModeForReads());
  }
  buildSelect(select, metadata, alias, embedPrefix) {
    for (let key in select) {
      if (select[key] === void 0 || select[key] === false) continue;
      const propertyPath = embedPrefix ? embedPrefix + "." + key : key;
      const column = metadata.findColumnWithPropertyPathStrict(propertyPath);
      const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);
      const relation = metadata.findRelationWithPropertyPath(propertyPath);
      if (!embed && !column && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);
      if (column) {
        this.selects.push(alias + "." + propertyPath);
      } else if (embed) {
        this.buildSelect(select[key], metadata, alias, propertyPath);
      }
    }
  }
  buildRelations(relations, selection, metadata, alias, embedPrefix) {
    if (!relations) return;
    Object.keys(relations).forEach((relationName) => {
      const relationValue = relations[relationName];
      const propertyPath = embedPrefix ? embedPrefix + "." + relationName : relationName;
      const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);
      const relation = metadata.findRelationWithPropertyPath(propertyPath);
      if (!embed && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);
      if (embed) {
        this.buildRelations(relationValue, typeof selection === "object" ? OrmUtils.deepValue(selection, embed.propertyPath) : void 0, metadata, alias, propertyPath);
      } else if (relation) {
        let joinAlias = alias + "_" + propertyPath.replace(".", "_");
        joinAlias = DriverUtils.buildAlias(this.connection.driver, {
          joiner: "__"
        }, alias, joinAlias);
        if (relationValue === true || typeof relationValue === "object") {
          if (this.expressionMap.relationLoadStrategy === "query") {
            this.concatRelationMetadata(relation);
          } else {
            this.joins.push({
              type: "left",
              select: true,
              selection: selection && typeof selection[relationName] === "object" ? selection[relationName] : void 0,
              alias: joinAlias,
              parentAlias: alias,
              relationMetadata: relation
            });
            if (selection && typeof selection[relationName] === "object") {
              this.buildSelect(selection[relationName], relation.inverseEntityMetadata, joinAlias);
            }
          }
        }
        if (typeof relationValue === "object" && this.expressionMap.relationLoadStrategy === "join") {
          this.buildRelations(relationValue, typeof selection === "object" ? OrmUtils.deepValue(selection, relation.propertyPath) : void 0, relation.inverseEntityMetadata, joinAlias, void 0);
        }
      }
    });
  }
  buildEagerRelations(relations, selection, metadata, alias, embedPrefix) {
    if (!relations) return;
    Object.keys(relations).forEach((relationName) => {
      const relationValue = relations[relationName];
      const propertyPath = embedPrefix ? embedPrefix + "." + relationName : relationName;
      const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);
      const relation = metadata.findRelationWithPropertyPath(propertyPath);
      if (!embed && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);
      if (embed) {
        this.buildEagerRelations(relationValue, typeof selection === "object" ? OrmUtils.deepValue(selection, embed.propertyPath) : void 0, metadata, alias, propertyPath);
      } else if (relation) {
        let joinAlias = alias + "_" + propertyPath.replace(".", "_");
        joinAlias = DriverUtils.buildAlias(this.connection.driver, {
          joiner: "__"
        }, alias, joinAlias);
        if (relationValue === true || typeof relationValue === "object") {
          relation.inverseEntityMetadata.eagerRelations.forEach((eagerRelation) => {
            let eagerRelationJoinAlias = joinAlias + "_" + eagerRelation.propertyPath.replace(".", "_");
            eagerRelationJoinAlias = DriverUtils.buildAlias(this.connection.driver, {
              joiner: "__"
            }, joinAlias, eagerRelationJoinAlias);
            const existJoin = this.joins.find((join) => join.alias === eagerRelationJoinAlias);
            if (!existJoin) {
              this.joins.push({
                type: "left",
                select: true,
                alias: eagerRelationJoinAlias,
                parentAlias: joinAlias,
                selection: void 0,
                relationMetadata: eagerRelation
              });
            }
            if (selection && typeof selection[relationName] === "object") {
              this.buildSelect(selection[relationName], relation.inverseEntityMetadata, joinAlias);
            }
          });
        }
        if (typeof relationValue === "object") {
          this.buildEagerRelations(relationValue, typeof selection === "object" ? OrmUtils.deepValue(selection, relation.propertyPath) : void 0, relation.inverseEntityMetadata, joinAlias, void 0);
        }
      }
    });
  }
  buildOrder(order, metadata, alias, embedPrefix) {
    for (let key in order) {
      if (order[key] === void 0) continue;
      const propertyPath = embedPrefix ? embedPrefix + "." + key : key;
      const column = metadata.findColumnWithPropertyPathStrict(propertyPath);
      const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);
      const relation = metadata.findRelationWithPropertyPath(propertyPath);
      if (!embed && !column && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);
      if (column) {
        let direction = typeof order[key] === "object" ? order[key].direction : order[key];
        direction = direction === "DESC" || direction === "desc" || direction === -1 ? "DESC" : "ASC";
        let nulls = typeof order[key] === "object" ? order[key].nulls : void 0;
        nulls = nulls?.toLowerCase() === "first" ? "NULLS FIRST" : nulls?.toLowerCase() === "last" ? "NULLS LAST" : void 0;
        let aliasPath = `${alias}.${propertyPath}`;
        this.addOrderBy(aliasPath, direction, nulls);
      } else if (embed) {
        this.buildOrder(order[key], metadata, alias, propertyPath);
      } else if (relation) {
        let joinAlias = alias + "_" + propertyPath.replace(".", "_");
        joinAlias = DriverUtils.buildAlias(this.connection.driver, {
          joiner: "__"
        }, alias, joinAlias);
        const existJoin = this.joins.find((join) => join.alias === joinAlias);
        if (!existJoin) {
          this.joins.push({
            type: "left",
            select: false,
            alias: joinAlias,
            parentAlias: alias,
            selection: void 0,
            relationMetadata: relation
          });
        }
        this.buildOrder(order[key], relation.inverseEntityMetadata, joinAlias);
      }
    }
  }
  buildWhere(where, metadata, alias, embedPrefix) {
    let condition = "";
    if (Array.isArray(where)) {
      if (where.length) {
        condition = where.map((whereItem) => {
          return this.buildWhere(whereItem, metadata, alias, embedPrefix);
        }).filter((condition2) => !!condition2).map((condition2) => "(" + condition2 + ")").join(" OR ");
      }
    } else {
      let andConditions = [];
      for (let key in where) {
        if (where[key] === void 0 || where[key] === null) continue;
        const propertyPath = embedPrefix ? embedPrefix + "." + key : key;
        const column = metadata.findColumnWithPropertyPathStrict(propertyPath);
        const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);
        const relation = metadata.findRelationWithPropertyPath(propertyPath);
        if (!embed && !column && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);
        if (column) {
          let aliasPath = `${alias}.${propertyPath}`;
          if (column.isVirtualProperty && column.query) {
            aliasPath = `(${column.query(alias)})`;
          }
          let parameterValue = where[key];
          if (InstanceChecker.isEqualOperator(where[key])) {
            parameterValue = where[key].value;
          }
          if (column.transformer) {
            parameterValue instanceof FindOperator ? parameterValue.transformValue(column.transformer) : parameterValue = ApplyValueTransformers.transformTo(column.transformer, parameterValue);
          }
          andConditions.push(this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, parameterValue)));
        } else if (embed) {
          const condition2 = this.buildWhere(where[key], metadata, alias, propertyPath);
          if (condition2) andConditions.push(condition2);
        } else if (relation) {
          if (typeof where[key] === "object") {
            const allAllUndefined = Object.keys(where[key]).every((k) => where[key][k] === void 0);
            if (allAllUndefined) {
              continue;
            }
          }
          if (InstanceChecker.isFindOperator(where[key])) {
            if (where[key].type === "moreThan" || where[key].type === "lessThan" || where[key].type === "moreThanOrEqual" || where[key].type === "lessThanOrEqual") {
              let sqlOperator = "";
              if (where[key].type === "moreThan") {
                sqlOperator = ">";
              } else if (where[key].type === "lessThan") {
                sqlOperator = "<";
              } else if (where[key].type === "moreThanOrEqual") {
                sqlOperator = ">=";
              } else if (where[key].type === "lessThanOrEqual") {
                sqlOperator = "<=";
              }
              const qb = this.subQuery();
              if (relation.isManyToManyOwner) {
                qb.select("COUNT(*)").from(relation.joinTableName, relation.joinTableName).where(relation.joinColumns.map((column2) => {
                  return `${relation.joinTableName}.${column2.propertyName} = ${alias}.${column2.referencedColumn.propertyName}`;
                }).join(" AND "));
              } else if (relation.isManyToManyNotOwner) {
                qb.select("COUNT(*)").from(relation.inverseRelation.joinTableName, relation.inverseRelation.joinTableName).where(relation.inverseRelation.inverseJoinColumns.map((column2) => {
                  return `${relation.inverseRelation.joinTableName}.${column2.propertyName} = ${alias}.${column2.referencedColumn.propertyName}`;
                }).join(" AND "));
              } else if (relation.isOneToMany) {
                qb.select("COUNT(*)").from(relation.inverseEntityMetadata.target, relation.inverseEntityMetadata.tableName).where(relation.inverseRelation.joinColumns.map((column2) => {
                  return `${relation.inverseEntityMetadata.tableName}.${column2.propertyName} = ${alias}.${column2.referencedColumn.propertyName}`;
                }).join(" AND "));
              } else {
                throw new Error(`This relation isn't supported by given find operator`);
              }
              this.andWhere(qb.getSql() + " " + sqlOperator + " " + parseInt(where[key].value));
            } else {
              if (relation.isManyToOne || relation.isOneToOne && relation.isOneToOneOwner) {
                const aliasPath = `${alias}.${propertyPath}`;
                andConditions.push(this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, where[key])));
              } else {
                throw new Error(`This relation isn't supported by given find operator`);
              }
            }
          } else {
            let joinAlias = alias + "_" + relation.propertyPath.replace(".", "_");
            joinAlias = DriverUtils.buildAlias(this.connection.driver, {
              joiner: "__"
            }, alias, joinAlias);
            const existJoin = this.joins.find((join) => join.alias === joinAlias);
            if (!existJoin) {
              this.joins.push({
                type: "left",
                select: false,
                selection: void 0,
                alias: joinAlias,
                parentAlias: alias,
                relationMetadata: relation
              });
            }
            const condition2 = this.buildWhere(where[key], relation.inverseEntityMetadata, joinAlias);
            if (condition2) {
              andConditions.push(condition2);
            }
          }
        }
      }
      condition = andConditions.length ? "(" + andConditions.join(") AND (") + ")" : andConditions.join(" AND ");
    }
    return condition.length ? "(" + condition + ")" : condition;
  }
};

// ../node_modules/typeorm/browser/query-builder/result/UpdateResult.js
var UpdateResult = class {
  constructor() {
    this.generatedMaps = [];
  }
  static from(queryResult) {
    const result = new this();
    result.raw = queryResult.records;
    result.affected = queryResult.affected;
    return result;
  }
};

// ../node_modules/typeorm/browser/query-builder/SoftDeleteQueryBuilder.js
var SoftDeleteQueryBuilder = class extends QueryBuilder {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connectionOrQueryBuilder, queryRunner) {
    super(connectionOrQueryBuilder, queryRunner);
    this["@instanceof"] = Symbol.for("SoftDeleteQueryBuilder");
    this.expressionMap.aliasNamePrefixingEnabled = false;
  }
  // -------------------------------------------------------------------------
  // Public Implemented Methods
  // -------------------------------------------------------------------------
  /**
   * Gets generated SQL query without parameters being replaced.
   */
  getQuery() {
    let sql = this.createUpdateExpression();
    sql += this.createCteExpression();
    sql += this.createOrderByExpression();
    sql += this.createLimitExpression();
    return this.replacePropertyNamesForTheWholeQuery(sql.trim());
  }
  /**
   * Executes sql generated by query builder and returns raw database results.
   */
  execute() {
    return __async(this, null, function* () {
      const queryRunner = this.obtainQueryRunner();
      let transactionStartedByUs = false;
      try {
        if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
          yield queryRunner.startTransaction();
          transactionStartedByUs = true;
        }
        if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
          if (this.expressionMap.queryType === "soft-delete") yield queryRunner.broadcaster.broadcast("BeforeSoftRemove", this.expressionMap.mainAlias.metadata);
          else if (this.expressionMap.queryType === "restore") yield queryRunner.broadcaster.broadcast("BeforeRecover", this.expressionMap.mainAlias.metadata);
        }
        const returningResultsEntityUpdator = new ReturningResultsEntityUpdator(queryRunner, this.expressionMap);
        if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {
          this.expressionMap.extraReturningColumns = returningResultsEntityUpdator.getSoftDeletionReturningColumns();
        }
        const [sql, parameters] = this.getQueryAndParameters();
        const queryResult = yield queryRunner.query(sql, parameters, true);
        const updateResult = UpdateResult.from(queryResult);
        if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {
          yield returningResultsEntityUpdator.update(updateResult, this.expressionMap.whereEntities);
        }
        if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
          if (this.expressionMap.queryType === "soft-delete") yield queryRunner.broadcaster.broadcast("AfterSoftRemove", this.expressionMap.mainAlias.metadata);
          else if (this.expressionMap.queryType === "restore") yield queryRunner.broadcaster.broadcast("AfterRecover", this.expressionMap.mainAlias.metadata);
        }
        if (transactionStartedByUs) yield queryRunner.commitTransaction();
        return updateResult;
      } catch (error) {
        if (transactionStartedByUs) {
          try {
            yield queryRunner.rollbackTransaction();
          } catch (rollbackError) {
          }
        }
        throw error;
      } finally {
        if (queryRunner !== this.queryRunner) {
          yield queryRunner.release();
        }
      }
    });
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Specifies FROM which entity's table select/update/delete/soft-delete will be executed.
   * Also sets a main string alias of the selection data.
   */
  from(entityTarget, aliasName) {
    entityTarget = InstanceChecker.isEntitySchema(entityTarget) ? entityTarget.options.name : entityTarget;
    const mainAlias = this.createFromAlias(entityTarget, aliasName);
    this.expressionMap.setMainAlias(mainAlias);
    return this;
  }
  /**
   * Sets WHERE condition in the query builder.
   * If you had previously WHERE expression defined,
   * calling this function will override previously set WHERE conditions.
   * Additionally you can add parameters used in where expression.
   */
  where(where, parameters) {
    this.expressionMap.wheres = [];
    const condition = this.getWhereCondition(where);
    if (condition) this.expressionMap.wheres = [{
      type: "simple",
      condition
    }];
    if (parameters) this.setParameters(parameters);
    return this;
  }
  /**
   * Adds new AND WHERE condition in the query builder.
   * Additionally you can add parameters used in where expression.
   */
  andWhere(where, parameters) {
    this.expressionMap.wheres.push({
      type: "and",
      condition: this.getWhereCondition(where)
    });
    if (parameters) this.setParameters(parameters);
    return this;
  }
  /**
   * Adds new OR WHERE condition in the query builder.
   * Additionally you can add parameters used in where expression.
   */
  orWhere(where, parameters) {
    this.expressionMap.wheres.push({
      type: "or",
      condition: this.getWhereCondition(where)
    });
    if (parameters) this.setParameters(parameters);
    return this;
  }
  /**
   * Adds new AND WHERE with conditions for the given ids.
   */
  whereInIds(ids) {
    return this.where(this.getWhereInIdsCondition(ids));
  }
  /**
   * Adds new AND WHERE with conditions for the given ids.
   */
  andWhereInIds(ids) {
    return this.andWhere(this.getWhereInIdsCondition(ids));
  }
  /**
   * Adds new OR WHERE with conditions for the given ids.
   */
  orWhereInIds(ids) {
    return this.orWhere(this.getWhereInIdsCondition(ids));
  }
  /**
   * Optional returning/output clause.
   */
  output(output) {
    return this.returning(output);
  }
  /**
   * Optional returning/output clause.
   */
  returning(returning) {
    if (!this.connection.driver.isReturningSqlSupported("update")) {
      throw new ReturningStatementNotSupportedError();
    }
    this.expressionMap.returning = returning;
    return this;
  }
  /**
   * Sets ORDER BY condition in the query builder.
   * If you had previously ORDER BY expression defined,
   * calling this function will override previously set ORDER BY conditions.
   */
  orderBy(sort, order = "ASC", nulls) {
    if (sort) {
      if (typeof sort === "object") {
        this.expressionMap.orderBys = sort;
      } else {
        if (nulls) {
          this.expressionMap.orderBys = {
            [sort]: {
              order,
              nulls
            }
          };
        } else {
          this.expressionMap.orderBys = {
            [sort]: order
          };
        }
      }
    } else {
      this.expressionMap.orderBys = {};
    }
    return this;
  }
  /**
   * Adds ORDER BY condition in the query builder.
   */
  addOrderBy(sort, order = "ASC", nulls) {
    if (nulls) {
      this.expressionMap.orderBys[sort] = {
        order,
        nulls
      };
    } else {
      this.expressionMap.orderBys[sort] = order;
    }
    return this;
  }
  /**
   * Sets LIMIT - maximum number of rows to be selected.
   */
  limit(limit) {
    this.expressionMap.limit = limit;
    return this;
  }
  /**
   * Indicates if entity must be updated after update operation.
   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).
   * Enabled by default.
   */
  whereEntity(entity) {
    if (!this.expressionMap.mainAlias.hasMetadata) throw new TypeORMError(`.whereEntity method can only be used on queries which update real entity table.`);
    this.expressionMap.wheres = [];
    const entities = Array.isArray(entity) ? entity : [entity];
    entities.forEach((entity2) => {
      const entityIdMap = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity2);
      if (!entityIdMap) throw new TypeORMError(`Provided entity does not have ids set, cannot perform operation.`);
      this.orWhereInIds(entityIdMap);
    });
    this.expressionMap.whereEntities = entities;
    return this;
  }
  /**
   * Indicates if entity must be updated after update operation.
   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).
   * Enabled by default.
   */
  updateEntity(enabled) {
    this.expressionMap.updateEntity = enabled;
    return this;
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Creates UPDATE express used to perform insert query.
   */
  createUpdateExpression() {
    const metadata = this.expressionMap.mainAlias.hasMetadata ? this.expressionMap.mainAlias.metadata : void 0;
    if (!metadata) throw new TypeORMError(`Cannot get entity metadata for the given alias "${this.expressionMap.mainAlias}"`);
    if (!metadata.deleteDateColumn) {
      throw new MissingDeleteDateColumnError(metadata);
    }
    const updateColumnAndValues = [];
    switch (this.expressionMap.queryType) {
      case "soft-delete":
        updateColumnAndValues.push(this.escape(metadata.deleteDateColumn.databaseName) + " = CURRENT_TIMESTAMP");
        break;
      case "restore":
        updateColumnAndValues.push(this.escape(metadata.deleteDateColumn.databaseName) + " = NULL");
        break;
      default:
        throw new TypeORMError(`The queryType must be "soft-delete" or "restore"`);
    }
    if (metadata.versionColumn) updateColumnAndValues.push(this.escape(metadata.versionColumn.databaseName) + " = " + this.escape(metadata.versionColumn.databaseName) + " + 1");
    if (metadata.updateDateColumn) updateColumnAndValues.push(this.escape(metadata.updateDateColumn.databaseName) + " = CURRENT_TIMESTAMP");
    if (updateColumnAndValues.length <= 0) {
      throw new UpdateValuesMissingError();
    }
    const whereExpression = this.createWhereExpression();
    const returningExpression = this.createReturningExpression("update");
    if (returningExpression === "") {
      return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")}${whereExpression}`;
    }
    if (this.connection.driver.options.type === "mssql") {
      return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")} OUTPUT ${returningExpression}${whereExpression}`;
    }
    return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")}${whereExpression} RETURNING ${returningExpression}`;
  }
  /**
   * Creates "ORDER BY" part of SQL query.
   */
  createOrderByExpression() {
    const orderBys = this.expressionMap.orderBys;
    if (Object.keys(orderBys).length > 0) return " ORDER BY " + Object.keys(orderBys).map((columnName) => {
      if (typeof orderBys[columnName] === "string") {
        return this.replacePropertyNames(columnName) + " " + orderBys[columnName];
      } else {
        return this.replacePropertyNames(columnName) + " " + orderBys[columnName].order + " " + orderBys[columnName].nulls;
      }
    }).join(", ");
    return "";
  }
  /**
   * Creates "LIMIT" parts of SQL query.
   */
  createLimitExpression() {
    let limit = this.expressionMap.limit;
    if (limit) {
      if (DriverUtils.isMySQLFamily(this.connection.driver)) {
        return " LIMIT " + limit;
      } else {
        throw new LimitOnUpdateNotSupportedError();
      }
    }
    return "";
  }
};

// ../node_modules/typeorm/browser/query-builder/UpdateQueryBuilder.js
var UpdateQueryBuilder = class extends QueryBuilder {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connectionOrQueryBuilder, queryRunner) {
    super(connectionOrQueryBuilder, queryRunner);
    this["@instanceof"] = Symbol.for("UpdateQueryBuilder");
    this.expressionMap.aliasNamePrefixingEnabled = false;
  }
  // -------------------------------------------------------------------------
  // Public Implemented Methods
  // -------------------------------------------------------------------------
  /**
   * Gets generated SQL query without parameters being replaced.
   */
  getQuery() {
    let sql = this.createComment();
    sql += this.createCteExpression();
    sql += this.createUpdateExpression();
    sql += this.createOrderByExpression();
    sql += this.createLimitExpression();
    return this.replacePropertyNamesForTheWholeQuery(sql.trim());
  }
  /**
   * Executes sql generated by query builder and returns raw database results.
   */
  execute() {
    return __async(this, null, function* () {
      const queryRunner = this.obtainQueryRunner();
      let transactionStartedByUs = false;
      try {
        if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
          yield queryRunner.startTransaction();
          transactionStartedByUs = true;
        }
        if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
          yield queryRunner.broadcaster.broadcast("BeforeUpdate", this.expressionMap.mainAlias.metadata, this.expressionMap.valuesSet);
        }
        let declareSql = null;
        let selectOutputSql = null;
        const returningResultsEntityUpdator = new ReturningResultsEntityUpdator(queryRunner, this.expressionMap);
        const returningColumns = [];
        if (Array.isArray(this.expressionMap.returning) && this.expressionMap.mainAlias.hasMetadata) {
          for (const columnPath of this.expressionMap.returning) {
            returningColumns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnPath));
          }
        }
        if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {
          this.expressionMap.extraReturningColumns = returningResultsEntityUpdator.getUpdationReturningColumns();
          returningColumns.push(...this.expressionMap.extraReturningColumns.filter((c) => !returningColumns.includes(c)));
        }
        if (returningColumns.length > 0 && this.connection.driver.options.type === "mssql") {
          declareSql = this.connection.driver.buildTableVariableDeclaration("@OutputTable", returningColumns);
          selectOutputSql = `SELECT * FROM @OutputTable`;
        }
        const [updateSql, parameters] = this.getQueryAndParameters();
        const statements = [declareSql, updateSql, selectOutputSql];
        const queryResult = yield queryRunner.query(statements.filter((sql) => sql != null).join(";\n\n"), parameters, true);
        const updateResult = UpdateResult.from(queryResult);
        if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {
          yield returningResultsEntityUpdator.update(updateResult, this.expressionMap.whereEntities);
        }
        if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
          yield queryRunner.broadcaster.broadcast("AfterUpdate", this.expressionMap.mainAlias.metadata, this.expressionMap.valuesSet);
        }
        if (transactionStartedByUs) yield queryRunner.commitTransaction();
        return updateResult;
      } catch (error) {
        if (transactionStartedByUs) {
          try {
            yield queryRunner.rollbackTransaction();
          } catch (rollbackError) {
          }
        }
        throw error;
      } finally {
        if (queryRunner !== this.queryRunner) {
          yield queryRunner.release();
        }
      }
    });
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Values needs to be updated.
   */
  set(values) {
    this.expressionMap.valuesSet = values;
    return this;
  }
  /**
   * Sets WHERE condition in the query builder.
   * If you had previously WHERE expression defined,
   * calling this function will override previously set WHERE conditions.
   * Additionally you can add parameters used in where expression.
   */
  where(where, parameters) {
    this.expressionMap.wheres = [];
    const condition = this.getWhereCondition(where);
    if (condition) this.expressionMap.wheres = [{
      type: "simple",
      condition
    }];
    if (parameters) this.setParameters(parameters);
    return this;
  }
  /**
   * Adds new AND WHERE condition in the query builder.
   * Additionally you can add parameters used in where expression.
   */
  andWhere(where, parameters) {
    this.expressionMap.wheres.push({
      type: "and",
      condition: this.getWhereCondition(where)
    });
    if (parameters) this.setParameters(parameters);
    return this;
  }
  /**
   * Adds new OR WHERE condition in the query builder.
   * Additionally you can add parameters used in where expression.
   */
  orWhere(where, parameters) {
    this.expressionMap.wheres.push({
      type: "or",
      condition: this.getWhereCondition(where)
    });
    if (parameters) this.setParameters(parameters);
    return this;
  }
  /**
   * Sets WHERE condition in the query builder with a condition for the given ids.
   * If you had previously WHERE expression defined,
   * calling this function will override previously set WHERE conditions.
   */
  whereInIds(ids) {
    return this.where(this.getWhereInIdsCondition(ids));
  }
  /**
   * Adds new AND WHERE with conditions for the given ids.
   */
  andWhereInIds(ids) {
    return this.andWhere(this.getWhereInIdsCondition(ids));
  }
  /**
   * Adds new OR WHERE with conditions for the given ids.
   */
  orWhereInIds(ids) {
    return this.orWhere(this.getWhereInIdsCondition(ids));
  }
  /**
   * Optional returning/output clause.
   */
  output(output) {
    return this.returning(output);
  }
  /**
   * Optional returning/output clause.
   */
  returning(returning) {
    if (!this.connection.driver.isReturningSqlSupported("update")) {
      throw new ReturningStatementNotSupportedError();
    }
    this.expressionMap.returning = returning;
    return this;
  }
  /**
   * Sets ORDER BY condition in the query builder.
   * If you had previously ORDER BY expression defined,
   * calling this function will override previously set ORDER BY conditions.
   */
  orderBy(sort, order = "ASC", nulls) {
    if (sort) {
      if (typeof sort === "object") {
        this.expressionMap.orderBys = sort;
      } else {
        if (nulls) {
          this.expressionMap.orderBys = {
            [sort]: {
              order,
              nulls
            }
          };
        } else {
          this.expressionMap.orderBys = {
            [sort]: order
          };
        }
      }
    } else {
      this.expressionMap.orderBys = {};
    }
    return this;
  }
  /**
   * Adds ORDER BY condition in the query builder.
   */
  addOrderBy(sort, order = "ASC", nulls) {
    if (nulls) {
      this.expressionMap.orderBys[sort] = {
        order,
        nulls
      };
    } else {
      this.expressionMap.orderBys[sort] = order;
    }
    return this;
  }
  /**
   * Sets LIMIT - maximum number of rows to be selected.
   */
  limit(limit) {
    this.expressionMap.limit = limit;
    return this;
  }
  /**
   * Indicates if entity must be updated after update operation.
   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).
   * Enabled by default.
   */
  whereEntity(entity) {
    if (!this.expressionMap.mainAlias.hasMetadata) throw new TypeORMError(`.whereEntity method can only be used on queries which update real entity table.`);
    this.expressionMap.wheres = [];
    const entities = Array.isArray(entity) ? entity : [entity];
    entities.forEach((entity2) => {
      const entityIdMap = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity2);
      if (!entityIdMap) throw new TypeORMError(`Provided entity does not have ids set, cannot perform operation.`);
      this.orWhereInIds(entityIdMap);
    });
    this.expressionMap.whereEntities = entities;
    return this;
  }
  /**
   * Indicates if entity must be updated after update operation.
   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).
   * Enabled by default.
   */
  updateEntity(enabled) {
    this.expressionMap.updateEntity = enabled;
    return this;
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Creates UPDATE express used to perform insert query.
   */
  createUpdateExpression() {
    const valuesSet = this.getValueSet();
    const metadata = this.expressionMap.mainAlias.hasMetadata ? this.expressionMap.mainAlias.metadata : void 0;
    const valuesSetNormalized = {};
    for (let key in valuesSet) {
      if (valuesSet[key] !== void 0) {
        valuesSetNormalized[key] = valuesSet[key];
      }
    }
    const updateColumnAndValues = [];
    const updatedColumns = [];
    if (metadata) {
      this.createPropertyPath(metadata, valuesSetNormalized).forEach((propertyPath) => {
        const columns = metadata.findColumnsWithPropertyPath(propertyPath);
        if (columns.length <= 0) {
          throw new EntityPropertyNotFoundError(propertyPath, metadata);
        }
        columns.forEach((column) => {
          if (!column.isUpdate || updatedColumns.includes(column)) {
            return;
          }
          updatedColumns.push(column);
          let value = column.getEntityValue(valuesSetNormalized);
          if (column.referencedColumn && typeof value === "object" && !(value instanceof Date) && value !== null && !Buffer.isBuffer(value)) {
            value = column.referencedColumn.getEntityValue(value);
          } else if (!(typeof value === "function")) {
            value = this.connection.driver.preparePersistentValue(value, column);
          }
          if (typeof value === "function") {
            updateColumnAndValues.push(this.escape(column.databaseName) + " = " + value());
          } else if ((this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") && value === null) {
            updateColumnAndValues.push(this.escape(column.databaseName) + " = NULL");
          } else {
            if (this.connection.driver.options.type === "mssql") {
              value = this.connection.driver.parametrizeValue(column, value);
            }
            const paramName = this.createParameter(value);
            let expression = null;
            if ((DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
              const useLegacy = this.connection.driver.options.legacySpatialSupport;
              const geomFromText = useLegacy ? "GeomFromText" : "ST_GeomFromText";
              if (column.srid != null) {
                expression = `${geomFromText}(${paramName}, ${column.srid})`;
              } else {
                expression = `${geomFromText}(${paramName})`;
              }
            } else if (DriverUtils.isPostgresFamily(this.connection.driver) && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
              if (column.srid != null) {
                expression = `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`;
              } else {
                expression = `ST_GeomFromGeoJSON(${paramName})::${column.type}`;
              }
            } else if (this.connection.driver.options.type === "mssql" && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
              expression = column.type + "::STGeomFromText(" + paramName + ", " + (column.srid || "0") + ")";
            } else {
              expression = paramName;
            }
            updateColumnAndValues.push(this.escape(column.databaseName) + " = " + expression);
          }
        });
      });
      if (updateColumnAndValues.length > 0 || Object.keys(valuesSetNormalized).length === 0) {
        if (metadata.versionColumn && updatedColumns.indexOf(metadata.versionColumn) === -1) updateColumnAndValues.push(this.escape(metadata.versionColumn.databaseName) + " = " + this.escape(metadata.versionColumn.databaseName) + " + 1");
        if (metadata.updateDateColumn && updatedColumns.indexOf(metadata.updateDateColumn) === -1) updateColumnAndValues.push(this.escape(metadata.updateDateColumn.databaseName) + " = CURRENT_TIMESTAMP");
      }
    } else {
      Object.keys(valuesSetNormalized).map((key) => {
        let value = valuesSetNormalized[key];
        if (typeof value === "function") {
          updateColumnAndValues.push(this.escape(key) + " = " + value());
        } else if ((this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") && value === null) {
          updateColumnAndValues.push(this.escape(key) + " = NULL");
        } else {
          const paramName = this.createParameter(value);
          updateColumnAndValues.push(this.escape(key) + " = " + paramName);
        }
      });
    }
    if (updateColumnAndValues.length <= 0) {
      throw new UpdateValuesMissingError();
    }
    const whereExpression = this.createWhereExpression();
    const returningExpression = this.createReturningExpression("update");
    if (returningExpression === "") {
      return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")}${whereExpression}`;
    }
    if (this.connection.driver.options.type === "mssql") {
      return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")} OUTPUT ${returningExpression}${whereExpression}`;
    }
    return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")}${whereExpression} RETURNING ${returningExpression}`;
  }
  /**
   * Creates "ORDER BY" part of SQL query.
   */
  createOrderByExpression() {
    const orderBys = this.expressionMap.orderBys;
    if (Object.keys(orderBys).length > 0) return " ORDER BY " + Object.keys(orderBys).map((columnName) => {
      if (typeof orderBys[columnName] === "string") {
        return this.replacePropertyNames(columnName) + " " + orderBys[columnName];
      } else {
        return this.replacePropertyNames(columnName) + " " + orderBys[columnName].order + " " + orderBys[columnName].nulls;
      }
    }).join(", ");
    return "";
  }
  /**
   * Creates "LIMIT" parts of SQL query.
   */
  createLimitExpression() {
    let limit = this.expressionMap.limit;
    if (limit) {
      if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") {
        return " LIMIT " + limit;
      } else {
        throw new LimitOnUpdateNotSupportedError();
      }
    }
    return "";
  }
  /**
   * Gets array of values need to be inserted into the target table.
   */
  getValueSet() {
    if (typeof this.expressionMap.valuesSet === "object") return this.expressionMap.valuesSet;
    throw new UpdateValuesMissingError();
  }
};

// ../node_modules/typeorm/browser/query-builder/index.js
function registerQueryBuilders() {
  QueryBuilder.registerQueryBuilderClass("DeleteQueryBuilder", (qb) => new DeleteQueryBuilder(qb));
  QueryBuilder.registerQueryBuilderClass("InsertQueryBuilder", (qb) => new InsertQueryBuilder(qb));
  QueryBuilder.registerQueryBuilderClass("RelationQueryBuilder", (qb) => new RelationQueryBuilder(qb));
  QueryBuilder.registerQueryBuilderClass("SelectQueryBuilder", (qb) => new SelectQueryBuilder(qb));
  QueryBuilder.registerQueryBuilderClass("SoftDeleteQueryBuilder", (qb) => new SoftDeleteQueryBuilder(qb));
  QueryBuilder.registerQueryBuilderClass("UpdateQueryBuilder", (qb) => new UpdateQueryBuilder(qb));
}

// ../node_modules/typeorm/browser/util/RandomGenerator.js
var RandomGenerator = class {
  /**
   *  discuss at: http://locutus.io/php/sha1/
   * original by: Webtoolkit.info (http://www.webtoolkit.info/)
   * improved by: Michael White (http://getsprink.com)
   * improved by: Kevin van Zonneveld (http://kvz.io)
   *    input by: Brett Zamir (http://brett-zamir.me)
   *      note 1: Keep in mind that in accordance with PHP, the whole string is buffered and then
   *      note 1: hashed. If available, we'd recommend using Node's native crypto modules directly
   *      note 1: in a steaming fashion for faster and more efficient hashing
   *   example 1: sha1('Kevin van Zonneveld')
   *   returns 1: '54916d2e62f65b3afa6e192e6a601cdbe5cb5897'
   */
  static sha1(str) {
    let _rotLeft = function(n, s) {
      let t4 = n << s | n >>> 32 - s;
      return t4;
    };
    let _cvtHex = function(val) {
      let str2 = "";
      let i2;
      let v;
      for (i2 = 7; i2 >= 0; i2--) {
        v = val >>> i2 * 4 & 15;
        str2 += v.toString(16);
      }
      return str2;
    };
    let blockstart;
    let i, j;
    let W = new Array(80);
    let H0 = 1732584193;
    let H1 = 4023233417;
    let H2 = 2562383102;
    let H3 = 271733878;
    let H4 = 3285377520;
    let A, B, C, D, E;
    let temp;
    str = /*unescape*/
    encodeURIComponent(str);
    let strLen = str.length;
    let wordArray = [];
    for (i = 0; i < strLen - 3; i += 4) {
      j = str.charCodeAt(i) << 24 | str.charCodeAt(i + 1) << 16 | str.charCodeAt(i + 2) << 8 | str.charCodeAt(i + 3);
      wordArray.push(j);
    }
    switch (strLen % 4) {
      case 0:
        i = 2147483648;
        break;
      case 1:
        i = str.charCodeAt(strLen - 1) << 24 | 8388608;
        break;
      case 2:
        i = str.charCodeAt(strLen - 2) << 24 | str.charCodeAt(strLen - 1) << 16 | 32768;
        break;
      case 3:
        i = str.charCodeAt(strLen - 3) << 24 | str.charCodeAt(strLen - 2) << 16 | str.charCodeAt(strLen - 1) << 8 | 128;
        break;
    }
    wordArray.push(i);
    while (wordArray.length % 16 !== 14) {
      wordArray.push(0);
    }
    wordArray.push(strLen >>> 29);
    wordArray.push(strLen << 3 & 4294967295);
    for (blockstart = 0; blockstart < wordArray.length; blockstart += 16) {
      for (i = 0; i < 16; i++) {
        W[i] = wordArray[blockstart + i];
      }
      for (i = 16; i <= 79; i++) {
        W[i] = _rotLeft(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
      }
      A = H0;
      B = H1;
      C = H2;
      D = H3;
      E = H4;
      for (i = 0; i <= 19; i++) {
        temp = _rotLeft(A, 5) + (B & C | ~B & D) + E + W[i] + 1518500249 & 4294967295;
        E = D;
        D = C;
        C = _rotLeft(B, 30);
        B = A;
        A = temp;
      }
      for (i = 20; i <= 39; i++) {
        temp = _rotLeft(A, 5) + (B ^ C ^ D) + E + W[i] + 1859775393 & 4294967295;
        E = D;
        D = C;
        C = _rotLeft(B, 30);
        B = A;
        A = temp;
      }
      for (i = 40; i <= 59; i++) {
        temp = _rotLeft(A, 5) + (B & C | B & D | C & D) + E + W[i] + 2400959708 & 4294967295;
        E = D;
        D = C;
        C = _rotLeft(B, 30);
        B = A;
        A = temp;
      }
      for (i = 60; i <= 79; i++) {
        temp = _rotLeft(A, 5) + (B ^ C ^ D) + E + W[i] + 3395469782 & 4294967295;
        E = D;
        D = C;
        C = _rotLeft(B, 30);
        B = A;
        A = temp;
      }
      H0 = H0 + A & 4294967295;
      H1 = H1 + B & 4294967295;
      H2 = H2 + C & 4294967295;
      H3 = H3 + D & 4294967295;
      H4 = H4 + E & 4294967295;
    }
    temp = _cvtHex(H0) + _cvtHex(H1) + _cvtHex(H2) + _cvtHex(H3) + _cvtHex(H4);
    return temp.toLowerCase();
  }
};

// ../node_modules/typeorm/browser/naming-strategy/DefaultNamingStrategy.js
var DefaultNamingStrategy = class {
  constructor() {
    this.nestedSetColumnNames = {
      left: "nsleft",
      right: "nsright"
    };
    this.materializedPathColumnName = "mpath";
  }
  getTableName(tableOrName) {
    if (typeof tableOrName !== "string") {
      tableOrName = tableOrName.name;
    }
    return tableOrName.split(".").pop();
  }
  /**
   * Normalizes table name.
   *
   * @param targetName Name of the target entity that can be used to generate a table name.
   * @param userSpecifiedName For example if user specified a table name in a decorator, e.g. @Entity("name")
   */
  tableName(targetName, userSpecifiedName) {
    return userSpecifiedName ? userSpecifiedName : snakeCase(targetName);
  }
  /**
   * Creates a table name for a junction table of a closure table.
   *
   * @param originalClosureTableName Name of the closure table which owns this junction table.
   */
  closureJunctionTableName(originalClosureTableName) {
    return originalClosureTableName + "_closure";
  }
  columnName(propertyName, customName, embeddedPrefixes) {
    const name = customName || propertyName;
    if (embeddedPrefixes.length) return camelCase(embeddedPrefixes.join("_")) + titleCase(name);
    return name;
  }
  relationName(propertyName) {
    return propertyName;
  }
  primaryKeyName(tableOrName, columnNames) {
    const clonedColumnNames = [...columnNames];
    clonedColumnNames.sort();
    const tableName = this.getTableName(tableOrName);
    const replacedTableName = tableName.replace(".", "_");
    const key = `${replacedTableName}_${clonedColumnNames.join("_")}`;
    return "PK_" + RandomGenerator.sha1(key).substr(0, 27);
  }
  uniqueConstraintName(tableOrName, columnNames) {
    const clonedColumnNames = [...columnNames];
    clonedColumnNames.sort();
    const tableName = this.getTableName(tableOrName);
    const replacedTableName = tableName.replace(".", "_");
    const key = `${replacedTableName}_${clonedColumnNames.join("_")}`;
    return "UQ_" + RandomGenerator.sha1(key).substr(0, 27);
  }
  relationConstraintName(tableOrName, columnNames, where) {
    const clonedColumnNames = [...columnNames];
    clonedColumnNames.sort();
    const tableName = this.getTableName(tableOrName);
    const replacedTableName = tableName.replace(".", "_");
    let key = `${replacedTableName}_${clonedColumnNames.join("_")}`;
    if (where) key += `_${where}`;
    return "REL_" + RandomGenerator.sha1(key).substr(0, 26);
  }
  defaultConstraintName(tableOrName, columnName) {
    const tableName = this.getTableName(tableOrName);
    const replacedTableName = tableName.replace(".", "_");
    const key = `${replacedTableName}_${columnName}`;
    return "DF_" + RandomGenerator.sha1(key).substr(0, 27);
  }
  foreignKeyName(tableOrName, columnNames, _referencedTablePath, _referencedColumnNames) {
    const clonedColumnNames = [...columnNames];
    clonedColumnNames.sort();
    const tableName = this.getTableName(tableOrName);
    const replacedTableName = tableName.replace(".", "_");
    const key = `${replacedTableName}_${clonedColumnNames.join("_")}`;
    return "FK_" + RandomGenerator.sha1(key).substr(0, 27);
  }
  indexName(tableOrName, columnNames, where) {
    const clonedColumnNames = [...columnNames];
    clonedColumnNames.sort();
    const tableName = this.getTableName(tableOrName);
    const replacedTableName = tableName.replace(".", "_");
    let key = `${replacedTableName}_${clonedColumnNames.join("_")}`;
    if (where) key += `_${where}`;
    return "IDX_" + RandomGenerator.sha1(key).substr(0, 26);
  }
  checkConstraintName(tableOrName, expression, isEnum) {
    const tableName = this.getTableName(tableOrName);
    const replacedTableName = tableName.replace(".", "_");
    const key = `${replacedTableName}_${expression}`;
    const name = "CHK_" + RandomGenerator.sha1(key).substr(0, 26);
    return isEnum ? `${name}_ENUM` : name;
  }
  exclusionConstraintName(tableOrName, expression) {
    const tableName = this.getTableName(tableOrName);
    const replacedTableName = tableName.replace(".", "_");
    const key = `${replacedTableName}_${expression}`;
    return "XCL_" + RandomGenerator.sha1(key).substr(0, 26);
  }
  joinColumnName(relationName, referencedColumnName) {
    return camelCase(relationName + "_" + referencedColumnName);
  }
  joinTableName(firstTableName, secondTableName, firstPropertyName, secondPropertyName) {
    return snakeCase(firstTableName + "_" + firstPropertyName.replace(/\./gi, "_") + "_" + secondTableName);
  }
  joinTableColumnDuplicationPrefix(columnName, index) {
    return columnName + "_" + index;
  }
  joinTableColumnName(tableName, propertyName, columnName) {
    return camelCase(tableName + "_" + (columnName ? columnName : propertyName));
  }
  joinTableInverseColumnName(tableName, propertyName, columnName) {
    return this.joinTableColumnName(tableName, propertyName, columnName);
  }
  /**
   * Adds globally set prefix to the table name.
   * This method is executed no matter if prefix was set or not.
   * Table name is either user's given table name, either name generated from entity target.
   * Note that table name comes here already normalized by #tableName method.
   */
  prefixTableName(prefix, tableName) {
    return prefix + tableName;
  }
};

// ../node_modules/typeorm/browser/schema-builder/table/TableColumn.js
var TableColumn = class _TableColumn {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(options) {
    this["@instanceof"] = Symbol.for("TableColumn");
    this.isNullable = false;
    this.isGenerated = false;
    this.isPrimary = false;
    this.isUnique = false;
    this.isArray = false;
    this.length = "";
    this.zerofill = false;
    this.unsigned = false;
    if (options) {
      this.name = options.name;
      this.type = options.type || "";
      this.length = options.length || "";
      this.width = options.width;
      this.charset = options.charset;
      this.collation = options.collation;
      this.precision = options.precision;
      this.scale = options.scale;
      this.zerofill = options.zerofill || false;
      this.unsigned = this.zerofill ? true : options.unsigned || false;
      this.default = options.default;
      this.onUpdate = options.onUpdate;
      this.isNullable = options.isNullable || false;
      this.isGenerated = options.isGenerated || false;
      this.generationStrategy = options.generationStrategy;
      this.generatedIdentity = options.generatedIdentity;
      this.isPrimary = options.isPrimary || false;
      this.isUnique = options.isUnique || false;
      this.isArray = options.isArray || false;
      this.comment = options.comment;
      this.enum = options.enum;
      this.enumName = options.enumName;
      this.primaryKeyConstraintName = options.primaryKeyConstraintName;
      this.asExpression = options.asExpression;
      this.generatedType = options.generatedType;
      this.spatialFeatureType = options.spatialFeatureType;
      this.srid = options.srid;
    }
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Clones this column to a new column with exact same properties as this column has.
   */
  clone() {
    return new _TableColumn({
      name: this.name,
      type: this.type,
      length: this.length,
      width: this.width,
      charset: this.charset,
      collation: this.collation,
      precision: this.precision,
      scale: this.scale,
      zerofill: this.zerofill,
      unsigned: this.unsigned,
      enum: this.enum,
      enumName: this.enumName,
      primaryKeyConstraintName: this.primaryKeyConstraintName,
      asExpression: this.asExpression,
      generatedType: this.generatedType,
      default: this.default,
      onUpdate: this.onUpdate,
      isNullable: this.isNullable,
      isGenerated: this.isGenerated,
      generationStrategy: this.generationStrategy,
      generatedIdentity: this.generatedIdentity,
      isPrimary: this.isPrimary,
      isUnique: this.isUnique,
      isArray: this.isArray,
      comment: this.comment,
      spatialFeatureType: this.spatialFeatureType,
      srid: this.srid
    });
  }
};

// ../node_modules/typeorm/browser/schema-builder/table/TableIndex.js
var TableIndex = class _TableIndex {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(options) {
    this["@instanceof"] = Symbol.for("TableIndex");
    this.columnNames = [];
    this.name = options.name;
    this.columnNames = options.columnNames;
    this.isUnique = !!options.isUnique;
    this.isSpatial = !!options.isSpatial;
    this.isConcurrent = !!options.isConcurrent;
    this.isFulltext = !!options.isFulltext;
    this.isNullFiltered = !!options.isNullFiltered;
    this.parser = options.parser;
    this.where = options.where ? options.where : "";
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates a new copy of this index with exactly same properties.
   */
  clone() {
    return new _TableIndex({
      name: this.name,
      columnNames: [...this.columnNames],
      isUnique: this.isUnique,
      isSpatial: this.isSpatial,
      isConcurrent: this.isConcurrent,
      isFulltext: this.isFulltext,
      isNullFiltered: this.isNullFiltered,
      parser: this.parser,
      where: this.where
    });
  }
  // -------------------------------------------------------------------------
  // Static Methods
  // -------------------------------------------------------------------------
  /**
   * Creates index from the index metadata object.
   */
  static create(indexMetadata) {
    return new _TableIndex({
      name: indexMetadata.name,
      columnNames: indexMetadata.columns.map((column) => column.databaseName),
      isUnique: indexMetadata.isUnique,
      isSpatial: indexMetadata.isSpatial,
      isConcurrent: indexMetadata.isConcurrent,
      isFulltext: indexMetadata.isFulltext,
      isNullFiltered: indexMetadata.isNullFiltered,
      parser: indexMetadata.parser,
      where: indexMetadata.where
    });
  }
};

// ../node_modules/typeorm/browser/schema-builder/table/TableForeignKey.js
var TableForeignKey = class _TableForeignKey {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(options) {
    this["@instanceof"] = Symbol.for("TableForeignKey");
    this.columnNames = [];
    this.referencedColumnNames = [];
    this.name = options.name;
    this.columnNames = options.columnNames;
    this.referencedColumnNames = options.referencedColumnNames;
    this.referencedDatabase = options.referencedDatabase;
    this.referencedSchema = options.referencedSchema;
    this.referencedTableName = options.referencedTableName;
    this.onDelete = options.onDelete;
    this.onUpdate = options.onUpdate;
    this.deferrable = options.deferrable;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates a new copy of this foreign key with exactly same properties.
   */
  clone() {
    return new _TableForeignKey({
      name: this.name,
      columnNames: [...this.columnNames],
      referencedColumnNames: [...this.referencedColumnNames],
      referencedDatabase: this.referencedDatabase,
      referencedSchema: this.referencedSchema,
      referencedTableName: this.referencedTableName,
      onDelete: this.onDelete,
      onUpdate: this.onUpdate,
      deferrable: this.deferrable
    });
  }
  // -------------------------------------------------------------------------
  // Static Methods
  // -------------------------------------------------------------------------
  /**
   * Creates a new table foreign key from the given foreign key metadata.
   */
  static create(metadata, driver) {
    return new _TableForeignKey({
      name: metadata.name,
      columnNames: metadata.columnNames,
      referencedColumnNames: metadata.referencedColumnNames,
      referencedDatabase: metadata.referencedEntityMetadata.database,
      referencedSchema: metadata.referencedEntityMetadata.schema,
      referencedTableName: metadata.referencedTablePath,
      onDelete: metadata.onDelete,
      onUpdate: metadata.onUpdate,
      deferrable: metadata.deferrable
    });
  }
};

// ../node_modules/typeorm/browser/schema-builder/util/TableUtils.js
var TableUtils = class {
  static createTableColumnOptions(columnMetadata, driver) {
    return {
      name: columnMetadata.databaseName,
      length: driver.getColumnLength(columnMetadata),
      width: columnMetadata.width,
      charset: columnMetadata.charset,
      collation: columnMetadata.collation,
      precision: columnMetadata.precision,
      scale: columnMetadata.scale,
      zerofill: columnMetadata.zerofill,
      unsigned: columnMetadata.unsigned,
      asExpression: columnMetadata.asExpression,
      generatedType: columnMetadata.generatedType,
      default: driver.normalizeDefault(columnMetadata),
      onUpdate: columnMetadata.onUpdate,
      comment: columnMetadata.comment,
      isGenerated: columnMetadata.isGenerated,
      generationStrategy: columnMetadata.generationStrategy,
      generatedIdentity: columnMetadata.generatedIdentity,
      isNullable: columnMetadata.isNullable,
      type: driver.normalizeType(columnMetadata),
      isPrimary: columnMetadata.isPrimary,
      isUnique: driver.normalizeIsUnique(columnMetadata),
      isArray: columnMetadata.isArray || false,
      enum: columnMetadata.enum ? columnMetadata.enum.map((val) => val + "") : columnMetadata.enum,
      enumName: columnMetadata.enumName,
      primaryKeyConstraintName: columnMetadata.primaryKeyConstraintName,
      spatialFeatureType: columnMetadata.spatialFeatureType,
      srid: columnMetadata.srid
    };
  }
};

// ../node_modules/typeorm/browser/schema-builder/table/TableUnique.js
var TableUnique = class _TableUnique {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(options) {
    this["@instanceof"] = Symbol.for("TableUnique");
    this.columnNames = [];
    this.name = options.name;
    this.columnNames = options.columnNames;
    this.deferrable = options.deferrable;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates a new copy of this constraint with exactly same properties.
   */
  clone() {
    return new _TableUnique({
      name: this.name,
      columnNames: [...this.columnNames],
      deferrable: this.deferrable
    });
  }
  // -------------------------------------------------------------------------
  // Static Methods
  // -------------------------------------------------------------------------
  /**
   * Creates unique from the unique metadata object.
   */
  static create(uniqueMetadata) {
    return new _TableUnique({
      name: uniqueMetadata.name,
      columnNames: uniqueMetadata.columns.map((column) => column.databaseName),
      deferrable: uniqueMetadata.deferrable
    });
  }
};

// ../node_modules/typeorm/browser/schema-builder/table/TableCheck.js
var TableCheck = class _TableCheck {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(options) {
    this["@instanceof"] = Symbol.for("TableCheck");
    this.columnNames = [];
    this.name = options.name;
    this.columnNames = options.columnNames;
    this.expression = options.expression;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates a new copy of this constraint with exactly same properties.
   */
  clone() {
    return new _TableCheck({
      name: this.name,
      columnNames: this.columnNames ? [...this.columnNames] : [],
      expression: this.expression
    });
  }
  // -------------------------------------------------------------------------
  // Static Methods
  // -------------------------------------------------------------------------
  /**
   * Creates checks from the check metadata object.
   */
  static create(checkMetadata) {
    return new _TableCheck({
      name: checkMetadata.name,
      expression: checkMetadata.expression
    });
  }
};

// ../node_modules/typeorm/browser/schema-builder/table/TableExclusion.js
var TableExclusion = class _TableExclusion {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(options) {
    this["@instanceof"] = Symbol.for("TableExclusion");
    this.name = options.name;
    this.expression = options.expression;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates a new copy of this constraint with exactly same properties.
   */
  clone() {
    return new _TableExclusion({
      name: this.name,
      expression: this.expression
    });
  }
  // -------------------------------------------------------------------------
  // Static Methods
  // -------------------------------------------------------------------------
  /**
   * Creates exclusions from the exclusion metadata object.
   */
  static create(exclusionMetadata) {
    return new _TableExclusion({
      name: exclusionMetadata.name,
      expression: exclusionMetadata.expression
    });
  }
};

// ../node_modules/typeorm/browser/schema-builder/table/Table.js
var Table = class _Table {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(options) {
    this["@instanceof"] = Symbol.for("Table");
    this.columns = [];
    this.indices = [];
    this.foreignKeys = [];
    this.uniques = [];
    this.checks = [];
    this.exclusions = [];
    this.justCreated = false;
    this.withoutRowid = false;
    if (options) {
      this.database = options.database;
      this.schema = options.schema;
      this.name = options.name;
      if (options.columns) this.columns = options.columns.map((column) => new TableColumn(column));
      if (options.indices) this.indices = options.indices.map((index) => new TableIndex(index));
      if (options.foreignKeys) this.foreignKeys = options.foreignKeys.map((foreignKey) => new TableForeignKey(__spreadProps(__spreadValues({}, foreignKey), {
        referencedDatabase: foreignKey?.referencedDatabase || options.database,
        referencedSchema: foreignKey?.referencedSchema || options.schema
      })));
      if (options.uniques) this.uniques = options.uniques.map((unique) => new TableUnique(unique));
      if (options.checks) this.checks = options.checks.map((check) => new TableCheck(check));
      if (options.exclusions) this.exclusions = options.exclusions.map((exclusion) => new TableExclusion(exclusion));
      if (options.justCreated !== void 0) this.justCreated = options.justCreated;
      if (options.withoutRowid) this.withoutRowid = options.withoutRowid;
      this.engine = options.engine;
      this.comment = options.comment;
    }
  }
  // -------------------------------------------------------------------------
  // Accessors
  // -------------------------------------------------------------------------
  get primaryColumns() {
    return this.columns.filter((column) => column.isPrimary);
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Clones this table to a new table with all properties cloned.
   */
  clone() {
    return new _Table({
      schema: this.schema,
      database: this.database,
      name: this.name,
      columns: this.columns.map((column) => column.clone()),
      indices: this.indices.map((constraint) => constraint.clone()),
      foreignKeys: this.foreignKeys.map((constraint) => constraint.clone()),
      uniques: this.uniques.map((constraint) => constraint.clone()),
      checks: this.checks.map((constraint) => constraint.clone()),
      exclusions: this.exclusions.map((constraint) => constraint.clone()),
      justCreated: this.justCreated,
      withoutRowid: this.withoutRowid,
      engine: this.engine,
      comment: this.comment
    });
  }
  /**
   * Add column and creates its constraints.
   */
  addColumn(column) {
    this.columns.push(column);
  }
  /**
   * Remove column and its constraints.
   */
  removeColumn(column) {
    const foundColumn = this.columns.find((c) => c.name === column.name);
    if (foundColumn) this.columns.splice(this.columns.indexOf(foundColumn), 1);
  }
  /**
   * Adds unique constraint.
   */
  addUniqueConstraint(uniqueConstraint) {
    this.uniques.push(uniqueConstraint);
    if (uniqueConstraint.columnNames.length === 1) {
      const uniqueColumn = this.columns.find((column) => column.name === uniqueConstraint.columnNames[0]);
      if (uniqueColumn) uniqueColumn.isUnique = true;
    }
  }
  /**
   * Removes unique constraint.
   */
  removeUniqueConstraint(removedUnique) {
    const foundUnique = this.uniques.find((unique) => unique.name === removedUnique.name);
    if (foundUnique) {
      this.uniques.splice(this.uniques.indexOf(foundUnique), 1);
      if (foundUnique.columnNames.length === 1) {
        const uniqueColumn = this.columns.find((column) => column.name === foundUnique.columnNames[0]);
        if (uniqueColumn) uniqueColumn.isUnique = false;
      }
    }
  }
  /**
   * Adds check constraint.
   */
  addCheckConstraint(checkConstraint) {
    this.checks.push(checkConstraint);
  }
  /**
   * Removes check constraint.
   */
  removeCheckConstraint(removedCheck) {
    const foundCheck = this.checks.find((check) => check.name === removedCheck.name);
    if (foundCheck) {
      this.checks.splice(this.checks.indexOf(foundCheck), 1);
    }
  }
  /**
   * Adds exclusion constraint.
   */
  addExclusionConstraint(exclusionConstraint) {
    this.exclusions.push(exclusionConstraint);
  }
  /**
   * Removes exclusion constraint.
   */
  removeExclusionConstraint(removedExclusion) {
    const foundExclusion = this.exclusions.find((exclusion) => exclusion.name === removedExclusion.name);
    if (foundExclusion) {
      this.exclusions.splice(this.exclusions.indexOf(foundExclusion), 1);
    }
  }
  /**
   * Adds foreign keys.
   */
  addForeignKey(foreignKey) {
    this.foreignKeys.push(foreignKey);
  }
  /**
   * Removes foreign key.
   */
  removeForeignKey(removedForeignKey) {
    const fk = this.foreignKeys.find((foreignKey) => foreignKey.name === removedForeignKey.name);
    if (fk) this.foreignKeys.splice(this.foreignKeys.indexOf(fk), 1);
  }
  /**
   * Adds index.
   */
  addIndex(index, isMysql = false) {
    this.indices.push(index);
    if (index.columnNames.length === 1 && index.isUnique && isMysql) {
      const column = this.columns.find((c) => c.name === index.columnNames[0]);
      if (column) column.isUnique = true;
    }
  }
  /**
   * Removes index.
   */
  removeIndex(tableIndex, isMysql = false) {
    const index = this.indices.find((index2) => index2.name === tableIndex.name);
    if (index) {
      this.indices.splice(this.indices.indexOf(index), 1);
      if (index.columnNames.length === 1 && index.isUnique && isMysql) {
        const column = this.columns.find((c) => c.name === index.columnNames[0]);
        if (column) column.isUnique = this.indices.some((ind) => ind.columnNames.length === 1 && ind.columnNames[0] === column.name && !!index.isUnique);
      }
    }
  }
  findColumnByName(name) {
    return this.columns.find((column) => column.name === name);
  }
  /**
   * Returns all column indices.
   */
  findColumnIndices(column) {
    return this.indices.filter((index) => {
      return !!index.columnNames.find((columnName) => columnName === column.name);
    });
  }
  /**
   * Returns all column foreign keys.
   */
  findColumnForeignKeys(column) {
    return this.foreignKeys.filter((foreignKey) => {
      return !!foreignKey.columnNames.find((columnName) => columnName === column.name);
    });
  }
  /**
   * Returns all column uniques.
   */
  findColumnUniques(column) {
    return this.uniques.filter((unique) => {
      return !!unique.columnNames.find((columnName) => columnName === column.name);
    });
  }
  /**
   * Returns all column checks.
   */
  findColumnChecks(column) {
    return this.checks.filter((check) => {
      return !!check.columnNames.find((columnName) => columnName === column.name);
    });
  }
  // -------------------------------------------------------------------------
  // Static Methods
  // -------------------------------------------------------------------------
  /**
   * Creates table from a given entity metadata.
   */
  static create(entityMetadata, driver) {
    const database = entityMetadata.database === driver.database ? void 0 : entityMetadata.database;
    const schema = entityMetadata.schema === driver.options.schema ? void 0 : entityMetadata.schema;
    const options = {
      database: entityMetadata.database,
      schema: entityMetadata.schema,
      name: driver.buildTableName(entityMetadata.tableName, schema, database),
      withoutRowid: entityMetadata.withoutRowid,
      engine: entityMetadata.engine,
      columns: entityMetadata.columns.filter((column) => column && !column.isVirtualProperty).map((column) => TableUtils.createTableColumnOptions(column, driver)),
      indices: entityMetadata.indices.filter((index) => index.synchronize === true).map((index) => TableIndex.create(index)),
      uniques: entityMetadata.uniques.map((unique) => TableUnique.create(unique)),
      checks: entityMetadata.checks.map((check) => TableCheck.create(check)),
      exclusions: entityMetadata.exclusions.map((exclusion) => TableExclusion.create(exclusion)),
      comment: entityMetadata.comment
    };
    return new _Table(options);
  }
};

// ../node_modules/typeorm/browser/migration/Migration.js
var Migration = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(id, timestamp, name, instance, transaction) {
    this.id = id;
    this.timestamp = timestamp;
    this.name = name;
    this.instance = instance;
    this.transaction = transaction;
  }
};

// ../node_modules/typeorm/browser/driver/sqlserver/MssqlParameter.js
var MssqlParameter = class {
  constructor(value, type, ...params) {
    this.value = value;
    this.type = type;
    this["@instanceof"] = Symbol.for("MssqlParameter");
    this.params = [];
    this.params = params || [];
  }
};

// ../node_modules/typeorm/browser/migration/MigrationExecutor.js
var MigrationExecutor = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection, queryRunner) {
    this.connection = connection;
    this.queryRunner = queryRunner;
    this.transaction = "all";
    const {
      schema
    } = this.connection.driver.options;
    const database = this.connection.driver.database;
    this.migrationsDatabase = database;
    this.migrationsSchema = schema;
    this.migrationsTableName = connection.options.migrationsTableName || "migrations";
    this.migrationsTable = this.connection.driver.buildTableName(this.migrationsTableName, schema, database);
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Tries to execute a single migration given.
   */
  executeMigration(migration) {
    return __async(this, null, function* () {
      return this.withQueryRunner((queryRunner) => __async(this, null, function* () {
        yield this.createMigrationsTableIfNotExist(queryRunner);
        const schemaBuilder = this.connection.driver.createSchemaBuilder();
        if (InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {
          yield schemaBuilder.createMetadataTableIfNecessary(queryRunner);
        }
        yield queryRunner.beforeMigration();
        yield migration.instance.up(queryRunner);
        yield queryRunner.afterMigration();
        yield this.insertExecutedMigration(queryRunner, migration);
        return migration;
      }));
    });
  }
  /**
   * Returns an array of all migrations.
   */
  getAllMigrations() {
    return __async(this, null, function* () {
      return Promise.resolve(this.getMigrations());
    });
  }
  /**
   * Returns an array of all executed migrations.
   */
  getExecutedMigrations() {
    return __async(this, null, function* () {
      return this.withQueryRunner((queryRunner) => __async(this, null, function* () {
        yield this.createMigrationsTableIfNotExist(queryRunner);
        return yield this.loadExecutedMigrations(queryRunner);
      }));
    });
  }
  /**
   * Returns an array of all pending migrations.
   */
  getPendingMigrations() {
    return __async(this, null, function* () {
      const allMigrations = yield this.getAllMigrations();
      const executedMigrations = yield this.getExecutedMigrations();
      return allMigrations.filter((migration) => !executedMigrations.find((executedMigration) => executedMigration.name === migration.name));
    });
  }
  /**
   * Inserts an executed migration.
   */
  insertMigration(migration) {
    return this.withQueryRunner((q) => this.insertExecutedMigration(q, migration));
  }
  /**
   * Deletes an executed migration.
   */
  deleteMigration(migration) {
    return this.withQueryRunner((q) => this.deleteExecutedMigration(q, migration));
  }
  /**
   * Lists all migrations and whether they have been executed or not
   * returns true if there are unapplied migrations
   */
  showMigrations() {
    return __async(this, null, function* () {
      let hasUnappliedMigrations = false;
      const queryRunner = this.queryRunner || this.connection.createQueryRunner();
      yield this.createMigrationsTableIfNotExist(queryRunner);
      const executedMigrations = yield this.loadExecutedMigrations(queryRunner);
      const allMigrations = this.getMigrations();
      for (const migration of allMigrations) {
        const executedMigration = executedMigrations.find((executedMigration2) => executedMigration2.name === migration.name);
        if (executedMigration) {
          this.connection.logger.logSchemaBuild(`[X] ${executedMigration.id} ${migration.name}`);
        } else {
          hasUnappliedMigrations = true;
          this.connection.logger.logSchemaBuild(`[ ] ${migration.name}`);
        }
      }
      if (!this.queryRunner) {
        yield queryRunner.release();
      }
      return hasUnappliedMigrations;
    });
  }
  /**
   * Executes all pending migrations. Pending migrations are migrations that are not yet executed,
   * thus not saved in the database.
   */
  executePendingMigrations() {
    return __async(this, null, function* () {
      const queryRunner = this.queryRunner || this.connection.createQueryRunner();
      yield this.createMigrationsTableIfNotExist(queryRunner);
      const schemaBuilder = this.connection.driver.createSchemaBuilder();
      if (InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {
        yield schemaBuilder.createMetadataTableIfNecessary(queryRunner);
      }
      const executedMigrations = yield this.loadExecutedMigrations(queryRunner);
      let lastTimeExecutedMigration = this.getLatestTimestampMigration(executedMigrations);
      const allMigrations = this.getMigrations();
      const successMigrations = [];
      const pendingMigrations = allMigrations.filter((migration) => {
        const executedMigration = executedMigrations.find((executedMigration2) => executedMigration2.name === migration.name);
        if (executedMigration) return false;
        return true;
      });
      if (!pendingMigrations.length) {
        this.connection.logger.logSchemaBuild(`No migrations are pending`);
        if (!this.queryRunner) yield queryRunner.release();
        return [];
      }
      this.connection.logger.logSchemaBuild(`${executedMigrations.length} migrations are already loaded in the database.`);
      this.connection.logger.logSchemaBuild(`${allMigrations.length} migrations were found in the source code.`);
      if (lastTimeExecutedMigration) this.connection.logger.logSchemaBuild(`${lastTimeExecutedMigration.name} is the last executed migration. It was executed on ${new Date(lastTimeExecutedMigration.timestamp).toString()}.`);
      this.connection.logger.logSchemaBuild(`${pendingMigrations.length} migrations are new migrations must be executed.`);
      if (this.transaction === "all") {
        const migrationsOverridingTransactionMode = pendingMigrations.filter((migration) => !(migration.instance?.transaction === void 0));
        if (migrationsOverridingTransactionMode.length > 0) {
          const error = new ForbiddenTransactionModeOverrideError(migrationsOverridingTransactionMode);
          this.connection.logger.logMigration(`Migrations failed, error: ${error.message}`);
          throw error;
        }
      }
      const txModeDefault = {
        each: true,
        none: false,
        all: false
      }[this.transaction];
      for (const migration of pendingMigrations) {
        if (migration.instance) {
          const instanceTx = migration.instance.transaction;
          if (instanceTx === void 0) {
            migration.transaction = txModeDefault;
          } else {
            migration.transaction = instanceTx;
          }
        }
      }
      let transactionStartedByUs = false;
      if (this.transaction === "all" && !queryRunner.isTransactionActive) {
        yield queryRunner.beforeMigration();
        yield queryRunner.startTransaction();
        transactionStartedByUs = true;
      }
      try {
        for (const migration of pendingMigrations) {
          if (this.fake) {
            yield this.insertExecutedMigration(queryRunner, migration);
            continue;
          }
          if (migration.transaction && !queryRunner.isTransactionActive) {
            yield queryRunner.beforeMigration();
            yield queryRunner.startTransaction();
            transactionStartedByUs = true;
          }
          yield migration.instance.up(queryRunner).catch((error) => {
            this.connection.logger.logMigration(`Migration "${migration.name}" failed, error: ${error?.message}`);
            throw error;
          }).then(() => __async(this, null, function* () {
            yield this.insertExecutedMigration(queryRunner, migration);
            if (migration.transaction && transactionStartedByUs) {
              yield queryRunner.commitTransaction();
              yield queryRunner.afterMigration();
            }
          })).then(() => {
            successMigrations.push(migration);
            this.connection.logger.logSchemaBuild(`Migration ${migration.name} has been ${this.fake ? "(fake)" : ""} executed successfully.`);
          });
        }
        if (this.transaction === "all" && transactionStartedByUs) {
          yield queryRunner.commitTransaction();
          yield queryRunner.afterMigration();
        }
      } catch (err) {
        if (transactionStartedByUs) {
          try {
            yield queryRunner.rollbackTransaction();
          } catch (rollbackError) {
          }
        }
        throw err;
      } finally {
        if (!this.queryRunner) yield queryRunner.release();
      }
      return successMigrations;
    });
  }
  /**
   * Reverts last migration that were run.
   */
  undoLastMigration() {
    return __async(this, null, function* () {
      const queryRunner = this.queryRunner || this.connection.createQueryRunner();
      yield this.createMigrationsTableIfNotExist(queryRunner);
      const schemaBuilder = this.connection.driver.createSchemaBuilder();
      if (InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {
        yield schemaBuilder.createMetadataTableIfNecessary(queryRunner);
      }
      const executedMigrations = yield this.loadExecutedMigrations(queryRunner);
      let lastTimeExecutedMigration = this.getLatestExecutedMigration(executedMigrations);
      if (!lastTimeExecutedMigration) {
        this.connection.logger.logSchemaBuild(`No migrations were found in the database. Nothing to revert!`);
        return;
      }
      const allMigrations = this.getMigrations();
      const migrationToRevert = allMigrations.find((migration) => migration.name === lastTimeExecutedMigration.name);
      if (!migrationToRevert) throw new TypeORMError(`No migration ${lastTimeExecutedMigration.name} was found in the source code. Make sure you have this migration in your codebase and its included in the connection options.`);
      this.connection.logger.logSchemaBuild(`${executedMigrations.length} migrations are already loaded in the database.`);
      this.connection.logger.logSchemaBuild(`${lastTimeExecutedMigration.name} is the last executed migration. It was executed on ${new Date(lastTimeExecutedMigration.timestamp).toString()}.`);
      this.connection.logger.logSchemaBuild(`Now reverting it...`);
      let transactionStartedByUs = false;
      if (this.transaction !== "none" && !queryRunner.isTransactionActive) {
        yield queryRunner.startTransaction();
        transactionStartedByUs = true;
      }
      try {
        if (!this.fake) {
          yield queryRunner.beforeMigration();
          yield migrationToRevert.instance.down(queryRunner);
          yield queryRunner.afterMigration();
        }
        yield this.deleteExecutedMigration(queryRunner, migrationToRevert);
        this.connection.logger.logSchemaBuild(`Migration ${migrationToRevert.name} has been ${this.fake ? "(fake)" : ""} reverted successfully.`);
        if (transactionStartedByUs) yield queryRunner.commitTransaction();
      } catch (err) {
        if (transactionStartedByUs) {
          try {
            yield queryRunner.rollbackTransaction();
          } catch (rollbackError) {
          }
        }
        throw err;
      } finally {
        if (!this.queryRunner) yield queryRunner.release();
      }
    });
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Creates table "migrations" that will store information about executed migrations.
   */
  createMigrationsTableIfNotExist(queryRunner) {
    return __async(this, null, function* () {
      if (this.connection.driver.options.type === "mongodb") {
        return;
      }
      const tableExist = yield queryRunner.hasTable(this.migrationsTable);
      if (!tableExist) {
        yield queryRunner.createTable(new Table({
          database: this.migrationsDatabase,
          schema: this.migrationsSchema,
          name: this.migrationsTable,
          columns: [{
            name: "id",
            type: this.connection.driver.normalizeType({
              type: this.connection.driver.mappedDataTypes.migrationId
            }),
            isGenerated: true,
            generationStrategy: "increment",
            isPrimary: true,
            isNullable: false
          }, {
            name: "timestamp",
            type: this.connection.driver.normalizeType({
              type: this.connection.driver.mappedDataTypes.migrationTimestamp
            }),
            isPrimary: false,
            isNullable: false
          }, {
            name: "name",
            type: this.connection.driver.normalizeType({
              type: this.connection.driver.mappedDataTypes.migrationName
            }),
            isNullable: false
          }]
        }));
      }
    });
  }
  /**
   * Loads all migrations that were executed and saved into the database (sorts by id).
   */
  loadExecutedMigrations(queryRunner) {
    return __async(this, null, function* () {
      if (this.connection.driver.options.type === "mongodb") {
        const mongoRunner = queryRunner;
        return mongoRunner.cursor(this.migrationsTableName, {}).sort({
          _id: -1
        }).toArray();
      } else {
        const migrationsRaw = yield this.connection.manager.createQueryBuilder(queryRunner).select().orderBy(this.connection.driver.escape("id"), "DESC").from(this.migrationsTable, this.migrationsTableName).getRawMany();
        return migrationsRaw.map((migrationRaw) => {
          return new Migration(parseInt(migrationRaw["id"]), parseInt(migrationRaw["timestamp"]), migrationRaw["name"]);
        });
      }
    });
  }
  /**
   * Gets all migrations that setup for this connection.
   */
  getMigrations() {
    const migrations = this.connection.migrations.map((migration) => {
      const migrationClassName = migration.name || migration.constructor.name;
      const migrationTimestamp = parseInt(migrationClassName.substr(-13), 10);
      if (!migrationTimestamp || isNaN(migrationTimestamp)) {
        throw new TypeORMError(`${migrationClassName} migration name is wrong. Migration class name should have a JavaScript timestamp appended.`);
      }
      return new Migration(void 0, migrationTimestamp, migrationClassName, migration);
    });
    this.checkForDuplicateMigrations(migrations);
    return migrations.sort((a, b) => a.timestamp - b.timestamp);
  }
  checkForDuplicateMigrations(migrations) {
    const migrationNames = migrations.map((migration) => migration.name);
    const duplicates = Array.from(new Set(migrationNames.filter((migrationName, index) => migrationNames.indexOf(migrationName) < index)));
    if (duplicates.length > 0) {
      throw Error(`Duplicate migrations: ${duplicates.join(", ")}`);
    }
  }
  /**
   * Finds the latest migration (sorts by timestamp) in the given array of migrations.
   */
  getLatestTimestampMigration(migrations) {
    const sortedMigrations = migrations.map((migration) => migration).sort((a, b) => (a.timestamp - b.timestamp) * -1);
    return sortedMigrations.length > 0 ? sortedMigrations[0] : void 0;
  }
  /**
   * Finds the latest migration in the given array of migrations.
   * PRE: Migration array must be sorted by descending id.
   */
  getLatestExecutedMigration(sortedMigrations) {
    return sortedMigrations.length > 0 ? sortedMigrations[0] : void 0;
  }
  /**
   * Inserts new executed migration's data into migrations table.
   */
  insertExecutedMigration(queryRunner, migration) {
    return __async(this, null, function* () {
      const values = {};
      if (this.connection.driver.options.type === "mssql") {
        values["timestamp"] = new MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({
          type: this.connection.driver.mappedDataTypes.migrationTimestamp
        }));
        values["name"] = new MssqlParameter(migration.name, this.connection.driver.normalizeType({
          type: this.connection.driver.mappedDataTypes.migrationName
        }));
      } else {
        values["timestamp"] = migration.timestamp;
        values["name"] = migration.name;
      }
      if (this.connection.driver.options.type === "mongodb") {
        const mongoRunner = queryRunner;
        yield mongoRunner.databaseConnection.db(this.connection.driver.database).collection(this.migrationsTableName).insertOne(values);
      } else {
        const qb = queryRunner.manager.createQueryBuilder();
        yield qb.insert().into(this.migrationsTable).values(values).execute();
      }
    });
  }
  /**
   * Delete previously executed migration's data from the migrations table.
   */
  deleteExecutedMigration(queryRunner, migration) {
    return __async(this, null, function* () {
      const conditions = {};
      if (this.connection.driver.options.type === "mssql") {
        conditions["timestamp"] = new MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({
          type: this.connection.driver.mappedDataTypes.migrationTimestamp
        }));
        conditions["name"] = new MssqlParameter(migration.name, this.connection.driver.normalizeType({
          type: this.connection.driver.mappedDataTypes.migrationName
        }));
      } else {
        conditions["timestamp"] = migration.timestamp;
        conditions["name"] = migration.name;
      }
      if (this.connection.driver.options.type === "mongodb") {
        const mongoRunner = queryRunner;
        yield mongoRunner.databaseConnection.db(this.connection.driver.database).collection(this.migrationsTableName).deleteOne(conditions);
      } else {
        const qb = queryRunner.manager.createQueryBuilder();
        yield qb.delete().from(this.migrationsTable).where(`${qb.escape("timestamp")} = :timestamp`).andWhere(`${qb.escape("name")} = :name`).setParameters(conditions).execute();
      }
    });
  }
  withQueryRunner(callback) {
    return __async(this, null, function* () {
      const queryRunner = this.queryRunner || this.connection.createQueryRunner();
      try {
        return yield callback(queryRunner);
      } finally {
        if (!this.queryRunner) {
          yield queryRunner.release();
        }
      }
    });
  }
};

// ../node_modules/typeorm/browser/util/DepGraph.js
function createDFS(edges, leavesOnly, result) {
  let currentPath = [];
  let visited = {};
  return function DFS(currentNode) {
    visited[currentNode] = true;
    currentPath.push(currentNode);
    edges[currentNode].forEach(function(node) {
      if (!visited[node]) {
        DFS(node);
      } else if (currentPath.indexOf(node) >= 0) {
        currentPath.push(node);
        throw new TypeORMError(`Dependency Cycle Found: ${currentPath.join(" -> ")}`);
      }
    });
    currentPath.pop();
    if ((!leavesOnly || edges[currentNode].length === 0) && result.indexOf(currentNode) === -1) {
      result.push(currentNode);
    }
  };
}
var DepGraph = class {
  constructor() {
    this.nodes = {};
    this.outgoingEdges = {};
    this.incomingEdges = {};
  }
  /**
   * Add a node to the dependency graph. If a node already exists, this method will do nothing.
   */
  addNode(node, data) {
    if (!this.hasNode(node)) {
      if (arguments.length === 2) {
        this.nodes[node] = data;
      } else {
        this.nodes[node] = node;
      }
      this.outgoingEdges[node] = [];
      this.incomingEdges[node] = [];
    }
  }
  /**
   * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.
   */
  removeNode(node) {
    if (this.hasNode(node)) {
      delete this.nodes[node];
      delete this.outgoingEdges[node];
      delete this.incomingEdges[node];
      [this.incomingEdges, this.outgoingEdges].forEach(function(edgeList) {
        Object.keys(edgeList).forEach(function(key) {
          const idx = edgeList[key].indexOf(node);
          if (idx >= 0) {
            edgeList[key].splice(idx, 1);
          }
        });
      });
    }
  }
  /**
   * Check if a node exists in the graph
   */
  hasNode(node) {
    return this.nodes.hasOwnProperty(node);
  }
  /**
   * Get the data associated with a node name
   */
  getNodeData(node) {
    if (this.hasNode(node)) {
      return this.nodes[node];
    } else {
      throw new TypeORMError(`Node does not exist: ${node}`);
    }
  }
  /**
   * Set the associated data for a given node name. If the node does not exist, this method will throw an error
   */
  setNodeData(node, data) {
    if (this.hasNode(node)) {
      this.nodes[node] = data;
    } else {
      throw new TypeORMError(`Node does not exist: ${node}`);
    }
  }
  /**
   * Add a dependency between two nodes. If either of the nodes does not exist,
   * an Error will be thrown.
   */
  addDependency(from, to) {
    if (!this.hasNode(from)) {
      throw new TypeORMError(`Node does not exist: ${from}`);
    }
    if (!this.hasNode(to)) {
      throw new TypeORMError(`Node does not exist: ${to}`);
    }
    if (this.outgoingEdges[from].indexOf(to) === -1) {
      this.outgoingEdges[from].push(to);
    }
    if (this.incomingEdges[to].indexOf(from) === -1) {
      this.incomingEdges[to].push(from);
    }
    return true;
  }
  /**
   * Remove a dependency between two nodes.
   */
  removeDependency(from, to) {
    let idx;
    if (this.hasNode(from)) {
      idx = this.outgoingEdges[from].indexOf(to);
      if (idx >= 0) {
        this.outgoingEdges[from].splice(idx, 1);
      }
    }
    if (this.hasNode(to)) {
      idx = this.incomingEdges[to].indexOf(from);
      if (idx >= 0) {
        this.incomingEdges[to].splice(idx, 1);
      }
    }
  }
  /**
   * Get an array containing the nodes that the specified node depends on (transitively).
   *
   * Throws an Error if the graph has a cycle, or the specified node does not exist.
   *
   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned
   * in the array.
   */
  dependenciesOf(node, leavesOnly) {
    if (this.hasNode(node)) {
      let result = [];
      let DFS = createDFS(this.outgoingEdges, leavesOnly, result);
      DFS(node);
      let idx = result.indexOf(node);
      if (idx >= 0) {
        result.splice(idx, 1);
      }
      return result;
    } else {
      throw new TypeORMError(`Node does not exist: ${node}`);
    }
  }
  /**
   * get an array containing the nodes that depend on the specified node (transitively).
   *
   * Throws an Error if the graph has a cycle, or the specified node does not exist.
   *
   * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.
   */
  dependantsOf(node, leavesOnly) {
    if (this.hasNode(node)) {
      let result = [];
      let DFS = createDFS(this.incomingEdges, leavesOnly, result);
      DFS(node);
      let idx = result.indexOf(node);
      if (idx >= 0) {
        result.splice(idx, 1);
      }
      return result;
    } else {
      throw new TypeORMError(`Node does not exist: ${node}`);
    }
  }
  /**
   * Construct the overall processing order for the dependency graph.
   *
   * Throws an Error if the graph has a cycle.
   *
   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.
   */
  overallOrder(leavesOnly) {
    let self2 = this;
    let result = [];
    let keys = Object.keys(this.nodes);
    if (keys.length === 0) {
      return result;
    } else {
      let CycleDFS = createDFS(this.outgoingEdges, false, []);
      keys.forEach(function(n) {
        CycleDFS(n);
      });
      let DFS = createDFS(this.outgoingEdges, leavesOnly, result);
      keys.filter(function(node) {
        return self2.incomingEdges[node].length === 0;
      }).forEach(function(n) {
        DFS(n);
      });
      return result;
    }
  }
};

// ../node_modules/typeorm/browser/metadata-builder/EntityMetadataValidator.js
var EntityMetadataValidator = class {
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Validates all given entity metadatas.
   */
  validateMany(entityMetadatas, driver) {
    entityMetadatas.forEach((entityMetadata) => this.validate(entityMetadata, entityMetadatas, driver));
    this.validateDependencies(entityMetadatas);
    this.validateEagerRelations(entityMetadatas);
  }
  /**
   * Validates given entity metadata.
   */
  validate(entityMetadata, allEntityMetadatas, driver) {
    if (!entityMetadata.primaryColumns.length && !entityMetadata.isJunction) throw new MissingPrimaryColumnError(entityMetadata);
    if (entityMetadata.primaryColumns.length > 1) {
      const areConstraintNamesEqual = entityMetadata.primaryColumns.every((columnMetadata, i, columnMetadatas) => columnMetadata.primaryKeyConstraintName === columnMetadatas[0].primaryKeyConstraintName);
      if (!areConstraintNamesEqual) {
        throw new TypeORMError(`Entity ${entityMetadata.name} has multiple primary columns with different constraint names. Constraint names should be the equal.`);
      }
    }
    if (entityMetadata.inheritancePattern === "STI" || entityMetadata.tableType === "entity-child") {
      if (!entityMetadata.discriminatorColumn) throw new TypeORMError(`Entity ${entityMetadata.name} using single-table inheritance, it should also have a discriminator column. Did you forget to put discriminator column options?`);
      if (typeof entityMetadata.discriminatorValue === "undefined") throw new TypeORMError(`Entity ${entityMetadata.name} has an undefined discriminator value. Discriminator value should be defined.`);
      const sameDiscriminatorValueEntityMetadata = allEntityMetadatas.find((metadata) => {
        return metadata !== entityMetadata && (metadata.inheritancePattern === "STI" || metadata.tableType === "entity-child") && metadata.tableName === entityMetadata.tableName && metadata.discriminatorValue === entityMetadata.discriminatorValue && metadata.inheritanceTree.some((parent) => entityMetadata.inheritanceTree.indexOf(parent) !== -1);
      });
      if (sameDiscriminatorValueEntityMetadata) throw new TypeORMError(`Entities ${entityMetadata.name} and ${sameDiscriminatorValueEntityMetadata.name} have the same discriminator values. Make sure they are different while using the @ChildEntity decorator.`);
    }
    entityMetadata.relationCounts.forEach((relationCount) => {
      if (relationCount.relation.isManyToOne || relationCount.relation.isOneToOne) throw new TypeORMError(`Relation count can not be implemented on ManyToOne or OneToOne relations.`);
    });
    if (!(driver.options.type === "mongodb")) {
      entityMetadata.columns.filter((column) => !column.isVirtualProperty).forEach((column) => {
        const normalizedColumn = driver.normalizeType(column);
        if (driver.supportedDataTypes.indexOf(normalizedColumn) === -1) throw new DataTypeNotSupportedError(column, normalizedColumn, driver.options.type);
        if (column.length && driver.withLengthColumnTypes.indexOf(normalizedColumn) === -1) throw new TypeORMError(`Column ${column.propertyName} of Entity ${entityMetadata.name} does not support length property.`);
        if (column.type === "enum" && !column.enum && !column.enumName) throw new TypeORMError(`Column "${column.propertyName}" of Entity "${entityMetadata.name}" is defined as enum, but missing "enum" or "enumName" properties.`);
      });
    }
    if (DriverUtils.isMySQLFamily(driver) || driver.options.type === "aurora-mysql") {
      const generatedColumns = entityMetadata.columns.filter((column) => column.isGenerated && column.generationStrategy !== "uuid");
      if (generatedColumns.length > 1) throw new TypeORMError(`Error in ${entityMetadata.name} entity. There can be only one auto-increment column in MySql table.`);
    }
    if (DriverUtils.isMySQLFamily(driver)) {
      const metadatasWithDatabase = allEntityMetadatas.filter((metadata) => metadata.database);
      if (metadatasWithDatabase.length === 0 && !driver.database) throw new NoConnectionOptionError("database");
    }
    if (driver.options.type === "mssql") {
      const charsetColumns = entityMetadata.columns.filter((column) => column.charset);
      if (charsetColumns.length > 1) throw new TypeORMError(`Character set specifying is not supported in Sql Server`);
    }
    if (driver.options.type === "postgres") {
      const virtualColumn = entityMetadata.columns.find((column) => column.asExpression && (!column.generatedType || column.generatedType === "VIRTUAL"));
      if (virtualColumn) throw new TypeORMError(`Column "${virtualColumn.propertyName}" of Entity "${entityMetadata.name}" is defined as VIRTUAL, but Postgres supports only STORED generated columns.`);
    }
    const entityInstance = entityMetadata.create(void 0, {
      fromDeserializer: true
    });
    entityMetadata.relations.forEach((relation) => {
      if (relation.isManyToMany || relation.isOneToMany) {
        if (relation.persistenceEnabled === false) return;
        const relationInitializedValue = relation.getEntityValue(entityInstance);
        if (Array.isArray(relationInitializedValue)) throw new InitializedRelationError(relation);
      }
    });
    entityMetadata.relations.forEach((relation) => {
      if (driver.supportedOnDeleteTypes && relation.onDelete && !driver.supportedOnDeleteTypes.includes(relation.onDelete)) {
        throw new TypeORMError(`OnDeleteType "${relation.onDelete}" is not supported for ${driver.options.type}!`);
      }
      if (driver.supportedOnUpdateTypes && relation.onUpdate && !driver.supportedOnUpdateTypes.includes(relation.onUpdate)) {
        throw new TypeORMError(`OnUpdateType "${relation.onUpdate}" is not valid for ${driver.options.type}!`);
      }
    });
    entityMetadata.relations.forEach((relation) => {
      const isCircularCascadeRemove = relation.isCascadeRemove && relation.inverseRelation && relation.inverseRelation.isCascadeRemove;
      if (isCircularCascadeRemove) throw new TypeORMError(`Relation ${entityMetadata.name}#${relation.propertyName} and ${relation.inverseRelation.entityMetadata.name}#${relation.inverseRelation.propertyName} both has cascade remove set. This may lead to unexpected circular removals. Please set cascade remove only from one side of relationship.`);
    });
    entityMetadata.eagerRelations.forEach((relation) => {
    });
  }
  /**
   * Validates dependencies of the entity metadatas.
   */
  validateDependencies(entityMetadatas) {
    const graph = new DepGraph();
    entityMetadatas.forEach((entityMetadata) => {
      graph.addNode(entityMetadata.name);
    });
    entityMetadatas.forEach((entityMetadata) => {
      entityMetadata.relationsWithJoinColumns.filter((relation) => !relation.isNullable).forEach((relation) => {
        graph.addDependency(entityMetadata.name, relation.inverseEntityMetadata.name);
      });
    });
    try {
      graph.overallOrder();
    } catch (err) {
      throw new CircularRelationsError(err.toString().replace("Error: Dependency Cycle Found: ", ""));
    }
  }
  /**
   * Validates eager relations to prevent circular dependency in them.
   */
  validateEagerRelations(entityMetadatas) {
    entityMetadatas.forEach((entityMetadata) => {
      entityMetadata.eagerRelations.forEach((relation) => {
        if (relation.inverseRelation && relation.inverseRelation.isEager) throw new TypeORMError(`Circular eager relations are disallowed. ${entityMetadata.targetName}#${relation.propertyPath} contains "eager: true", and its inverse side ${relation.inverseEntityMetadata.targetName}#${relation.inverseRelation.propertyPath} contains "eager: true" as well. Remove "eager: true" from one side of the relation.`);
      });
    });
  }
};

// ../node_modules/typeorm/browser/platform/BrowserDisabledDriversDummy.js
var MongoDriver = class {
};
var MongoQueryRunner = class {
};
var MongoEntityManager = class {
};
var MongoRepository = class {
};
var PostgresDriver = class {
};
var AuroraMysqlDriver = class {
};
var CockroachDriver = class {
};
var AuroraPostgresDriver = class {
};
var SqlServerDriver = class {
};
var SapDriver = class {
};
var MysqlDriver = class {
};
var OracleDriver = class {
};
var SqliteDriver = class {
};
var BetterSqlite3Driver = class {
};

// ../node_modules/typeorm/browser/util/TreeRepositoryUtils.js
var TreeRepositoryUtils = class _TreeRepositoryUtils {
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  static createRelationMaps(manager, metadata, alias, rawResults) {
    return rawResults.map((rawResult) => {
      const joinColumn = metadata.treeParentRelation.joinColumns[0];
      const referencedColumn = joinColumn.referencedColumn ?? metadata.primaryColumns[0];
      const joinColumnName = joinColumn.givenDatabaseName || joinColumn.databaseName;
      const referencedColumnName = referencedColumn.givenDatabaseName || referencedColumn.databaseName;
      const id = rawResult[alias + "_" + referencedColumnName];
      const parentId = rawResult[alias + "_" + joinColumnName];
      return {
        id: manager.connection.driver.prepareHydratedValue(id, referencedColumn),
        parentId: manager.connection.driver.prepareHydratedValue(parentId, joinColumn)
      };
    });
  }
  static buildChildrenEntityTree(metadata, entity, entities, relationMaps, options) {
    const childProperty = metadata.treeChildrenRelation.propertyName;
    if (options.depth === 0) {
      entity[childProperty] = [];
      return;
    }
    const joinColumn = metadata.treeParentRelation.joinColumns[0];
    const referencedColumn = joinColumn.referencedColumn ?? metadata.primaryColumns[0];
    const parentEntityId = referencedColumn.getEntityValue(entity);
    const childRelationMaps = relationMaps.filter((relationMap) => relationMap.parentId === parentEntityId);
    const childIds = new Set(childRelationMaps.map((relationMap) => relationMap.id));
    entity[childProperty] = entities.filter((entity2) => childIds.has(referencedColumn.getEntityValue(entity2)));
    entity[childProperty].forEach((childEntity) => {
      _TreeRepositoryUtils.buildChildrenEntityTree(metadata, childEntity, entities, relationMaps, __spreadProps(__spreadValues({}, options), {
        depth: options.depth - 1
      }));
    });
  }
  static buildParentEntityTree(metadata, entity, entities, relationMaps) {
    const parentProperty = metadata.treeParentRelation.propertyName;
    const joinColumn = metadata.treeParentRelation.joinColumns[0];
    const referencedColumn = joinColumn.referencedColumn ?? metadata.primaryColumns[0];
    const entityId = referencedColumn.getEntityValue(entity);
    const parentRelationMap = relationMaps.find((relationMap) => relationMap.id === entityId);
    const parentEntity = entities.find((entity2) => {
      if (!parentRelationMap) return false;
      return referencedColumn.getEntityValue(entity2) === parentRelationMap.parentId;
    });
    if (parentEntity) {
      entity[parentProperty] = parentEntity;
      _TreeRepositoryUtils.buildParentEntityTree(metadata, entity[parentProperty], entities, relationMaps);
    }
  }
};

// ../node_modules/typeorm/browser/repository/Repository.js
var Repository = class {
  // -------------------------------------------------------------------------
  // Accessors
  // -------------------------------------------------------------------------
  /**
   * Entity metadata of the entity current repository manages.
   */
  get metadata() {
    return this.manager.connection.getMetadata(this.target);
  }
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(target, manager, queryRunner) {
    this.target = target;
    this.manager = manager;
    this.queryRunner = queryRunner;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates a new query builder that can be used to build a SQL query.
   */
  createQueryBuilder(alias, queryRunner) {
    return this.manager.createQueryBuilder(this.metadata.target, alias || this.metadata.targetName, queryRunner || this.queryRunner);
  }
  /**
   * Checks if entity has an id.
   * If entity composite compose ids, it will check them all.
   */
  hasId(entity) {
    return this.manager.hasId(this.metadata.target, entity);
  }
  /**
   * Gets entity mixed id.
   */
  getId(entity) {
    return this.manager.getId(this.metadata.target, entity);
  }
  /**
   * Creates a new entity instance or instances.
   * Can copy properties from the given object into new entities.
   */
  create(plainEntityLikeOrPlainEntityLikes) {
    return this.manager.create(this.metadata.target, plainEntityLikeOrPlainEntityLikes);
  }
  /**
   * Merges multiple entities (or entity-like objects) into a given entity.
   */
  merge(mergeIntoEntity, ...entityLikes) {
    return this.manager.merge(this.metadata.target, mergeIntoEntity, ...entityLikes);
  }
  /**
   * Creates a new entity from the given plain javascript object. If entity already exist in the database, then
   * it loads it (and everything related to it), replaces all values with the new ones from the given object
   * and returns this new entity. This new entity is actually a loaded from the db entity with all properties
   * replaced from the new object.
   *
   * Note that given entity-like object must have an entity id / primary key to find entity by.
   * Returns undefined if entity with given id was not found.
   */
  preload(entityLike) {
    return this.manager.preload(this.metadata.target, entityLike);
  }
  /**
   * Saves one or many given entities.
   */
  save(entityOrEntities, options) {
    return this.manager.save(this.metadata.target, entityOrEntities, options);
  }
  /**
   * Removes one or many given entities.
   */
  remove(entityOrEntities, options) {
    return this.manager.remove(this.metadata.target, entityOrEntities, options);
  }
  /**
   * Records the delete date of one or many given entities.
   */
  softRemove(entityOrEntities, options) {
    return this.manager.softRemove(this.metadata.target, entityOrEntities, options);
  }
  /**
   * Recovers one or many given entities.
   */
  recover(entityOrEntities, options) {
    return this.manager.recover(this.metadata.target, entityOrEntities, options);
  }
  /**
   * Inserts a given entity into the database.
   * Unlike save method executes a primitive operation without cascades, relations and other operations included.
   * Executes fast and efficient INSERT query.
   * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.
   */
  insert(entity) {
    return this.manager.insert(this.metadata.target, entity);
  }
  /**
   * Updates entity partially. Entity can be found by a given conditions.
   * Unlike save method executes a primitive operation without cascades, relations and other operations included.
   * Executes fast and efficient UPDATE query.
   * Does not check if entity exist in the database.
   */
  update(criteria, partialEntity) {
    return this.manager.update(this.metadata.target, criteria, partialEntity);
  }
  /**
   * Inserts a given entity into the database, unless a unique constraint conflicts then updates the entity
   * Unlike save method executes a primitive operation without cascades, relations and other operations included.
   * Executes fast and efficient INSERT ... ON CONFLICT DO UPDATE/ON DUPLICATE KEY UPDATE query.
   */
  upsert(entityOrEntities, conflictPathsOrOptions) {
    return this.manager.upsert(this.metadata.target, entityOrEntities, conflictPathsOrOptions);
  }
  /**
   * Deletes entities by a given criteria.
   * Unlike save method executes a primitive operation without cascades, relations and other operations included.
   * Executes fast and efficient DELETE query.
   * Does not check if entity exist in the database.
   */
  delete(criteria) {
    return this.manager.delete(this.metadata.target, criteria);
  }
  /**
   * Records the delete date of entities by a given criteria.
   * Unlike save method executes a primitive operation without cascades, relations and other operations included.
   * Executes fast and efficient SOFT-DELETE query.
   * Does not check if entity exist in the database.
   */
  softDelete(criteria) {
    return this.manager.softDelete(this.metadata.target, criteria);
  }
  /**
   * Restores entities by a given criteria.
   * Unlike save method executes a primitive operation without cascades, relations and other operations included.
   * Executes fast and efficient SOFT-DELETE query.
   * Does not check if entity exist in the database.
   */
  restore(criteria) {
    return this.manager.restore(this.metadata.target, criteria);
  }
  /**
   * Checks whether any entity exists that matches the given options.
   *
   * @deprecated use `exists` method instead, for example:
   *
   * .exists()
   */
  exist(options) {
    return this.manager.exists(this.metadata.target, options);
  }
  /**
   * Checks whether any entity exists that matches the given options.
   */
  exists(options) {
    return this.manager.exists(this.metadata.target, options);
  }
  /**
   * Checks whether any entity exists that matches the given conditions.
   */
  existsBy(where) {
    return this.manager.existsBy(this.metadata.target, where);
  }
  /**
   * Counts entities that match given options.
   * Useful for pagination.
   */
  count(options) {
    return this.manager.count(this.metadata.target, options);
  }
  /**
   * Counts entities that match given conditions.
   * Useful for pagination.
   */
  countBy(where) {
    return this.manager.countBy(this.metadata.target, where);
  }
  /**
   * Return the SUM of a column
   */
  sum(columnName, where) {
    return this.manager.sum(this.metadata.target, columnName, where);
  }
  /**
   * Return the AVG of a column
   */
  average(columnName, where) {
    return this.manager.average(this.metadata.target, columnName, where);
  }
  /**
   * Return the MIN of a column
   */
  minimum(columnName, where) {
    return this.manager.minimum(this.metadata.target, columnName, where);
  }
  /**
   * Return the MAX of a column
   */
  maximum(columnName, where) {
    return this.manager.maximum(this.metadata.target, columnName, where);
  }
  /**
   * Finds entities that match given find options.
   */
  find(options) {
    return __async(this, null, function* () {
      return this.manager.find(this.metadata.target, options);
    });
  }
  /**
   * Finds entities that match given find options.
   */
  findBy(where) {
    return __async(this, null, function* () {
      return this.manager.findBy(this.metadata.target, where);
    });
  }
  /**
   * Finds entities that match given find options.
   * Also counts all entities that match given conditions,
   * but ignores pagination settings (from and take options).
   */
  findAndCount(options) {
    return this.manager.findAndCount(this.metadata.target, options);
  }
  /**
   * Finds entities that match given WHERE conditions.
   * Also counts all entities that match given conditions,
   * but ignores pagination settings (from and take options).
   */
  findAndCountBy(where) {
    return this.manager.findAndCountBy(this.metadata.target, where);
  }
  /**
   * Finds entities with ids.
   * Optionally find options or conditions can be applied.
   *
   * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:
   *
   * .findBy({
   *     id: In([1, 2, 3])
   * })
   */
  findByIds(ids) {
    return __async(this, null, function* () {
      return this.manager.findByIds(this.metadata.target, ids);
    });
  }
  /**
   * Finds first entity by a given find options.
   * If entity was not found in the database - returns null.
   */
  findOne(options) {
    return __async(this, null, function* () {
      return this.manager.findOne(this.metadata.target, options);
    });
  }
  /**
   * Finds first entity that matches given where condition.
   * If entity was not found in the database - returns null.
   */
  findOneBy(where) {
    return __async(this, null, function* () {
      return this.manager.findOneBy(this.metadata.target, where);
    });
  }
  /**
   * Finds first entity that matches given id.
   * If entity was not found in the database - returns null.
   *
   * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:
   *
   * .findOneBy({
   *     id: 1 // where "id" is your primary column name
   * })
   */
  findOneById(id) {
    return __async(this, null, function* () {
      return this.manager.findOneById(this.metadata.target, id);
    });
  }
  /**
   * Finds first entity by a given find options.
   * If entity was not found in the database - rejects with error.
   */
  findOneOrFail(options) {
    return __async(this, null, function* () {
      return this.manager.findOneOrFail(this.metadata.target, options);
    });
  }
  /**
   * Finds first entity that matches given where condition.
   * If entity was not found in the database - rejects with error.
   */
  findOneByOrFail(where) {
    return __async(this, null, function* () {
      return this.manager.findOneByOrFail(this.metadata.target, where);
    });
  }
  /**
   * Executes a raw SQL query and returns a raw database results.
   * Raw query execution is supported only by relational databases (MongoDB is not supported).
   *
   * @see [Official docs](https://typeorm.io/repository-api) for examples.
   */
  query(query, parameters) {
    return this.manager.query(query, parameters);
  }
  /**
   * Clears all the data from the given table/collection (truncates/drops it).
   *
   * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.
   * @see https://stackoverflow.com/a/5972738/925151
   */
  clear() {
    return this.manager.clear(this.metadata.target);
  }
  /**
   * Increments some column by provided value of the entities matched given conditions.
   */
  increment(conditions, propertyPath, value) {
    return this.manager.increment(this.metadata.target, conditions, propertyPath, value);
  }
  /**
   * Decrements some column by provided value of the entities matched given conditions.
   */
  decrement(conditions, propertyPath, value) {
    return this.manager.decrement(this.metadata.target, conditions, propertyPath, value);
  }
  /**
   * Extends repository with provided functions.
   */
  extend(customs) {
    const thisRepo = this.constructor;
    const {
      target,
      manager,
      queryRunner
    } = this;
    const ChildClass = class extends thisRepo {
      constructor(target2, manager2, queryRunner2) {
        super(target2, manager2, queryRunner2);
      }
    };
    for (const custom in customs) ChildClass.prototype[custom] = customs[custom];
    return new ChildClass(target, manager, queryRunner);
  }
};

// ../node_modules/typeorm/browser/repository/TreeRepository.js
var TreeRepository = class extends Repository {
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Gets complete trees for all roots in the table.
   */
  findTrees(options) {
    return __async(this, null, function* () {
      const roots = yield this.findRoots(options);
      yield Promise.all(roots.map((root) => this.findDescendantsTree(root, options)));
      return roots;
    });
  }
  /**
   * Roots are entities that have no ancestors. Finds them all.
   */
  findRoots(options) {
    const escapeAlias = (alias) => this.manager.connection.driver.escape(alias);
    const escapeColumn = (column) => this.manager.connection.driver.escape(column);
    const joinColumn = this.metadata.treeParentRelation.joinColumns[0];
    const parentPropertyName = joinColumn.givenDatabaseName || joinColumn.databaseName;
    const qb = this.createQueryBuilder("treeEntity");
    FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);
    return qb.where(`${escapeAlias("treeEntity")}.${escapeColumn(parentPropertyName)} IS NULL`).getMany();
  }
  /**
   * Gets all children (descendants) of the given entity. Returns them all in a flat array.
   */
  findDescendants(entity, options) {
    const qb = this.createDescendantsQueryBuilder("treeEntity", "treeClosure", entity);
    FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);
    return qb.getMany();
  }
  /**
   * Gets all children (descendants) of the given entity. Returns them in a tree - nested into each other.
   */
  findDescendantsTree(entity, options) {
    return __async(this, null, function* () {
      const qb = this.createDescendantsQueryBuilder("treeEntity", "treeClosure", entity);
      FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);
      const entities = yield qb.getRawAndEntities();
      const relationMaps = TreeRepositoryUtils.createRelationMaps(this.manager, this.metadata, "treeEntity", entities.raw);
      TreeRepositoryUtils.buildChildrenEntityTree(this.metadata, entity, entities.entities, relationMaps, __spreadValues({
        depth: -1
      }, options));
      return entity;
    });
  }
  /**
   * Gets number of descendants of the entity.
   */
  countDescendants(entity) {
    return this.createDescendantsQueryBuilder("treeEntity", "treeClosure", entity).getCount();
  }
  /**
   * Creates a query builder used to get descendants of the entities in a tree.
   */
  createDescendantsQueryBuilder(alias, closureTableAlias, entity) {
    const escape = (alias2) => this.manager.connection.driver.escape(alias2);
    if (this.metadata.treeType === "closure-table") {
      const joinCondition = this.metadata.closureJunctionTable.descendantColumns.map((column) => {
        return escape(closureTableAlias) + "." + escape(column.propertyPath) + " = " + escape(alias) + "." + escape(column.referencedColumn.propertyPath);
      }).join(" AND ");
      const parameters = {};
      const whereCondition = this.metadata.closureJunctionTable.ancestorColumns.map((column) => {
        parameters[column.referencedColumn.propertyName] = column.referencedColumn.getEntityValue(entity);
        return escape(closureTableAlias) + "." + escape(column.propertyPath) + " = :" + column.referencedColumn.propertyName;
      }).join(" AND ");
      return this.createQueryBuilder(alias).innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition).where(whereCondition).setParameters(parameters);
    } else if (this.metadata.treeType === "nested-set") {
      const whereCondition = alias + "." + this.metadata.nestedSetLeftColumn.propertyPath + " BETWEEN joined." + this.metadata.nestedSetLeftColumn.propertyPath + " AND joined." + this.metadata.nestedSetRightColumn.propertyPath;
      const parameters = {};
      const joinCondition = this.metadata.treeParentRelation.joinColumns.map((joinColumn) => {
        const parameterName = joinColumn.referencedColumn.propertyPath.replace(".", "_");
        parameters[parameterName] = joinColumn.referencedColumn.getEntityValue(entity);
        return "joined." + joinColumn.referencedColumn.propertyPath + " = :" + parameterName;
      }).join(" AND ");
      return this.createQueryBuilder(alias).innerJoin(this.metadata.targetName, "joined", whereCondition).where(joinCondition, parameters);
    } else if (this.metadata.treeType === "materialized-path") {
      return this.createQueryBuilder(alias).where((qb) => {
        const subQuery = qb.subQuery().select(`${this.metadata.targetName}.${this.metadata.materializedPathColumn.propertyPath}`, "path").from(this.metadata.target, this.metadata.targetName).whereInIds(this.metadata.getEntityIdMap(entity));
        if (DriverUtils.isSQLiteFamily(this.manager.connection.driver)) {
          return `${alias}.${this.metadata.materializedPathColumn.propertyPath} LIKE ${subQuery.getQuery()} || '%'`;
        } else {
          return `${alias}.${this.metadata.materializedPathColumn.propertyPath} LIKE NULLIF(CONCAT(${subQuery.getQuery()}, '%'), '%')`;
        }
      });
    }
    throw new TypeORMError(`Supported only in tree entities`);
  }
  /**
   * Gets all parents (ancestors) of the given entity. Returns them all in a flat array.
   */
  findAncestors(entity, options) {
    const qb = this.createAncestorsQueryBuilder("treeEntity", "treeClosure", entity);
    FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);
    return qb.getMany();
  }
  /**
   * Gets all parents (ancestors) of the given entity. Returns them in a tree - nested into each other.
   */
  findAncestorsTree(entity, options) {
    return __async(this, null, function* () {
      const qb = this.createAncestorsQueryBuilder("treeEntity", "treeClosure", entity);
      FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);
      const entities = yield qb.getRawAndEntities();
      const relationMaps = TreeRepositoryUtils.createRelationMaps(this.manager, this.metadata, "treeEntity", entities.raw);
      TreeRepositoryUtils.buildParentEntityTree(this.metadata, entity, entities.entities, relationMaps);
      return entity;
    });
  }
  /**
   * Gets number of ancestors of the entity.
   */
  countAncestors(entity) {
    return this.createAncestorsQueryBuilder("treeEntity", "treeClosure", entity).getCount();
  }
  /**
   * Creates a query builder used to get ancestors of the entities in the tree.
   */
  createAncestorsQueryBuilder(alias, closureTableAlias, entity) {
    if (this.metadata.treeType === "closure-table") {
      const joinCondition = this.metadata.closureJunctionTable.ancestorColumns.map((column) => {
        return closureTableAlias + "." + column.propertyPath + " = " + alias + "." + column.referencedColumn.propertyPath;
      }).join(" AND ");
      const parameters = {};
      const whereCondition = this.metadata.closureJunctionTable.descendantColumns.map((column) => {
        parameters[column.referencedColumn.propertyName] = column.referencedColumn.getEntityValue(entity);
        return closureTableAlias + "." + column.propertyPath + " = :" + column.referencedColumn.propertyName;
      }).join(" AND ");
      return this.createQueryBuilder(alias).innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition).where(whereCondition).setParameters(parameters);
    } else if (this.metadata.treeType === "nested-set") {
      const joinCondition = "joined." + this.metadata.nestedSetLeftColumn.propertyPath + " BETWEEN " + alias + "." + this.metadata.nestedSetLeftColumn.propertyPath + " AND " + alias + "." + this.metadata.nestedSetRightColumn.propertyPath;
      const parameters = {};
      const whereCondition = this.metadata.treeParentRelation.joinColumns.map((joinColumn) => {
        const parameterName = joinColumn.referencedColumn.propertyPath.replace(".", "_");
        parameters[parameterName] = joinColumn.referencedColumn.getEntityValue(entity);
        return "joined." + joinColumn.referencedColumn.propertyPath + " = :" + parameterName;
      }).join(" AND ");
      return this.createQueryBuilder(alias).innerJoin(this.metadata.targetName, "joined", joinCondition).where(whereCondition, parameters);
    } else if (this.metadata.treeType === "materialized-path") {
      return this.createQueryBuilder(alias).where((qb) => {
        const subQuery = qb.subQuery().select(`${this.metadata.targetName}.${this.metadata.materializedPathColumn.propertyPath}`, "path").from(this.metadata.target, this.metadata.targetName).whereInIds(this.metadata.getEntityIdMap(entity));
        if (DriverUtils.isSQLiteFamily(this.manager.connection.driver)) {
          return `${subQuery.getQuery()} LIKE ${alias}.${this.metadata.materializedPathColumn.propertyPath} || '%'`;
        } else {
          return `${subQuery.getQuery()} LIKE CONCAT(${alias}.${this.metadata.materializedPathColumn.propertyPath}, '%')`;
        }
      });
    }
    throw new TypeORMError(`Supported only in tree entities`);
  }
};

// ../node_modules/typeorm/browser/query-builder/transformer/PlainObjectToNewEntityTransformer.js
var PlainObjectToNewEntityTransformer = class {
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  transform(newEntity, object, metadata, getLazyRelationsPromiseValue = false) {
    this.groupAndTransform(newEntity, object, metadata, getLazyRelationsPromiseValue);
    return newEntity;
  }
  // -------------------------------------------------------------------------
  // Private Methods
  // -------------------------------------------------------------------------
  /**
   * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated
   * we need to group our result and we must have some unique id (primary key in our case)
   */
  groupAndTransform(entity, object, metadata, getLazyRelationsPromiseValue = false) {
    metadata.nonVirtualColumns.forEach((column) => {
      const objectColumnValue = column.getEntityValue(object);
      if (objectColumnValue !== void 0) column.setEntityValue(entity, objectColumnValue);
    });
    if (metadata.relations.length) {
      metadata.relations.forEach((relation) => {
        let entityRelatedValue = relation.getEntityValue(entity);
        const objectRelatedValue = relation.getEntityValue(object, getLazyRelationsPromiseValue);
        if (objectRelatedValue === void 0) return;
        if (relation.isOneToMany || relation.isManyToMany) {
          if (!Array.isArray(objectRelatedValue)) return;
          if (!entityRelatedValue) {
            entityRelatedValue = [];
            relation.setEntityValue(entity, entityRelatedValue);
          }
          objectRelatedValue.forEach((objectRelatedValueItem) => {
            let objectRelatedValueEntity = entityRelatedValue.find((entityRelatedValueItem) => {
              return relation.inverseEntityMetadata.compareEntities(objectRelatedValueItem, entityRelatedValueItem);
            });
            const inverseEntityMetadata = relation.inverseEntityMetadata.findInheritanceMetadata(objectRelatedValueItem);
            if (!objectRelatedValueEntity) {
              objectRelatedValueEntity = inverseEntityMetadata.create(void 0, {
                fromDeserializer: true
              });
              entityRelatedValue.push(objectRelatedValueEntity);
            }
            this.groupAndTransform(objectRelatedValueEntity, objectRelatedValueItem, inverseEntityMetadata, getLazyRelationsPromiseValue);
          });
        } else {
          if (!ObjectUtils.isObject(objectRelatedValue)) {
            if (!ObjectUtils.isObject(entityRelatedValue)) relation.setEntityValue(entity, objectRelatedValue);
            return;
          }
          const inverseEntityMetadata = relation.inverseEntityMetadata.findInheritanceMetadata(objectRelatedValue);
          if (!entityRelatedValue) {
            entityRelatedValue = inverseEntityMetadata.create(void 0, {
              fromDeserializer: true
            });
            relation.setEntityValue(entity, entityRelatedValue);
          }
          this.groupAndTransform(entityRelatedValue, objectRelatedValue, inverseEntityMetadata, getLazyRelationsPromiseValue);
        }
      });
    }
  }
};

// ../node_modules/typeorm/browser/query-builder/transformer/PlainObjectToDatabaseEntityTransformer.js
var LoadMapItem = class {
  constructor(plainEntity, metadata, parentLoadMapItem, relation) {
    this.plainEntity = plainEntity;
    this.metadata = metadata;
    this.parentLoadMapItem = parentLoadMapItem;
    this.relation = relation;
  }
  get target() {
    return this.metadata.target;
  }
  get id() {
    return this.metadata.getEntityIdMixedMap(this.plainEntity);
  }
};
var LoadMap = class {
  constructor() {
    this.loadMapItems = [];
  }
  get mainLoadMapItem() {
    return this.loadMapItems.find((item) => !item.relation && !item.parentLoadMapItem);
  }
  addLoadMap(newLoadMap) {
    const item = this.loadMapItems.find((item2) => item2.target === newLoadMap.target && item2.id === newLoadMap.id);
    if (!item) this.loadMapItems.push(newLoadMap);
  }
  fillEntities(target, entities) {
    entities.forEach((entity) => {
      const item = this.loadMapItems.find((loadMapItem) => {
        return loadMapItem.target === target && loadMapItem.metadata.compareEntities(entity, loadMapItem.plainEntity);
      });
      if (item) item.entity = entity;
    });
  }
  groupByTargetIds() {
    const groups = [];
    this.loadMapItems.forEach((loadMapItem) => {
      let group = groups.find((group2) => group2.target === loadMapItem.target);
      if (!group) {
        group = {
          target: loadMapItem.target,
          ids: []
        };
        groups.push(group);
      }
      group.ids.push(loadMapItem.id);
    });
    return groups;
  }
};
var PlainObjectToDatabaseEntityTransformer = class {
  constructor(manager) {
    this.manager = manager;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  transform(plainObject, metadata) {
    return __async(this, null, function* () {
      if (!metadata.hasAllPrimaryKeys(plainObject)) return Promise.reject("Given object does not have a primary column, cannot transform it to database entity.");
      const loadMap = new LoadMap();
      const fillLoadMap = (entity, entityMetadata, parentLoadMapItem, relation) => {
        const item = new LoadMapItem(entity, entityMetadata, parentLoadMapItem, relation);
        loadMap.addLoadMap(item);
        entityMetadata.extractRelationValuesFromEntity(entity, metadata.relations).filter((value) => value !== null && value !== void 0).forEach(([relation2, value, inverseEntityMetadata]) => fillLoadMap(value, inverseEntityMetadata, item, relation2));
      };
      fillLoadMap(plainObject, metadata);
      yield Promise.all(loadMap.groupByTargetIds().map((targetWithIds) => {
        return this.manager.findByIds(targetWithIds.target, targetWithIds.ids).then((entities) => loadMap.fillEntities(targetWithIds.target, entities));
      }));
      loadMap.loadMapItems.forEach((loadMapItem) => {
        if (!loadMapItem.relation || !loadMapItem.entity || !loadMapItem.parentLoadMapItem || !loadMapItem.parentLoadMapItem.entity) return;
        if (loadMapItem.relation.isManyToMany || loadMapItem.relation.isOneToMany) {
          if (!loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName]) loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName] = [];
          loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName].push(loadMapItem.entity);
        } else {
          loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName] = loadMapItem.entity;
        }
      });
      return loadMap.mainLoadMapItem ? loadMap.mainLoadMapItem.entity : void 0;
    });
  }
};

// ../node_modules/typeorm/browser/repository/AbstractRepository.js
var AbstractRepository = class {
  // -------------------------------------------------------------------------
  // Protected Accessors
  // -------------------------------------------------------------------------
  /**
   * Gets the original ORM repository for the entity that is managed by this repository.
   * If current repository does not manage any entity, then exception will be thrown.
   */
  get repository() {
    const target = this.getCustomRepositoryTarget(this);
    if (!target) throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);
    return this.manager.getRepository(target);
  }
  /**
   * Gets the original ORM tree repository for the entity that is managed by this repository.
   * If current repository does not manage any entity, then exception will be thrown.
   */
  get treeRepository() {
    const target = this.getCustomRepositoryTarget(this);
    if (!target) throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);
    return this.manager.getTreeRepository(target);
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Creates a new query builder for the repository's entity that can be used to build a SQL query.
   * If current repository does not manage any entity, then exception will be thrown.
   */
  createQueryBuilder(alias) {
    const target = this.getCustomRepositoryTarget(this.constructor);
    if (!target) throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);
    return this.manager.getRepository(target).createQueryBuilder(alias);
  }
  /**
   * Creates a new query builder for the given entity that can be used to build a SQL query.
   */
  createQueryBuilderFor(entity, alias) {
    return this.getRepositoryFor(entity).createQueryBuilder(alias);
  }
  /**
   * Gets the original ORM repository for the given entity class.
   */
  getRepositoryFor(entity) {
    return this.manager.getRepository(entity);
  }
  /**
   * Gets the original ORM tree repository for the given entity class.
   */
  getTreeRepositoryFor(entity) {
    return this.manager.getTreeRepository(entity);
  }
  // -------------------------------------------------------------------------
  // Private Methods
  // -------------------------------------------------------------------------
  /**
   * Gets custom repository's managed entity.
   * If given custom repository does not manage any entity then undefined will be returned.
   */
  getCustomRepositoryTarget(customRepository) {
    const entityRepositoryMetadataArgs = getMetadataArgsStorage().entityRepositories.find((repository) => {
      return repository.target === (typeof customRepository === "function" ? customRepository : customRepository.constructor);
    });
    if (!entityRepositoryMetadataArgs) throw new CustomRepositoryNotFoundError(customRepository);
    return entityRepositoryMetadataArgs.entity;
  }
};

// ../node_modules/typeorm/browser/persistence/SubjectTopologicalSorter.js
var SubjectTopologicalSorter = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(subjects) {
    this.subjects = [...subjects];
    this.metadatas = this.getUniqueMetadatas(this.subjects);
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Sorts (orders) subjects in their topological order.
   */
  sort(direction) {
    if (!this.metadatas.length) return this.subjects;
    const sortedSubjects = [];
    if (direction === "delete") {
      const junctionSubjects = this.subjects.filter((subject) => !subject.entity && !subject.databaseEntity);
      sortedSubjects.push(...junctionSubjects);
      this.removeAlreadySorted(junctionSubjects);
    }
    const nonNullableDependencies = this.getNonNullableDependencies();
    let sortedNonNullableEntityTargets = this.toposort(nonNullableDependencies);
    if (direction === "insert") sortedNonNullableEntityTargets = sortedNonNullableEntityTargets.reverse();
    sortedNonNullableEntityTargets.forEach((sortedEntityTarget) => {
      const entityTargetSubjects = this.subjects.filter((subject) => subject.metadata.targetName === sortedEntityTarget || subject.metadata.inheritanceTree.some((s) => s.name === sortedEntityTarget));
      sortedSubjects.push(...entityTargetSubjects);
      this.removeAlreadySorted(entityTargetSubjects);
    });
    const otherDependencies = this.getDependencies();
    let sortedOtherEntityTargets = this.toposort(otherDependencies);
    if (direction === "insert") sortedOtherEntityTargets = sortedOtherEntityTargets.reverse();
    sortedOtherEntityTargets.forEach((sortedEntityTarget) => {
      const entityTargetSubjects = this.subjects.filter((subject) => subject.metadata.targetName === sortedEntityTarget);
      sortedSubjects.push(...entityTargetSubjects);
      this.removeAlreadySorted(entityTargetSubjects);
    });
    sortedSubjects.push(...this.subjects);
    return sortedSubjects;
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Removes already sorted subjects from this.subjects list of subjects.
   */
  removeAlreadySorted(subjects) {
    subjects.forEach((subject) => {
      this.subjects.splice(this.subjects.indexOf(subject), 1);
    });
  }
  /**
   * Extracts all unique metadatas from the given subjects.
   */
  getUniqueMetadatas(subjects) {
    const metadatas = [];
    subjects.forEach((subject) => {
      if (metadatas.indexOf(subject.metadata) === -1) metadatas.push(subject.metadata);
    });
    return metadatas;
  }
  /**
   * Gets dependency tree for all entity metadatas with non-nullable relations.
   * We need to execute insertions first for entities which non-nullable relations.
   */
  getNonNullableDependencies() {
    return this.metadatas.reduce((dependencies, metadata) => {
      metadata.relationsWithJoinColumns.forEach((relation) => {
        if (relation.isNullable) return;
        dependencies.push([metadata.targetName, relation.inverseEntityMetadata.targetName]);
      });
      return dependencies;
    }, []);
  }
  /**
   * Gets dependency tree for all entity metadatas with non-nullable relations.
   * We need to execute insertions first for entities which non-nullable relations.
   */
  getDependencies() {
    return this.metadatas.reduce((dependencies, metadata) => {
      metadata.relationsWithJoinColumns.forEach((relation) => {
        if (relation.inverseEntityMetadata === metadata) return;
        dependencies.push([metadata.targetName, relation.inverseEntityMetadata.targetName]);
      });
      return dependencies;
    }, []);
  }
  /**
   * Sorts given graph using topological sorting algorithm.
   *
   * Algorithm is kindly taken from https://github.com/marcelklehr/toposort repository.
   */
  toposort(edges) {
    function uniqueNodes(arr) {
      let res = [];
      for (let i2 = 0, len = arr.length; i2 < len; i2++) {
        let edge = arr[i2];
        if (res.indexOf(edge[0]) < 0) res.push(edge[0]);
        if (res.indexOf(edge[1]) < 0) res.push(edge[1]);
      }
      return res;
    }
    const nodes = uniqueNodes(edges);
    let cursor = nodes.length, sorted = new Array(cursor), visited = {}, i = cursor;
    while (i--) {
      if (!visited[i]) visit(nodes[i], i, []);
    }
    function visit(node, i2, predecessors) {
      if (predecessors.indexOf(node) >= 0) {
        throw new TypeORMError("Cyclic dependency: " + JSON.stringify(node));
      }
      if (!~nodes.indexOf(node)) {
        throw new TypeORMError("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
      }
      if (visited[i2]) return;
      visited[i2] = true;
      let outgoing = edges.filter(function(edge) {
        return edge[0] === node;
      });
      if (i2 = outgoing.length) {
        let preds = predecessors.concat(node);
        do {
          let child = outgoing[--i2][1];
          visit(child, nodes.indexOf(child), preds);
        } while (i2);
      }
      sorted[--cursor] = node;
    }
    return sorted;
  }
};

// ../node_modules/typeorm/browser/util/DateUtils.js
var import_dayjs = __toESM(require_dayjs_min());
var DateUtils = class {
  // -------------------------------------------------------------------------
  // Public Static Methods
  // -------------------------------------------------------------------------
  /**
   * Normalizes date object hydrated from the database.
   */
  static normalizeHydratedDate(mixedDate) {
    if (!mixedDate) return mixedDate;
    return typeof mixedDate === "string" ? new Date(mixedDate) : mixedDate;
  }
  /**
   * Converts given value into date string in a "YYYY-MM-DD" format.
   */
  static mixedDateToDateString(value) {
    if (value instanceof Date) {
      return this.formatZerolessValue(value.getFullYear(), 4) + "-" + this.formatZerolessValue(value.getMonth() + 1) + "-" + this.formatZerolessValue(value.getDate());
    }
    return value;
  }
  /**
   * Converts given value into date object.
   */
  static mixedDateToDate(mixedDate, toUtc = false, useMilliseconds = true) {
    let date = typeof mixedDate === "string" ? (0, import_dayjs.default)(mixedDate).toDate() : mixedDate;
    if (toUtc) date = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
    if (!useMilliseconds) date.setUTCMilliseconds(0);
    return date;
  }
  /**
   * Converts given value into time string in a "HH:mm:ss" format.
   */
  static mixedDateToTimeString(value, skipSeconds = false) {
    if (value instanceof Date) return this.formatZerolessValue(value.getHours()) + ":" + this.formatZerolessValue(value.getMinutes()) + (!skipSeconds ? ":" + this.formatZerolessValue(value.getSeconds()) : "");
    return value;
  }
  /**
   * Converts given value into time string in a "HH:mm:ss" format.
   */
  static mixedTimeToDate(value) {
    if (typeof value === "string") {
      const [hours, minutes, seconds] = value.split(":");
      const date = /* @__PURE__ */ new Date();
      if (hours) date.setHours(parseInt(hours));
      if (minutes) date.setMinutes(parseInt(minutes));
      if (seconds) date.setSeconds(parseInt(seconds));
      return date;
    }
    return value;
  }
  /**
   * Converts given string value with "-" separator into a "HH:mm:ss" format.
   */
  static mixedTimeToString(value, skipSeconds = false) {
    value = value instanceof Date ? value.getHours() + ":" + value.getMinutes() + (!skipSeconds ? ":" + value.getSeconds() : "") : value;
    if (typeof value === "string") {
      return value.split(":").map((v) => v.length === 1 ? "0" + v : v).join(":");
    }
    return value;
  }
  /**
   * Converts given value into datetime string in a "YYYY-MM-DD HH-mm-ss" format.
   */
  static mixedDateToDatetimeString(value, useMilliseconds) {
    if (typeof value === "string") {
      value = new Date(value);
    }
    if (value instanceof Date) {
      let finalValue = this.formatZerolessValue(value.getFullYear(), 4) + "-" + this.formatZerolessValue(value.getMonth() + 1) + "-" + this.formatZerolessValue(value.getDate()) + " " + this.formatZerolessValue(value.getHours()) + ":" + this.formatZerolessValue(value.getMinutes()) + ":" + this.formatZerolessValue(value.getSeconds());
      if (useMilliseconds) finalValue += `.${this.formatMilliseconds(value.getMilliseconds())}`;
      value = finalValue;
    }
    return value;
  }
  /**
   * Converts given value into utc datetime string in a "YYYY-MM-DD HH-mm-ss.sss" format.
   */
  static mixedDateToUtcDatetimeString(value) {
    if (typeof value === "string") {
      value = new Date(value);
    }
    if (value instanceof Date) {
      return this.formatZerolessValue(value.getUTCFullYear(), 4) + "-" + this.formatZerolessValue(value.getUTCMonth() + 1) + "-" + this.formatZerolessValue(value.getUTCDate()) + " " + this.formatZerolessValue(value.getUTCHours()) + ":" + this.formatZerolessValue(value.getUTCMinutes()) + ":" + this.formatZerolessValue(value.getUTCSeconds()) + "." + this.formatMilliseconds(value.getUTCMilliseconds());
    }
    return value;
  }
  /**
   * Converts each item in the given array to string joined by "," separator.
   */
  static simpleArrayToString(value) {
    if (Array.isArray(value)) {
      return value.map((i) => String(i)).join(",");
    }
    return value;
  }
  /**
   * Converts given string to simple array split by "," separator.
   */
  static stringToSimpleArray(value) {
    if (typeof value === "string") {
      if (value.length > 0) {
        return value.split(",");
      } else {
        return [];
      }
    }
    return value;
  }
  static simpleJsonToString(value) {
    return JSON.stringify(value);
  }
  static stringToSimpleJson(value) {
    return typeof value === "string" ? JSON.parse(value) : value;
  }
  static simpleEnumToString(value) {
    return "" + value;
  }
  static stringToSimpleEnum(value, columnMetadata) {
    if (columnMetadata.enum && !isNaN(value) && columnMetadata.enum.indexOf(parseInt(value)) >= 0) {
      value = parseInt(value);
    }
    return value;
  }
  // -------------------------------------------------------------------------
  // Private Static Methods
  // -------------------------------------------------------------------------
  /**
   * Formats given number to "0x" format, e.g. if the totalLength = 2 and the value is 1 then it will return "01".
   */
  static formatZerolessValue(value, totalLength = 2) {
    const pad = "0".repeat(totalLength);
    return String(`${pad}${value}`).slice(-totalLength);
  }
  /**
   * Formats given number to "0x" format, e.g. if it is 1 then it will return "01".
   */
  static formatMilliseconds(value) {
    if (value < 10) {
      return "00" + value;
    } else if (value < 100) {
      return "0" + value;
    } else {
      return String(value);
    }
  }
};

// ../node_modules/typeorm/browser/persistence/SubjectChangedColumnsComputer.js
var SubjectChangedColumnsComputer = class {
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Finds what columns are changed in the subject entities.
   */
  compute(subjects) {
    subjects.forEach((subject) => {
      this.computeDiffColumns(subject);
      this.computeDiffRelationalColumns(subjects, subject);
    });
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Differentiate columns from the updated entity and entity stored in the database.
   */
  computeDiffColumns(subject) {
    if (!subject.entity) return;
    subject.metadata.columns.forEach((column) => {
      if (column.isVirtual || column.isDiscriminator) return;
      const changeMap = subject.changeMaps.find((changeMap2) => changeMap2.column === column);
      if (changeMap) {
        subject.changeMaps.splice(subject.changeMaps.indexOf(changeMap), 1);
      }
      const entityValue = column.getEntityValue(subject.entity);
      if (entityValue === void 0) return;
      if (subject.databaseEntity) {
        const shouldTransformDatabaseEntity = column.type !== "json" && column.type !== "jsonb";
        let databaseValue = column.getEntityValue(subject.databaseEntity, shouldTransformDatabaseEntity);
        if (column.relationMetadata) {
          const value = column.relationMetadata.getEntityValue(subject.entity);
          if (value !== null && value !== void 0) return;
        }
        let normalizedValue = entityValue;
        if (entityValue !== null) {
          switch (column.type) {
            case "date":
              normalizedValue = DateUtils.mixedDateToDateString(entityValue);
              break;
            case "time":
            case "time with time zone":
            case "time without time zone":
            case "timetz":
              normalizedValue = DateUtils.mixedDateToTimeString(entityValue);
              break;
            case "datetime":
            case "datetime2":
            case Date:
            case "timestamp":
            case "timestamp without time zone":
            case "timestamp with time zone":
            case "timestamp with local time zone":
            case "timestamptz":
              normalizedValue = DateUtils.mixedDateToUtcDatetimeString(entityValue);
              databaseValue = DateUtils.mixedDateToUtcDatetimeString(databaseValue);
              break;
            case "json":
            case "jsonb":
              if (OrmUtils.deepCompare(entityValue, databaseValue)) return;
              break;
            case "simple-array":
              normalizedValue = DateUtils.simpleArrayToString(entityValue);
              databaseValue = DateUtils.simpleArrayToString(databaseValue);
              break;
            case "simple-enum":
              normalizedValue = DateUtils.simpleEnumToString(entityValue);
              databaseValue = DateUtils.simpleEnumToString(databaseValue);
              break;
            case "simple-json":
              normalizedValue = DateUtils.simpleJsonToString(entityValue);
              databaseValue = DateUtils.simpleJsonToString(databaseValue);
              break;
          }
          if (column.transformer) {
            normalizedValue = ApplyValueTransformers.transformTo(column.transformer, entityValue);
          }
        }
        if (Buffer.isBuffer(normalizedValue) && Buffer.isBuffer(databaseValue)) {
          if (normalizedValue.equals(databaseValue)) {
            return;
          }
        } else {
          if (normalizedValue === databaseValue) return;
        }
      }
      if (!subject.diffColumns.includes(column)) subject.diffColumns.push(column);
      subject.changeMaps.push({
        column,
        value: entityValue
      });
    });
  }
  /**
   * Difference columns of the owning one-to-one and many-to-one columns.
   */
  computeDiffRelationalColumns(allSubjects, subject) {
    if (!subject.entity) return;
    subject.metadata.relationsWithJoinColumns.forEach((relation) => {
      let relatedEntity = relation.getEntityValue(subject.entity);
      if (relatedEntity === void 0) return;
      if (subject.databaseEntity) {
        let relatedEntityRelationIdMap = relatedEntity;
        if (relatedEntityRelationIdMap !== null && ObjectUtils.isObject(relatedEntityRelationIdMap)) relatedEntityRelationIdMap = relation.getRelationIdMap(relatedEntityRelationIdMap);
        const databaseRelatedEntityRelationIdMap = relation.getEntityValue(subject.databaseEntity);
        const areRelatedIdsEqual = OrmUtils.compareIds(relatedEntityRelationIdMap, databaseRelatedEntityRelationIdMap);
        if (areRelatedIdsEqual) {
          return;
        } else {
          subject.diffRelations.push(relation);
        }
      }
      const valueSubject = allSubjects.find((subject2) => subject2.mustBeInserted && subject2.entity === relatedEntity);
      if (valueSubject) relatedEntity = valueSubject;
      const changeMap = subject.changeMaps.find((changeMap2) => changeMap2.relation === relation);
      if (changeMap) {
        changeMap.value = relatedEntity;
      } else {
        subject.changeMaps.push({
          relation,
          value: relatedEntity
        });
      }
    });
  }
};

// ../node_modules/typeorm/browser/error/NestedSetMultipleRootError.js
var NestedSetMultipleRootError = class extends TypeORMError {
  constructor() {
    super(`Nested sets do not support multiple root entities.`);
  }
};

// ../node_modules/typeorm/browser/persistence/tree/NestedSetSubjectExecutor.js
var NestedSetSubjectExecutor = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(queryRunner) {
    this.queryRunner = queryRunner;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Executes operations when subject is being inserted.
   */
  insert(subject) {
    return __async(this, null, function* () {
      const escape = (alias) => this.queryRunner.connection.driver.escape(alias);
      const tableName = this.getTableName(subject.metadata.tablePath);
      const leftColumnName = escape(subject.metadata.nestedSetLeftColumn.databaseName);
      const rightColumnName = escape(subject.metadata.nestedSetRightColumn.databaseName);
      let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity);
      if (!parent && subject.parentSubject && subject.parentSubject.entity)
        parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;
      const parentId = subject.metadata.getEntityIdMap(parent);
      let parentNsRight = void 0;
      if (parentId) {
        parentNsRight = yield this.queryRunner.manager.createQueryBuilder().select(subject.metadata.targetName + "." + subject.metadata.nestedSetRightColumn.propertyPath, "right").from(subject.metadata.target, subject.metadata.targetName).whereInIds(parentId).getRawOne().then((result) => {
          const value = result ? result["right"] : void 0;
          return typeof value === "string" ? parseInt(value) : value;
        });
      }
      if (parentNsRight !== void 0) {
        yield this.queryRunner.query(`UPDATE ${tableName} SET ${leftColumnName} = CASE WHEN ${leftColumnName} > ${parentNsRight} THEN ${leftColumnName} + 2 ELSE ${leftColumnName} END,${rightColumnName} = ${rightColumnName} + 2 WHERE ${rightColumnName} >= ${parentNsRight}`);
        OrmUtils.mergeDeep(subject.insertedValueSet, subject.metadata.nestedSetLeftColumn.createValueMap(parentNsRight), subject.metadata.nestedSetRightColumn.createValueMap(parentNsRight + 1));
      } else {
        const isUniqueRoot = yield this.isUniqueRootEntity(subject, parent);
        if (!isUniqueRoot) throw new NestedSetMultipleRootError();
        OrmUtils.mergeDeep(subject.insertedValueSet, subject.metadata.nestedSetLeftColumn.createValueMap(1), subject.metadata.nestedSetRightColumn.createValueMap(2));
      }
    });
  }
  /**
   * Executes operations when subject is being updated.
   */
  update(subject) {
    return __async(this, null, function* () {
      let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity);
      if (!parent && subject.parentSubject && subject.parentSubject.entity)
        parent = subject.parentSubject.entity;
      let entity = subject.databaseEntity;
      if (!entity && parent)
        entity = subject.metadata.treeChildrenRelation.getEntityValue(parent).find((child) => {
          return Object.entries(subject.identifier).every(([key, value]) => child[key] === value);
        });
      if (entity === void 0 || parent === void 0) {
        return;
      }
      const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);
      const oldParentId = subject.metadata.getEntityIdMap(oldParent);
      const parentId = subject.metadata.getEntityIdMap(parent);
      if (OrmUtils.compareIds(oldParentId, parentId)) {
        return;
      }
      if (parent) {
        const escape = (alias) => this.queryRunner.connection.driver.escape(alias);
        const tableName = this.getTableName(subject.metadata.tablePath);
        const leftColumnName = escape(subject.metadata.nestedSetLeftColumn.databaseName);
        const rightColumnName = escape(subject.metadata.nestedSetRightColumn.databaseName);
        const entityId = subject.metadata.getEntityIdMap(entity);
        let entityNs = void 0;
        if (entityId) {
          entityNs = (yield this.getNestedSetIds(subject.metadata, entityId))[0];
        }
        let parentNs = void 0;
        if (parentId) {
          parentNs = (yield this.getNestedSetIds(subject.metadata, parentId))[0];
        }
        if (entityNs !== void 0 && parentNs !== void 0) {
          const isMovingUp = parentNs.left > entityNs.left;
          const treeSize = entityNs.right - entityNs.left + 1;
          let entitySize;
          if (isMovingUp) {
            entitySize = parentNs.left - entityNs.right;
          } else {
            entitySize = parentNs.right - entityNs.left;
          }
          const updateLeftSide = `WHEN ${leftColumnName} >= ${entityNs.left} AND ${leftColumnName} < ${entityNs.right} THEN ${leftColumnName} + ${entitySize} `;
          const updateRightSide = `WHEN ${rightColumnName} > ${entityNs.left} AND ${rightColumnName} <= ${entityNs.right} THEN ${rightColumnName} + ${entitySize} `;
          if (isMovingUp) {
            yield this.queryRunner.query(`UPDATE ${tableName} SET ${leftColumnName} = CASE WHEN ${leftColumnName} > ${entityNs.right} AND ${leftColumnName} <= ${parentNs.left} THEN ${leftColumnName} - ${treeSize} ` + updateLeftSide + `ELSE ${leftColumnName} END, ${rightColumnName} = CASE WHEN ${rightColumnName} > ${entityNs.right} AND ${rightColumnName} < ${parentNs.left} THEN ${rightColumnName} - ${treeSize} ` + updateRightSide + `ELSE ${rightColumnName} END`);
          } else {
            yield this.queryRunner.query(`UPDATE ${tableName} SET ${leftColumnName} = CASE WHEN ${leftColumnName} < ${entityNs.left} AND ${leftColumnName} > ${parentNs.right} THEN ${leftColumnName} + ${treeSize} ` + updateLeftSide + `ELSE ${leftColumnName} END, ${rightColumnName} = CASE WHEN ${rightColumnName} < ${entityNs.left} AND ${rightColumnName} >= ${parentNs.right} THEN ${rightColumnName} + ${treeSize} ` + updateRightSide + `ELSE ${rightColumnName} END`);
          }
        }
      } else {
        const isUniqueRoot = yield this.isUniqueRootEntity(subject, parent);
        if (!isUniqueRoot) throw new NestedSetMultipleRootError();
      }
    });
  }
  /**
   * Executes operations when subject is being removed.
   */
  remove(subjects) {
    return __async(this, null, function* () {
      if (!Array.isArray(subjects)) subjects = [subjects];
      const metadata = subjects[0].metadata;
      const escape = (alias) => this.queryRunner.connection.driver.escape(alias);
      const tableName = this.getTableName(metadata.tablePath);
      const leftColumnName = escape(metadata.nestedSetLeftColumn.databaseName);
      const rightColumnName = escape(metadata.nestedSetRightColumn.databaseName);
      let entitiesIds = [];
      for (const subject of subjects) {
        const entityId = metadata.getEntityIdMap(subject.entity);
        if (entityId) {
          entitiesIds.push(entityId);
        }
      }
      let entitiesNs = yield this.getNestedSetIds(metadata, entitiesIds);
      for (const entity of entitiesNs) {
        const treeSize = entity.right - entity.left + 1;
        yield this.queryRunner.query(`UPDATE ${tableName} SET ${leftColumnName} = CASE WHEN ${leftColumnName} > ${entity.left} THEN ${leftColumnName} - ${treeSize} ELSE ${leftColumnName} END, ${rightColumnName} = CASE WHEN ${rightColumnName} > ${entity.right} THEN ${rightColumnName} - ${treeSize} ELSE ${rightColumnName} END`);
      }
    });
  }
  /**
   * Get the nested set ids for a given entity
   */
  getNestedSetIds(metadata, ids) {
    const select = {
      left: `${metadata.targetName}.${metadata.nestedSetLeftColumn.propertyPath}`,
      right: `${metadata.targetName}.${metadata.nestedSetRightColumn.propertyPath}`
    };
    const queryBuilder = this.queryRunner.manager.createQueryBuilder();
    Object.entries(select).forEach(([key, value]) => {
      queryBuilder.addSelect(value, key);
    });
    return queryBuilder.from(metadata.target, metadata.targetName).whereInIds(ids).orderBy(select.right, "DESC").getRawMany().then((results) => {
      const data = [];
      for (const result of results) {
        const entry = {};
        for (const key of Object.keys(select)) {
          const value = result ? result[key] : void 0;
          entry[key] = typeof value === "string" ? parseInt(value) : value;
        }
        data.push(entry);
      }
      return data;
    });
  }
  isUniqueRootEntity(subject, parent) {
    return __async(this, null, function* () {
      const escape = (alias) => this.queryRunner.connection.driver.escape(alias);
      const tableName = this.getTableName(subject.metadata.tablePath);
      const parameters = [];
      const whereCondition = subject.metadata.treeParentRelation.joinColumns.map((column) => {
        const columnName = escape(column.databaseName);
        const parameter = column.getEntityValue(parent);
        if (parameter == null) {
          return `${columnName} IS NULL`;
        }
        parameters.push(parameter);
        const parameterName = this.queryRunner.connection.driver.createParameter("entity_" + column.databaseName, parameters.length - 1);
        return `${columnName} = ${parameterName}`;
      }).join(" AND ");
      const countAlias = "count";
      const result = yield this.queryRunner.query(`SELECT COUNT(1) AS ${escape(countAlias)} FROM ${tableName} WHERE ${whereCondition}`, parameters, true);
      return parseInt(result.records[0][countAlias]) === 0;
    });
  }
  /**
   * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom
   * schema name, otherwise returns escaped table name.
   */
  getTableName(tablePath) {
    return tablePath.split(".").map((i) => {
      return i === "" ? i : this.queryRunner.connection.driver.escape(i);
    }).join(".");
  }
};

// ../node_modules/typeorm/browser/persistence/tree/ClosureSubjectExecutor.js
var ClosureSubjectExecutor = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(queryRunner) {
    this.queryRunner = queryRunner;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Executes operations when subject is being inserted.
   */
  insert(subject) {
    return __async(this, null, function* () {
      const closureJunctionInsertMap = {};
      subject.metadata.closureJunctionTable.ancestorColumns.forEach((column) => {
        closureJunctionInsertMap[column.databaseName] = subject.identifier;
      });
      subject.metadata.closureJunctionTable.descendantColumns.forEach((column) => {
        closureJunctionInsertMap[column.databaseName] = subject.identifier;
      });
      yield this.queryRunner.manager.createQueryBuilder().insert().into(subject.metadata.closureJunctionTable.tablePath).values(closureJunctionInsertMap).updateEntity(false).callListeners(false).execute();
      let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity);
      if (!parent && subject.parentSubject && subject.parentSubject.entity)
        parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;
      if (parent) {
        const escape = (alias) => this.queryRunner.connection.driver.escape(alias);
        const tableName = this.getTableName(subject.metadata.closureJunctionTable.tablePath);
        const queryParams = [];
        const ancestorColumnNames = subject.metadata.closureJunctionTable.ancestorColumns.map((column) => {
          return escape(column.databaseName);
        });
        const descendantColumnNames = subject.metadata.closureJunctionTable.descendantColumns.map((column) => {
          return escape(column.databaseName);
        });
        const childEntityIds1 = subject.metadata.primaryColumns.map((column) => {
          queryParams.push(column.getEntityValue(subject.insertedValueSet ? subject.insertedValueSet : subject.entity));
          return this.queryRunner.connection.driver.createParameter("child_entity_" + column.databaseName, queryParams.length - 1);
        });
        const whereCondition = subject.metadata.closureJunctionTable.descendantColumns.map((column) => {
          const columnName = escape(column.databaseName);
          const parentId = column.referencedColumn.getEntityValue(parent);
          if (!parentId) throw new CannotAttachTreeChildrenEntityError(subject.metadata.name);
          queryParams.push(parentId);
          const parameterName = this.queryRunner.connection.driver.createParameter("parent_entity_" + column.referencedColumn.databaseName, queryParams.length - 1);
          return `${columnName} = ${parameterName}`;
        });
        yield this.queryRunner.query(`INSERT INTO ${tableName} (${[...ancestorColumnNames, ...descendantColumnNames].join(", ")}) SELECT ${ancestorColumnNames.join(", ")}, ${childEntityIds1.join(", ")} FROM ${tableName} WHERE ${whereCondition.join(" AND ")}`, queryParams);
      }
    });
  }
  /**
   * Executes operations when subject is being updated.
   */
  update(subject) {
    return __async(this, null, function* () {
      let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity);
      if (!parent && subject.parentSubject && subject.parentSubject.entity)
        parent = subject.parentSubject.entity;
      let entity = subject.databaseEntity;
      if (!entity && parent)
        entity = subject.metadata.treeChildrenRelation.getEntityValue(parent).find((child) => {
          return Object.entries(subject.identifier).every(([key, value]) => child[key] === value);
        });
      if (entity === void 0 || parent === void 0) {
        return;
      }
      const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);
      const oldParentId = subject.metadata.getEntityIdMap(oldParent);
      const parentId = subject.metadata.getEntityIdMap(parent);
      if (OrmUtils.compareIds(oldParentId, parentId)) {
        return;
      }
      const escape = (alias) => this.queryRunner.connection.driver.escape(alias);
      const closureTable = subject.metadata.closureJunctionTable;
      const ancestorColumnNames = closureTable.ancestorColumns.map((column) => {
        return escape(column.databaseName);
      });
      const descendantColumnNames = closureTable.descendantColumns.map((column) => {
        return escape(column.databaseName);
      });
      const createSubQuery = (qb, alias) => {
        const subAlias = `sub${alias}`;
        const subSelect = qb.createQueryBuilder().select(descendantColumnNames.join(", ")).from(closureTable.tablePath, subAlias);
        for (const column of closureTable.ancestorColumns) {
          subSelect.andWhere(`${escape(subAlias)}.${escape(column.databaseName)} = :value_${column.referencedColumn.databaseName}`);
        }
        return qb.createQueryBuilder().select(descendantColumnNames.join(", ")).from(`(${subSelect.getQuery()})`, alias).setParameters(subSelect.getParameters()).getQuery();
      };
      const parameters = {};
      for (const column of subject.metadata.primaryColumns) {
        parameters[`value_${column.databaseName}`] = entity[column.databaseName];
      }
      yield this.queryRunner.manager.createQueryBuilder().delete().from(closureTable.tablePath).where((qb) => `(${descendantColumnNames.join(", ")}) IN (${createSubQuery(qb, "descendant")})`).andWhere((qb) => `(${ancestorColumnNames.join(", ")}) NOT IN (${createSubQuery(qb, "ancestor")})`).setParameters(parameters).execute();
      if (parent) {
        const queryParams = [];
        const tableName = this.getTableName(closureTable.tablePath);
        const superAlias = escape("supertree");
        const subAlias = escape("subtree");
        const select = [...ancestorColumnNames.map((columnName) => `${superAlias}.${columnName}`), ...descendantColumnNames.map((columnName) => `${subAlias}.${columnName}`)];
        const entityWhereCondition = subject.metadata.closureJunctionTable.ancestorColumns.map((column) => {
          const columnName = escape(column.databaseName);
          const entityId = column.referencedColumn.getEntityValue(entity);
          queryParams.push(entityId);
          const parameterName = this.queryRunner.connection.driver.createParameter("entity_" + column.referencedColumn.databaseName, queryParams.length - 1);
          return `${subAlias}.${columnName} = ${parameterName}`;
        });
        const parentWhereCondition = subject.metadata.closureJunctionTable.descendantColumns.map((column) => {
          const columnName = escape(column.databaseName);
          const parentId2 = column.referencedColumn.getEntityValue(parent);
          if (!parentId2) throw new CannotAttachTreeChildrenEntityError(subject.metadata.name);
          queryParams.push(parentId2);
          const parameterName = this.queryRunner.connection.driver.createParameter("parent_entity_" + column.referencedColumn.databaseName, queryParams.length - 1);
          return `${superAlias}.${columnName} = ${parameterName}`;
        });
        yield this.queryRunner.query(`INSERT INTO ${tableName} (${[...ancestorColumnNames, ...descendantColumnNames].join(", ")}) SELECT ${select.join(", ")} FROM ${tableName} AS ${superAlias}, ${tableName} AS ${subAlias} WHERE ${[...entityWhereCondition, ...parentWhereCondition].join(" AND ")}`, queryParams);
      }
    });
  }
  /**
   * Executes operations when subject is being removed.
   */
  remove(subjects) {
    return __async(this, null, function* () {
      if (!(this.queryRunner.connection.driver.options.type === "mssql")) {
        return;
      }
      if (!Array.isArray(subjects)) subjects = [subjects];
      const escape = (alias) => this.queryRunner.connection.driver.escape(alias);
      const identifiers = subjects.map((subject) => subject.identifier);
      const closureTable = subjects[0].metadata.closureJunctionTable;
      const generateWheres = (columns) => {
        return columns.map((column) => {
          const data = identifiers.map((identifier) => identifier[column.referencedColumn.databaseName]);
          return `${escape(column.databaseName)} IN (${data.join(", ")})`;
        }).join(" AND ");
      };
      const ancestorWhere = generateWheres(closureTable.ancestorColumns);
      const descendantWhere = generateWheres(closureTable.descendantColumns);
      yield this.queryRunner.manager.createQueryBuilder().delete().from(closureTable.tablePath).where(ancestorWhere).orWhere(descendantWhere).execute();
    });
  }
  /**
   * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom
   * schema name, otherwise returns escaped table name.
   */
  getTableName(tablePath) {
    return tablePath.split(".").map((i) => {
      return i === "" ? i : this.queryRunner.connection.driver.escape(i);
    }).join(".");
  }
};

// ../node_modules/typeorm/browser/metadata/EntityMetadata.js
var EntityMetadata = class _EntityMetadata {
  // ---------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------
  constructor(options) {
    this["@instanceof"] = Symbol.for("EntityMetadata");
    this.childEntityMetadatas = [];
    this.inheritanceTree = [];
    this.tableType = "regular";
    this.withoutRowid = false;
    this.synchronize = true;
    this.hasNonNullableRelations = false;
    this.isJunction = false;
    this.isAlwaysUsingConstructor = true;
    this.isClosureJunction = false;
    this.hasMultiplePrimaryKeys = false;
    this.hasUUIDGeneratedColumns = false;
    this.ownColumns = [];
    this.columns = [];
    this.ancestorColumns = [];
    this.descendantColumns = [];
    this.nonVirtualColumns = [];
    this.ownerColumns = [];
    this.inverseColumns = [];
    this.generatedColumns = [];
    this.primaryColumns = [];
    this.ownRelations = [];
    this.relations = [];
    this.eagerRelations = [];
    this.lazyRelations = [];
    this.oneToOneRelations = [];
    this.ownerOneToOneRelations = [];
    this.oneToManyRelations = [];
    this.manyToOneRelations = [];
    this.manyToManyRelations = [];
    this.ownerManyToManyRelations = [];
    this.relationsWithJoinColumns = [];
    this.relationIds = [];
    this.relationCounts = [];
    this.foreignKeys = [];
    this.embeddeds = [];
    this.allEmbeddeds = [];
    this.ownIndices = [];
    this.indices = [];
    this.uniques = [];
    this.ownUniques = [];
    this.checks = [];
    this.exclusions = [];
    this.ownListeners = [];
    this.listeners = [];
    this.afterLoadListeners = [];
    this.beforeInsertListeners = [];
    this.afterInsertListeners = [];
    this.beforeUpdateListeners = [];
    this.afterUpdateListeners = [];
    this.beforeRemoveListeners = [];
    this.beforeSoftRemoveListeners = [];
    this.beforeRecoverListeners = [];
    this.afterRemoveListeners = [];
    this.afterSoftRemoveListeners = [];
    this.afterRecoverListeners = [];
    this.connection = options.connection;
    this.inheritanceTree = options.inheritanceTree || [];
    this.inheritancePattern = options.inheritancePattern;
    this.treeType = options.tableTree ? options.tableTree.type : void 0;
    this.treeOptions = options.tableTree ? options.tableTree.options : void 0;
    this.parentClosureEntityMetadata = options.parentClosureEntityMetadata;
    this.tableMetadataArgs = options.args;
    this.target = this.tableMetadataArgs.target;
    this.tableType = this.tableMetadataArgs.type;
    this.expression = this.tableMetadataArgs.expression;
    this.withoutRowid = this.tableMetadataArgs.withoutRowid;
    this.dependsOn = this.tableMetadataArgs.dependsOn;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates a new entity.
   */
  create(queryRunner, options) {
    const pojo = options && options.pojo === true ? true : false;
    let ret;
    if (typeof this.target === "function" && !pojo) {
      if (!options?.fromDeserializer || this.isAlwaysUsingConstructor) {
        ret = new this.target();
      } else {
        ret = Object.create(this.target.prototype);
      }
    } else {
      ret = {};
    }
    if (this.connection.options.typename) {
      ret[this.connection.options.typename] = this.targetName;
    }
    this.lazyRelations.forEach((relation) => this.connection.relationLoader.enableLazyLoad(relation, ret, queryRunner));
    return ret;
  }
  /**
   * Checks if given entity has an id.
   */
  hasId(entity) {
    if (!entity) return false;
    return this.primaryColumns.every((primaryColumn) => {
      const value = primaryColumn.getEntityValue(entity);
      return value !== null && value !== void 0 && value !== "";
    });
  }
  /**
   * Checks if given entity / object contains ALL primary keys entity must have.
   * Returns true if it contains all of them, false if at least one of them is not defined.
   */
  hasAllPrimaryKeys(entity) {
    return this.primaryColumns.every((primaryColumn) => {
      const value = primaryColumn.getEntityValue(entity);
      return value !== null && value !== void 0;
    });
  }
  /**
   * Ensures that given object is an entity id map.
   * If given id is an object then it means its already id map.
   * If given id isn't an object then it means its a value of the id column
   * and it creates a new id map with this value and name of the primary column.
   */
  ensureEntityIdMap(id) {
    if (ObjectUtils.isObject(id)) return id;
    if (this.hasMultiplePrimaryKeys) throw new CannotCreateEntityIdMapError(this, id);
    return this.primaryColumns[0].createValueMap(id);
  }
  /**
   * Gets primary keys of the entity and returns them in a literal object.
   * For example, for Post{ id: 1, title: "hello" } where id is primary it will return { id: 1 }
   * For multiple primary keys it returns multiple keys in object.
   * For primary keys inside embeds it returns complex object literal with keys in them.
   */
  getEntityIdMap(entity) {
    if (!entity) return void 0;
    return _EntityMetadata.getValueMap(entity, this.primaryColumns, {
      skipNulls: true
    });
  }
  /**
   * Creates a "mixed id map".
   * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.
   * But if entity has a single primary key then it will return just value of the id column of the entity, just value.
   * This is called mixed id map.
   */
  getEntityIdMixedMap(entity) {
    if (!entity) return entity;
    const idMap = this.getEntityIdMap(entity);
    if (this.hasMultiplePrimaryKeys) {
      return idMap;
    } else if (idMap) {
      return this.primaryColumns[0].getEntityValue(idMap);
    }
    return idMap;
  }
  /**
   * Compares two different entities by their ids.
   * Returns true if they match, false otherwise.
   */
  compareEntities(firstEntity, secondEntity) {
    const firstEntityIdMap = this.getEntityIdMap(firstEntity);
    if (!firstEntityIdMap) return false;
    const secondEntityIdMap = this.getEntityIdMap(secondEntity);
    if (!secondEntityIdMap) return false;
    return OrmUtils.compareIds(firstEntityIdMap, secondEntityIdMap);
  }
  /**
   * Finds column with a given property name.
   */
  findColumnWithPropertyName(propertyName) {
    return this.columns.find((column) => column.propertyName === propertyName);
  }
  /**
   * Finds column with a given database name.
   */
  findColumnWithDatabaseName(databaseName) {
    return this.columns.find((column) => column.databaseName === databaseName);
  }
  /**
   * Checks if there is a column or relationship with a given property path.
   */
  hasColumnWithPropertyPath(propertyPath) {
    const hasColumn = this.columns.some((column) => column.propertyPath === propertyPath);
    return hasColumn || this.hasRelationWithPropertyPath(propertyPath);
  }
  /**
   * Finds column with a given property path.
   */
  findColumnWithPropertyPath(propertyPath) {
    const column = this.columns.find((column2) => column2.propertyPath === propertyPath);
    if (column) return column;
    const relation = this.relations.find((relation2) => relation2.propertyPath === propertyPath);
    if (relation && relation.joinColumns.length === 1) return relation.joinColumns[0];
    return void 0;
  }
  /**
   * Finds column with a given property path.
   * Does not search in relation unlike findColumnWithPropertyPath.
   */
  findColumnWithPropertyPathStrict(propertyPath) {
    return this.columns.find((column) => column.propertyPath === propertyPath);
  }
  /**
   * Finds columns with a given property path.
   * Property path can match a relation, and relations can contain multiple columns.
   */
  findColumnsWithPropertyPath(propertyPath) {
    const column = this.columns.find((column2) => column2.propertyPath === propertyPath);
    if (column) return [column];
    const relation = this.findRelationWithPropertyPath(propertyPath);
    if (relation && relation.joinColumns) return relation.joinColumns;
    return [];
  }
  /**
   * Checks if there is a relation with the given property path.
   */
  hasRelationWithPropertyPath(propertyPath) {
    return this.relations.some((relation) => relation.propertyPath === propertyPath);
  }
  /**
   * Finds relation with the given property path.
   */
  findRelationWithPropertyPath(propertyPath) {
    return this.relations.find((relation) => relation.propertyPath === propertyPath);
  }
  /**
   * Checks if there is an embedded with a given property path.
   */
  hasEmbeddedWithPropertyPath(propertyPath) {
    return this.allEmbeddeds.some((embedded) => embedded.propertyPath === propertyPath);
  }
  /**
   * Finds embedded with a given property path.
   */
  findEmbeddedWithPropertyPath(propertyPath) {
    return this.allEmbeddeds.find((embedded) => embedded.propertyPath === propertyPath);
  }
  /**
   * Returns an array of databaseNames mapped from provided propertyPaths
   */
  mapPropertyPathsToColumns(propertyPaths) {
    return propertyPaths.map((propertyPath) => {
      const column = this.findColumnWithPropertyPath(propertyPath);
      if (column == null) {
        throw new EntityPropertyNotFoundError(propertyPath, this);
      }
      return column;
    });
  }
  /**
   * Iterates through entity and finds and extracts all values from relations in the entity.
   * If relation value is an array its being flattened.
   */
  extractRelationValuesFromEntity(entity, relations) {
    const relationsAndValues = [];
    relations.forEach((relation) => {
      const value = relation.getEntityValue(entity);
      if (Array.isArray(value)) {
        value.forEach((subValue) => relationsAndValues.push([relation, subValue, _EntityMetadata.getInverseEntityMetadata(subValue, relation)]));
      } else if (value) {
        relationsAndValues.push([relation, value, _EntityMetadata.getInverseEntityMetadata(value, relation)]);
      }
    });
    return relationsAndValues;
  }
  /**
   * In the case of SingleTableInheritance, find the correct metadata
   * for a given value.
   *
   * @param value The value to find the metadata for.
   * @returns The found metadata for the entity or the base metadata if no matching metadata
   *          was found in the whole inheritance tree.
   */
  findInheritanceMetadata(value) {
    if (this.inheritancePattern === "STI" && this.childEntityMetadatas.length > 0) {
      let manuallySetDiscriminatorValue;
      if (this.discriminatorColumn) {
        manuallySetDiscriminatorValue = value[this.discriminatorColumn.propertyName];
      }
      return this.childEntityMetadatas.find((meta) => manuallySetDiscriminatorValue === meta.discriminatorValue || value.constructor === meta.target) || this;
    }
    return this;
  }
  // -------------------------------------------------------------------------
  // Private Static Methods
  // -------------------------------------------------------------------------
  static getInverseEntityMetadata(value, relation) {
    return relation.inverseEntityMetadata.findInheritanceMetadata(value);
  }
  // -------------------------------------------------------------------------
  // Public Static Methods
  // -------------------------------------------------------------------------
  /**
   * Creates a property paths for a given entity.
   *
   * @deprecated
   */
  static createPropertyPath(metadata, entity, prefix = "") {
    const paths = [];
    Object.keys(entity).forEach((key) => {
      const parentPath = prefix ? prefix + "." + key : key;
      if (metadata.hasEmbeddedWithPropertyPath(parentPath)) {
        const subPaths = this.createPropertyPath(metadata, entity[key], parentPath);
        paths.push(...subPaths);
      } else {
        const path = prefix ? prefix + "." + key : key;
        paths.push(path);
      }
    });
    return paths;
  }
  /**
   * Finds difference between two entity id maps.
   * Returns items that exist in the first array and absent in the second array.
   */
  static difference(firstIdMaps, secondIdMaps) {
    return firstIdMaps.filter((firstIdMap) => {
      return !secondIdMaps.find((secondIdMap) => OrmUtils.compareIds(firstIdMap, secondIdMap));
    });
  }
  /**
   * Creates value map from the given values and columns.
   * Examples of usages are primary columns map and join columns map.
   */
  static getValueMap(entity, columns, options) {
    return columns.reduce((map, column) => {
      const value = column.getEntityValueMap(entity, options);
      if (map === void 0 || value === null || value === void 0) return void 0;
      return OrmUtils.mergeDeep(map, value);
    }, {});
  }
  // ---------------------------------------------------------------------
  // Public Builder Methods
  // ---------------------------------------------------------------------
  build() {
    const namingStrategy = this.connection.namingStrategy;
    const entityPrefix = this.connection.options.entityPrefix;
    const entitySkipConstructor = this.connection.options.entitySkipConstructor;
    this.engine = this.tableMetadataArgs.engine;
    this.database = this.tableMetadataArgs.type === "entity-child" && this.parentEntityMetadata ? this.parentEntityMetadata.database : this.tableMetadataArgs.database;
    if (this.tableMetadataArgs.schema) {
      this.schema = this.tableMetadataArgs.schema;
    } else if (this.tableMetadataArgs.type === "entity-child" && this.parentEntityMetadata) {
      this.schema = this.parentEntityMetadata.schema;
    } else if (this.connection.options?.hasOwnProperty("schema")) {
      this.schema = this.connection.options.schema;
    }
    this.givenTableName = this.tableMetadataArgs.type === "entity-child" && this.parentEntityMetadata ? this.parentEntityMetadata.givenTableName : this.tableMetadataArgs.name;
    this.synchronize = this.tableMetadataArgs.synchronize === false ? false : true;
    this.targetName = typeof this.tableMetadataArgs.target === "function" ? this.tableMetadataArgs.target.name : this.tableMetadataArgs.target;
    if (this.tableMetadataArgs.type === "closure-junction") {
      this.tableNameWithoutPrefix = namingStrategy.closureJunctionTableName(this.givenTableName);
    } else if (this.tableMetadataArgs.type === "entity-child" && this.parentEntityMetadata) {
      this.tableNameWithoutPrefix = namingStrategy.tableName(this.parentEntityMetadata.targetName, this.parentEntityMetadata.givenTableName);
    } else {
      this.tableNameWithoutPrefix = namingStrategy.tableName(this.targetName, this.givenTableName);
      if (this.tableMetadataArgs.type === "junction" && this.connection.driver.maxAliasLength && this.connection.driver.maxAliasLength > 0 && this.tableNameWithoutPrefix.length > this.connection.driver.maxAliasLength) {
        this.tableNameWithoutPrefix = shorten(this.tableNameWithoutPrefix, {
          separator: "_",
          segmentLength: 3
        });
      }
    }
    this.tableName = entityPrefix ? namingStrategy.prefixTableName(entityPrefix, this.tableNameWithoutPrefix) : this.tableNameWithoutPrefix;
    this.target = this.target ? this.target : this.tableName;
    this.name = this.targetName ? this.targetName : this.tableName;
    this.expression = this.tableMetadataArgs.expression;
    this.withoutRowid = this.tableMetadataArgs.withoutRowid === true ? true : false;
    this.tablePath = this.connection.driver.buildTableName(this.tableName, this.schema, this.database);
    this.orderBy = typeof this.tableMetadataArgs.orderBy === "function" ? this.tableMetadataArgs.orderBy(this.propertiesMap) : this.tableMetadataArgs.orderBy;
    if (entitySkipConstructor !== void 0) {
      this.isAlwaysUsingConstructor = !entitySkipConstructor;
    }
    this.isJunction = this.tableMetadataArgs.type === "closure-junction" || this.tableMetadataArgs.type === "junction";
    this.isClosureJunction = this.tableMetadataArgs.type === "closure-junction";
    this.comment = this.tableMetadataArgs.comment;
  }
  /**
   * Registers a new column in the entity and recomputes all depend properties.
   */
  registerColumn(column) {
    if (this.ownColumns.indexOf(column) !== -1) return;
    this.ownColumns.push(column);
    this.columns = this.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), this.ownColumns);
    this.primaryColumns = this.columns.filter((column2) => column2.isPrimary);
    this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1;
    this.hasUUIDGeneratedColumns = this.columns.filter((column2) => column2.isGenerated || column2.generationStrategy === "uuid").length > 0;
    this.propertiesMap = this.createPropertiesMap();
    if (this.childEntityMetadatas) this.childEntityMetadatas.forEach((entityMetadata) => entityMetadata.registerColumn(column));
  }
  /**
   * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)
   * in a special format - { propertyName: propertyName }.
   *
   * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.
   * This method will create following object:
   * { id: "id", counterEmbed: { count: "counterEmbed.count" }, category: "category" }
   */
  createPropertiesMap() {
    const map = {};
    this.columns.forEach((column) => OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath)));
    this.relations.forEach((relation) => OrmUtils.mergeDeep(map, relation.createValueMap(relation.propertyPath)));
    return map;
  }
  /**
   * Checks if entity has any column which rely on returning data,
   * e.g. columns with auto generated value, DEFAULT values considered as dependant of returning data.
   * For example, if we need to have RETURNING after INSERT (or we need returned id for DBs not supporting RETURNING),
   * it means we cannot execute bulk inserts in some cases.
   */
  getInsertionReturningColumns() {
    return this.columns.filter((column) => {
      return column.default !== void 0 || column.asExpression !== void 0 || column.isGenerated || column.isCreateDate || column.isUpdateDate || column.isDeleteDate || column.isVersion;
    });
  }
};

// ../node_modules/typeorm/browser/persistence/tree/MaterializedPathSubjectExecutor.js
var MaterializedPathSubjectExecutor = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(queryRunner) {
    this.queryRunner = queryRunner;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Executes operations when subject is being inserted.
   */
  insert(subject) {
    return __async(this, null, function* () {
      let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity);
      if (!parent && subject.parentSubject && subject.parentSubject.entity)
        parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;
      const parentId = subject.metadata.getEntityIdMap(parent);
      let parentPath = "";
      if (parentId) {
        parentPath = yield this.getEntityPath(subject, parentId);
      }
      const insertedEntityId = subject.metadata.treeParentRelation.joinColumns.map((joinColumn) => {
        return joinColumn.referencedColumn.getEntityValue(subject.insertedValueSet);
      }).join("_");
      yield this.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set({
        [subject.metadata.materializedPathColumn.propertyPath]: parentPath + insertedEntityId + "."
      }).where(subject.identifier).execute();
    });
  }
  /**
   * Executes operations when subject is being updated.
   */
  update(subject) {
    return __async(this, null, function* () {
      let newParent = subject.metadata.treeParentRelation.getEntityValue(subject.entity);
      if (!newParent && subject.parentSubject && subject.parentSubject.entity)
        newParent = subject.parentSubject.entity;
      let entity = subject.databaseEntity;
      if (!entity && newParent)
        entity = subject.metadata.treeChildrenRelation.getEntityValue(newParent).find((child) => {
          return Object.entries(subject.identifier).every(([key, value]) => child[key] === value);
        });
      const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);
      const oldParentId = this.getEntityParentReferencedColumnMap(subject, oldParent);
      const newParentId = this.getEntityParentReferencedColumnMap(subject, newParent);
      if (OrmUtils.compareIds(oldParentId, newParentId)) {
        return;
      }
      let newParentPath = "";
      if (newParentId) {
        newParentPath = yield this.getEntityPath(subject, newParentId);
      }
      let oldParentPath = "";
      if (oldParentId) {
        oldParentPath = (yield this.getEntityPath(subject, oldParentId)) || "";
      }
      const entityPath = subject.metadata.treeParentRelation.joinColumns.map((joinColumn) => {
        return joinColumn.referencedColumn.getEntityValue(entity);
      }).join("_");
      const propertyPath = subject.metadata.materializedPathColumn.propertyPath;
      yield this.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set({
        [propertyPath]: () => `REPLACE(${this.queryRunner.connection.driver.escape(propertyPath)}, '${oldParentPath}${entityPath}.', '${newParentPath}${entityPath}.')`
      }).where(`${propertyPath} LIKE :path`, {
        path: `${oldParentPath}${entityPath}.%`
      }).execute();
    });
  }
  getEntityParentReferencedColumnMap(subject, entity) {
    if (!entity) return void 0;
    return EntityMetadata.getValueMap(entity, subject.metadata.treeParentRelation.joinColumns.map((column) => column.referencedColumn).filter((v) => v != null), {
      skipNulls: true
    });
  }
  getEntityPath(subject, id) {
    const metadata = subject.metadata;
    const normalized = (Array.isArray(id) ? id : [id]).map((id2) => metadata.ensureEntityIdMap(id2));
    return this.queryRunner.manager.createQueryBuilder().select(subject.metadata.targetName + "." + subject.metadata.materializedPathColumn.propertyPath, "path").from(subject.metadata.target, subject.metadata.targetName).where(new Brackets((qb) => {
      for (const data of normalized) {
        qb.orWhere(new Brackets((qb2) => qb2.where(data)));
      }
    })).getRawOne().then((result) => result ? result["path"] : "");
  }
};

// ../node_modules/typeorm/browser/persistence/SubjectExecutor.js
var SubjectExecutor = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(queryRunner, subjects, options) {
    this.hasExecutableOperations = false;
    this.insertSubjects = [];
    this.updateSubjects = [];
    this.removeSubjects = [];
    this.softRemoveSubjects = [];
    this.recoverSubjects = [];
    this.queryRunner = queryRunner;
    this.allSubjects = subjects;
    this.options = options;
    this.validate();
    this.recompute();
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Executes all operations over given array of subjects.
   * Executes queries using given query runner.
   */
  execute() {
    return __async(this, null, function* () {
      let broadcasterResult = void 0;
      if (!this.options || this.options.listeners !== false) {
        broadcasterResult = this.broadcastBeforeEventsForAll();
        if (broadcasterResult.promises.length > 0) yield Promise.all(broadcasterResult.promises);
      }
      if (broadcasterResult && broadcasterResult.count > 0) {
        this.insertSubjects.forEach((subject) => subject.recompute());
        this.updateSubjects.forEach((subject) => subject.recompute());
        this.removeSubjects.forEach((subject) => subject.recompute());
        this.softRemoveSubjects.forEach((subject) => subject.recompute());
        this.recoverSubjects.forEach((subject) => subject.recompute());
        this.recompute();
      }
      this.insertSubjects = new SubjectTopologicalSorter(this.insertSubjects).sort("insert");
      yield this.executeInsertOperations();
      this.updateSubjects = this.allSubjects.filter((subject) => subject.mustBeUpdated);
      yield this.executeUpdateOperations();
      this.removeSubjects = new SubjectTopologicalSorter(this.removeSubjects).sort("delete");
      yield this.executeRemoveOperations();
      this.softRemoveSubjects = this.allSubjects.filter((subject) => subject.mustBeSoftRemoved);
      yield this.executeSoftRemoveOperations();
      this.recoverSubjects = this.allSubjects.filter((subject) => subject.mustBeRecovered);
      yield this.executeRecoverOperations();
      this.updateSpecialColumnsInPersistedEntities();
      if (!this.options || this.options.listeners !== false) {
        broadcasterResult = this.broadcastAfterEventsForAll();
        if (broadcasterResult.promises.length > 0) yield Promise.all(broadcasterResult.promises);
      }
    });
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Validates all given subjects.
   */
  validate() {
    this.allSubjects.forEach((subject) => {
      if (subject.mustBeUpdated && subject.mustBeRemoved) throw new SubjectRemovedAndUpdatedError(subject);
    });
  }
  /**
   * Performs entity re-computations - finds changed columns, re-builds insert/update/remove subjects.
   */
  recompute() {
    new SubjectChangedColumnsComputer().compute(this.allSubjects);
    this.insertSubjects = this.allSubjects.filter((subject) => subject.mustBeInserted);
    this.updateSubjects = this.allSubjects.filter((subject) => subject.mustBeUpdated);
    this.removeSubjects = this.allSubjects.filter((subject) => subject.mustBeRemoved);
    this.softRemoveSubjects = this.allSubjects.filter((subject) => subject.mustBeSoftRemoved);
    this.recoverSubjects = this.allSubjects.filter((subject) => subject.mustBeRecovered);
    this.hasExecutableOperations = this.insertSubjects.length > 0 || this.updateSubjects.length > 0 || this.removeSubjects.length > 0 || this.softRemoveSubjects.length > 0 || this.recoverSubjects.length > 0;
  }
  /**
   * Broadcasts "BEFORE_INSERT", "BEFORE_UPDATE", "BEFORE_REMOVE", "BEFORE_SOFT_REMOVE", "BEFORE_RECOVER" events for all given subjects.
   */
  broadcastBeforeEventsForAll() {
    const result = new BroadcasterResult();
    if (this.insertSubjects.length) this.insertSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastBeforeInsertEvent(result, subject.metadata, subject.entity));
    if (this.updateSubjects.length) this.updateSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations));
    if (this.removeSubjects.length) this.removeSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastBeforeRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
    if (this.softRemoveSubjects.length) this.softRemoveSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastBeforeSoftRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
    if (this.recoverSubjects.length) this.recoverSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastBeforeRecoverEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
    return result;
  }
  /**
   * Broadcasts "AFTER_INSERT", "AFTER_UPDATE", "AFTER_REMOVE", "AFTER_SOFT_REMOVE", "AFTER_RECOVER" events for all given subjects.
   * Returns void if there wasn't any listener or subscriber executed.
   * Note: this method has a performance-optimized code organization.
   */
  broadcastAfterEventsForAll() {
    const result = new BroadcasterResult();
    if (this.insertSubjects.length) this.insertSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastAfterInsertEvent(result, subject.metadata, subject.entity, subject.identifier));
    if (this.updateSubjects.length) this.updateSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations));
    if (this.removeSubjects.length) this.removeSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastAfterRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
    if (this.softRemoveSubjects.length) this.softRemoveSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastAfterSoftRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
    if (this.recoverSubjects.length) this.recoverSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastAfterRecoverEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
    return result;
  }
  /**
   * Executes insert operations.
   */
  executeInsertOperations() {
    return __async(this, null, function* () {
      const [groupedInsertSubjects, groupedInsertSubjectKeys] = this.groupBulkSubjects(this.insertSubjects, "insert");
      for (const groupName of groupedInsertSubjectKeys) {
        const subjects = groupedInsertSubjects[groupName];
        const bulkInsertMaps = [];
        const bulkInsertSubjects = [];
        const singleInsertSubjects = [];
        if (this.queryRunner.connection.driver.options.type === "mongodb") {
          subjects.forEach((subject) => {
            if (subject.metadata.createDateColumn && subject.entity) {
              subject.entity[subject.metadata.createDateColumn.databaseName] = /* @__PURE__ */ new Date();
            }
            if (subject.metadata.updateDateColumn && subject.entity) {
              subject.entity[subject.metadata.updateDateColumn.databaseName] = /* @__PURE__ */ new Date();
            }
            subject.createValueSetAndPopChangeMap();
            bulkInsertSubjects.push(subject);
            bulkInsertMaps.push(subject.entity);
          });
        } else if (this.queryRunner.connection.driver.options.type === "oracle") {
          subjects.forEach((subject) => {
            singleInsertSubjects.push(subject);
          });
        } else {
          subjects.forEach((subject) => {
            if (subject.changeMaps.length === 0 || subject.metadata.treeType || this.queryRunner.connection.driver.options.type === "oracle" || this.queryRunner.connection.driver.options.type === "sap") {
              singleInsertSubjects.push(subject);
            } else {
              bulkInsertSubjects.push(subject);
              bulkInsertMaps.push(subject.createValueSetAndPopChangeMap());
            }
          });
        }
        if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
          const insertResult = yield this.queryRunner.manager.insert(subjects[0].metadata.target, bulkInsertMaps);
          subjects.forEach((subject, index) => {
            subject.identifier = insertResult.identifiers[index];
            subject.generatedMap = insertResult.generatedMaps[index];
            subject.insertedValueSet = bulkInsertMaps[index];
          });
        } else {
          if (bulkInsertMaps.length > 0) {
            const insertResult = yield this.queryRunner.manager.createQueryBuilder().insert().into(subjects[0].metadata.target).values(bulkInsertMaps).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false).execute();
            bulkInsertSubjects.forEach((subject, index) => {
              subject.identifier = insertResult.identifiers[index];
              subject.generatedMap = insertResult.generatedMaps[index];
              subject.insertedValueSet = bulkInsertMaps[index];
            });
          }
          if (singleInsertSubjects.length > 0) {
            for (const subject of singleInsertSubjects) {
              subject.insertedValueSet = subject.createValueSetAndPopChangeMap();
              if (subject.metadata.treeType === "nested-set") yield new NestedSetSubjectExecutor(this.queryRunner).insert(subject);
              yield this.queryRunner.manager.createQueryBuilder().insert().into(subject.metadata.target).values(subject.insertedValueSet).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false).execute().then((insertResult) => {
                subject.identifier = insertResult.identifiers[0];
                subject.generatedMap = insertResult.generatedMaps[0];
              });
              if (subject.metadata.treeType === "closure-table") {
                yield new ClosureSubjectExecutor(this.queryRunner).insert(subject);
              } else if (subject.metadata.treeType === "materialized-path") {
                yield new MaterializedPathSubjectExecutor(this.queryRunner).insert(subject);
              }
            }
          }
        }
        subjects.forEach((subject) => {
          if (subject.generatedMap) {
            subject.metadata.columns.forEach((column) => {
              const value = column.getEntityValue(subject.generatedMap);
              if (value !== void 0 && value !== null) {
                const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);
                column.setEntityValue(subject.generatedMap, preparedValue);
              }
            });
          }
        });
      }
    });
  }
  /**
   * Updates all given subjects in the database.
   */
  executeUpdateOperations() {
    return __async(this, null, function* () {
      const updateSubject = (subject) => __async(this, null, function* () {
        if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);
        if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
          const partialEntity = this.cloneMongoSubjectEntity(subject);
          if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {
            delete partialEntity[subject.metadata.objectIdColumn.propertyName];
          }
          if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {
            delete partialEntity[subject.metadata.createDateColumn.propertyName];
          }
          if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {
            partialEntity[subject.metadata.updateDateColumn.propertyName] = /* @__PURE__ */ new Date();
          }
          const manager = this.queryRunner.manager;
          yield manager.update(subject.metadata.target, subject.identifier, partialEntity);
        } else {
          const updateMap = subject.createValueSetAndPopChangeMap();
          switch (subject.metadata.treeType) {
            case "nested-set":
              yield new NestedSetSubjectExecutor(this.queryRunner).update(subject);
              break;
            case "closure-table":
              yield new ClosureSubjectExecutor(this.queryRunner).update(subject);
              break;
            case "materialized-path":
              yield new MaterializedPathSubjectExecutor(this.queryRunner).update(subject);
              break;
          }
          const updateQueryBuilder = this.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set(updateMap).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);
          if (subject.entity) {
            updateQueryBuilder.whereEntity(subject.identifier);
          } else {
            updateQueryBuilder.where(subject.identifier);
          }
          const updateResult = yield updateQueryBuilder.execute();
          let updateGeneratedMap = updateResult.generatedMaps[0];
          if (updateGeneratedMap) {
            subject.metadata.columns.forEach((column) => {
              const value = column.getEntityValue(updateGeneratedMap);
              if (value !== void 0 && value !== null) {
                const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);
                column.setEntityValue(updateGeneratedMap, preparedValue);
              }
            });
            if (!subject.generatedMap) {
              subject.generatedMap = {};
            }
            Object.assign(subject.generatedMap, updateGeneratedMap);
          }
        }
      });
      const nestedSetSubjects = [];
      const remainingSubjects = [];
      for (const subject of this.updateSubjects) {
        if (subject.metadata.treeType === "nested-set") {
          nestedSetSubjects.push(subject);
        } else {
          remainingSubjects.push(subject);
        }
      }
      const nestedSetPromise = new Promise((ok, fail) => __async(this, null, function* () {
        for (const subject of nestedSetSubjects) {
          try {
            yield updateSubject(subject);
          } catch (error) {
            fail(error);
          }
        }
        ok();
      }));
      yield Promise.all([...remainingSubjects.map(updateSubject), nestedSetPromise]);
    });
  }
  /**
   * Removes all given subjects from the database.
   *
   * todo: we need to apply topological sort here as well
   */
  executeRemoveOperations() {
    return __async(this, null, function* () {
      const [groupedRemoveSubjects, groupedRemoveSubjectKeys] = this.groupBulkSubjects(this.removeSubjects, "delete");
      for (const groupName of groupedRemoveSubjectKeys) {
        const subjects = groupedRemoveSubjects[groupName];
        const deleteMaps = subjects.map((subject) => {
          if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);
          return subject.identifier;
        });
        if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
          const manager = this.queryRunner.manager;
          yield manager.delete(subjects[0].metadata.target, deleteMaps);
        } else {
          switch (subjects[0].metadata.treeType) {
            case "nested-set":
              yield new NestedSetSubjectExecutor(this.queryRunner).remove(subjects);
              break;
            case "closure-table":
              yield new ClosureSubjectExecutor(this.queryRunner).remove(subjects);
              break;
          }
          yield this.queryRunner.manager.createQueryBuilder().delete().from(subjects[0].metadata.target).where(deleteMaps).callListeners(false).execute();
        }
      }
    });
  }
  cloneMongoSubjectEntity(subject) {
    const target = {};
    if (subject.entity) {
      for (const column of subject.metadata.columns) {
        OrmUtils.mergeDeep(target, column.getEntityValueMap(subject.entity));
      }
    }
    return target;
  }
  /**
   * Soft-removes all given subjects in the database.
   */
  executeSoftRemoveOperations() {
    return __async(this, null, function* () {
      yield Promise.all(this.softRemoveSubjects.map((subject) => __async(this, null, function* () {
        if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);
        let updateResult;
        if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
          const partialEntity = this.cloneMongoSubjectEntity(subject);
          if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {
            delete partialEntity[subject.metadata.objectIdColumn.propertyName];
          }
          if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {
            delete partialEntity[subject.metadata.createDateColumn.propertyName];
          }
          if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {
            partialEntity[subject.metadata.updateDateColumn.propertyName] = /* @__PURE__ */ new Date();
          }
          if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {
            partialEntity[subject.metadata.deleteDateColumn.propertyName] = /* @__PURE__ */ new Date();
          }
          const manager = this.queryRunner.manager;
          updateResult = yield manager.update(subject.metadata.target, subject.identifier, partialEntity);
        } else {
          const softDeleteQueryBuilder = this.queryRunner.manager.createQueryBuilder().softDelete().from(subject.metadata.target).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);
          if (subject.entity) {
            softDeleteQueryBuilder.whereEntity(subject.identifier);
          } else {
            softDeleteQueryBuilder.where(subject.identifier);
          }
          updateResult = yield softDeleteQueryBuilder.execute();
        }
        subject.generatedMap = updateResult.generatedMaps[0];
        if (subject.generatedMap) {
          subject.metadata.columns.forEach((column) => {
            const value = column.getEntityValue(subject.generatedMap);
            if (value !== void 0 && value !== null) {
              const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);
              column.setEntityValue(subject.generatedMap, preparedValue);
            }
          });
        }
      })));
    });
  }
  /**
   * Recovers all given subjects in the database.
   */
  executeRecoverOperations() {
    return __async(this, null, function* () {
      yield Promise.all(this.recoverSubjects.map((subject) => __async(this, null, function* () {
        if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);
        let updateResult;
        if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
          const partialEntity = this.cloneMongoSubjectEntity(subject);
          if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {
            delete partialEntity[subject.metadata.objectIdColumn.propertyName];
          }
          if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {
            delete partialEntity[subject.metadata.createDateColumn.propertyName];
          }
          if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {
            partialEntity[subject.metadata.updateDateColumn.propertyName] = /* @__PURE__ */ new Date();
          }
          if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {
            partialEntity[subject.metadata.deleteDateColumn.propertyName] = null;
          }
          const manager = this.queryRunner.manager;
          updateResult = yield manager.update(subject.metadata.target, subject.identifier, partialEntity);
        } else {
          const softDeleteQueryBuilder = this.queryRunner.manager.createQueryBuilder().restore().from(subject.metadata.target).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);
          if (subject.entity) {
            softDeleteQueryBuilder.whereEntity(subject.identifier);
          } else {
            softDeleteQueryBuilder.where(subject.identifier);
          }
          updateResult = yield softDeleteQueryBuilder.execute();
        }
        subject.generatedMap = updateResult.generatedMaps[0];
        if (subject.generatedMap) {
          subject.metadata.columns.forEach((column) => {
            const value = column.getEntityValue(subject.generatedMap);
            if (value !== void 0 && value !== null) {
              const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);
              column.setEntityValue(subject.generatedMap, preparedValue);
            }
          });
        }
      })));
    });
  }
  /**
   * Updates all special columns of the saving entities (create date, update date, version, etc.).
   * Also updates nullable columns and columns with default values.
   */
  updateSpecialColumnsInPersistedEntities() {
    if (this.insertSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.insertSubjects);
    if (this.updateSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.updateSubjects);
    if (this.softRemoveSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.softRemoveSubjects);
    if (this.recoverSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.recoverSubjects);
    if (this.removeSubjects.length) {
      this.removeSubjects.forEach((subject) => {
        if (!subject.entity) return;
        subject.metadata.primaryColumns.forEach((primaryColumn) => {
          primaryColumn.setEntityValue(subject.entity, void 0);
        });
      });
    }
    this.allSubjects.forEach((subject) => {
      if (!subject.entity) return;
      subject.metadata.relationIds.forEach((relationId) => {
        relationId.setValue(subject.entity);
      });
      if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
        if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.databaseName && subject.metadata.objectIdColumn.databaseName !== subject.metadata.objectIdColumn.propertyName) {
          delete subject.entity[subject.metadata.objectIdColumn.databaseName];
        }
      }
    });
  }
  /**
   * Updates all special columns of the saving entities (create date, update date, version, etc.).
   * Also updates nullable columns and columns with default values.
   */
  updateSpecialColumnsInInsertedAndUpdatedEntities(subjects) {
    subjects.forEach((subject) => {
      if (!subject.entity) return;
      subject.metadata.columns.forEach((column) => {
        if (subject.metadata.childEntityMetadatas.length > 0 && subject.metadata.childEntityMetadatas.map((metadata) => metadata.target).indexOf(column.target) !== -1) return;
        if (column.isVirtual) return;
        if (column.isDeleteDate) return;
        if (column.isNullable) {
          const columnValue = column.getEntityValue(subject.entity);
          if (columnValue === void 0) column.setEntityValue(subject.entity, null);
        }
        if (subject.updatedRelationMaps.length > 0) {
          subject.updatedRelationMaps.forEach((updatedRelationMap) => {
            updatedRelationMap.relation.joinColumns.forEach((column2) => {
              if (column2.isVirtual === true) return;
              column2.setEntityValue(subject.entity, ObjectUtils.isObject(updatedRelationMap.value) ? column2.referencedColumn.getEntityValue(updatedRelationMap.value) : updatedRelationMap.value);
            });
          });
        }
      });
      if (subject.generatedMap) this.queryRunner.manager.merge(subject.metadata.target, subject.entity, subject.generatedMap);
    });
  }
  /**
   * Groups subjects by metadata names (by tables) to make bulk insertions and deletions possible.
   * However there are some limitations with bulk insertions of data into tables with generated (increment) columns
   * in some drivers. Some drivers like mysql and sqlite does not support returning multiple generated columns
   * after insertion and can only return a single generated column value, that's why its not possible to do bulk insertion,
   * because it breaks insertion result's generatedMap and leads to problems when this subject is used in other subjects saves.
   * That's why we only support bulking in junction tables for those drivers.
   *
   * Other drivers like postgres and sql server support RETURNING / OUTPUT statement which allows to return generated
   * id for each inserted row, that's why bulk insertion is not limited to junction tables in there.
   */
  groupBulkSubjects(subjects, type) {
    const group = {};
    const keys = [];
    const hasReturningDependColumns = subjects.some((subject) => {
      return subject.metadata.getInsertionReturningColumns().length > 0;
    });
    const groupingAllowed = type === "delete" || this.queryRunner.connection.driver.isReturningSqlSupported("insert") || hasReturningDependColumns === false;
    subjects.forEach((subject, index) => {
      const key = groupingAllowed || subject.metadata.isJunction ? subject.metadata.name : subject.metadata.name + "_" + index;
      if (!group[key]) {
        group[key] = [subject];
        keys.push(key);
      } else {
        group[key].push(subject);
      }
    });
    return [group, keys];
  }
};

// ../node_modules/typeorm/browser/persistence/Subject.js
var Subject = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(options) {
    this["@instanceof"] = Symbol.for("Subject");
    this.identifier = void 0;
    this.entityWithFulfilledIds = void 0;
    this.databaseEntityLoaded = false;
    this.changeMaps = [];
    this.canBeInserted = false;
    this.canBeUpdated = false;
    this.mustBeRemoved = false;
    this.canBeSoftRemoved = false;
    this.canBeRecovered = false;
    this.updatedRelationMaps = [];
    this.diffColumns = [];
    this.diffRelations = [];
    this.metadata = options.metadata;
    this.entity = options.entity;
    this.parentSubject = options.parentSubject;
    if (options.canBeInserted !== void 0) this.canBeInserted = options.canBeInserted;
    if (options.canBeUpdated !== void 0) this.canBeUpdated = options.canBeUpdated;
    if (options.mustBeRemoved !== void 0) this.mustBeRemoved = options.mustBeRemoved;
    if (options.canBeSoftRemoved !== void 0) this.canBeSoftRemoved = options.canBeSoftRemoved;
    if (options.canBeRecovered !== void 0) this.canBeRecovered = options.canBeRecovered;
    if (options.identifier !== void 0) this.identifier = options.identifier;
    if (options.changeMaps !== void 0) this.changeMaps.push(...options.changeMaps);
    this.recompute();
  }
  // -------------------------------------------------------------------------
  // Accessors
  // -------------------------------------------------------------------------
  /**
   * Checks if this subject must be inserted into the database.
   * Subject can be inserted into the database if it is allowed to be inserted (explicitly persisted or by cascades)
   * and if it does not have database entity set.
   */
  get mustBeInserted() {
    return this.canBeInserted && !this.databaseEntity;
  }
  /**
   * Checks if this subject must be updated into the database.
   * Subject can be updated in the database if it is allowed to be updated (explicitly persisted or by cascades)
   * and if it does have differentiated columns or relations.
   */
  get mustBeUpdated() {
    return this.canBeUpdated && this.identifier && (this.databaseEntityLoaded === false || this.databaseEntityLoaded && this.databaseEntity) && // ((this.entity && this.databaseEntity) || (!this.entity && !this.databaseEntity)) &&
    // ensure there are one or more changes for updatable columns
    this.changeMaps.some((change) => !change.column || change.column.isUpdate);
  }
  /**
   * Checks if this subject must be soft-removed into the database.
   * Subject can be updated in the database if it is allowed to be soft-removed (explicitly persisted or by cascades)
   * and if it does have differentiated columns or relations.
   */
  get mustBeSoftRemoved() {
    return this.canBeSoftRemoved && this.identifier && (this.databaseEntityLoaded === false || this.databaseEntityLoaded && this.databaseEntity);
  }
  /**
   * Checks if this subject must be recovered into the database.
   * Subject can be updated in the database if it is allowed to be recovered (explicitly persisted or by cascades)
   * and if it does have differentiated columns or relations.
   */
  get mustBeRecovered() {
    return this.canBeRecovered && this.identifier && (this.databaseEntityLoaded === false || this.databaseEntityLoaded && this.databaseEntity);
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates a value set needs to be inserted / updated in the database.
   * Value set is based on the entity and change maps of the subject.
   * Important note: this method pops data from this subject's change maps.
   */
  createValueSetAndPopChangeMap() {
    const changeMapsWithoutValues = [];
    const changeSet = this.changeMaps.reduce((updateMap, changeMap) => {
      let value = changeMap.value;
      if (InstanceChecker.isSubject(value)) {
        value = value.insertedValueSet ? value.insertedValueSet : value.entity;
      }
      let valueMap;
      if (this.metadata.isJunction && changeMap.column) {
        valueMap = changeMap.column.createValueMap(changeMap.column.referencedColumn.getEntityValue(value));
      } else if (changeMap.column) {
        valueMap = changeMap.column.createValueMap(value);
      } else if (changeMap.relation) {
        if (ObjectUtils.isObject(value) && !Buffer.isBuffer(value)) {
          const relationId = changeMap.relation.getRelationIdMap(value);
          if (relationId === void 0) {
            changeMapsWithoutValues.push(changeMap);
            this.canBeUpdated = true;
            return updateMap;
          }
          valueMap = changeMap.relation.createValueMap(relationId);
          this.updatedRelationMaps.push({
            relation: changeMap.relation,
            value: relationId
          });
        } else {
          valueMap = changeMap.relation.createValueMap(value);
          this.updatedRelationMaps.push({
            relation: changeMap.relation,
            value
          });
        }
      }
      OrmUtils.mergeDeep(updateMap, valueMap);
      return updateMap;
    }, {});
    this.changeMaps = changeMapsWithoutValues;
    return changeSet;
  }
  /**
   * Recomputes entityWithFulfilledIds and identifier when entity changes.
   */
  recompute() {
    if (this.entity) {
      this.entityWithFulfilledIds = Object.assign({}, this.entity);
      if (this.parentSubject) {
        this.metadata.primaryColumns.forEach((primaryColumn) => {
          if (primaryColumn.relationMetadata && primaryColumn.relationMetadata.inverseEntityMetadata === this.parentSubject.metadata) {
            const value = primaryColumn.referencedColumn.getEntityValue(this.parentSubject.entity);
            primaryColumn.setEntityValue(this.entityWithFulfilledIds, value);
          }
        });
      }
      this.identifier = this.metadata.getEntityIdMap(this.entityWithFulfilledIds);
    } else if (this.databaseEntity) {
      this.identifier = this.metadata.getEntityIdMap(this.databaseEntity);
    }
  }
};

// ../node_modules/typeorm/browser/persistence/subject-builder/OneToManySubjectBuilder.js
var OneToManySubjectBuilder = class {
  // ---------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------
  constructor(subjects) {
    this.subjects = subjects;
  }
  // ---------------------------------------------------------------------
  // Public Methods
  // ---------------------------------------------------------------------
  /**
   * Builds all required operations.
   */
  build() {
    this.subjects.forEach((subject) => {
      subject.metadata.oneToManyRelations.forEach((relation) => {
        if (relation.persistenceEnabled === false) return;
        this.buildForSubjectRelation(subject, relation);
      });
    });
  }
  // ---------------------------------------------------------------------
  // Protected Methods
  // ---------------------------------------------------------------------
  /**
   * Builds operations for a given subject and relation.
   *
   * by example: subject is "post" entity we are saving here and relation is "categories" inside it here.
   */
  buildForSubjectRelation(subject, relation) {
    let relatedEntityDatabaseRelationIds = [];
    if (subject.databaseEntity) {
      const relatedEntityDatabaseRelation = relation.getEntityValue(subject.databaseEntity);
      if (relatedEntityDatabaseRelation) {
        relatedEntityDatabaseRelationIds = relatedEntityDatabaseRelation.map((entity) => relation.inverseEntityMetadata.getEntityIdMap(entity));
      }
    }
    let relatedEntities = relation.getEntityValue(subject.entity);
    if (relatedEntities === null)
      relatedEntities = [];
    if (relatedEntities === void 0)
      return;
    const relatedPersistedEntityRelationIds = [];
    relatedEntities.forEach((relatedEntity) => {
      let relationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity);
      let relatedEntitySubject = this.subjects.find((subject2) => {
        return subject2.entity === relatedEntity;
      });
      if (relatedEntitySubject) relationIdMap = relatedEntitySubject.identifier;
      if (!relationIdMap) {
        if (!relatedEntitySubject) return;
        relatedEntitySubject.changeMaps.push({
          relation: relation.inverseRelation,
          value: subject
        });
        return;
      }
      const relationIdInDatabaseSubjectRelation = relatedEntityDatabaseRelationIds.find((relatedDatabaseEntityRelationId) => {
        return OrmUtils.compareIds(relationIdMap, relatedDatabaseEntityRelationId);
      });
      if (!relationIdInDatabaseSubjectRelation) {
        if (!relatedEntitySubject) {
          relatedEntitySubject = new Subject({
            metadata: relation.inverseEntityMetadata,
            parentSubject: subject,
            canBeUpdated: true,
            identifier: relationIdMap
          });
          this.subjects.push(relatedEntitySubject);
        }
        relatedEntitySubject.changeMaps.push({
          relation: relation.inverseRelation,
          value: subject
        });
      }
      relatedPersistedEntityRelationIds.push(relationIdMap);
    });
    if (relation.inverseRelation?.orphanedRowAction !== "disable") {
      EntityMetadata.difference(relatedEntityDatabaseRelationIds, relatedPersistedEntityRelationIds).forEach((removedRelatedEntityRelationId) => {
        const removedRelatedEntitySubject = new Subject({
          metadata: relation.inverseEntityMetadata,
          parentSubject: subject,
          identifier: removedRelatedEntityRelationId
        });
        if (!relation.inverseRelation || relation.inverseRelation.orphanedRowAction === "nullify") {
          removedRelatedEntitySubject.canBeUpdated = true;
          removedRelatedEntitySubject.changeMaps = [{
            relation: relation.inverseRelation,
            value: null
          }];
        } else if (relation.inverseRelation.orphanedRowAction === "delete") {
          removedRelatedEntitySubject.mustBeRemoved = true;
        } else if (relation.inverseRelation.orphanedRowAction === "soft-delete") {
          removedRelatedEntitySubject.canBeSoftRemoved = true;
        }
        this.subjects.push(removedRelatedEntitySubject);
      });
    }
  }
};

// ../node_modules/typeorm/browser/persistence/subject-builder/OneToOneInverseSideSubjectBuilder.js
var OneToOneInverseSideSubjectBuilder = class {
  // ---------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------
  constructor(subjects) {
    this.subjects = subjects;
  }
  // ---------------------------------------------------------------------
  // Public Methods
  // ---------------------------------------------------------------------
  /**
   * Builds all required operations.
   */
  build() {
    this.subjects.forEach((subject) => {
      subject.metadata.oneToOneRelations.forEach((relation) => {
        if (relation.isOwning || relation.persistenceEnabled === false) return;
        this.buildForSubjectRelation(subject, relation);
      });
    });
  }
  // ---------------------------------------------------------------------
  // Protected Methods
  // ---------------------------------------------------------------------
  /**
   * Builds operations for a given subject and relation.
   *
   * by example: subject is "post" entity we are saving here and relation is "category" inside it here.
   */
  buildForSubjectRelation(subject, relation) {
    let relatedEntityDatabaseRelationId = void 0;
    if (subject.databaseEntity)
      relatedEntityDatabaseRelationId = relation.getEntityValue(subject.databaseEntity);
    let relatedEntity = relation.getEntityValue(subject.entity);
    if (relatedEntity === void 0)
      return;
    if (relatedEntity === null) {
      if (relatedEntityDatabaseRelationId) {
        const removedRelatedEntitySubject = new Subject({
          metadata: relation.inverseEntityMetadata,
          parentSubject: subject,
          canBeUpdated: true,
          identifier: relatedEntityDatabaseRelationId,
          changeMaps: [{
            relation: relation.inverseRelation,
            value: null
          }]
        });
        this.subjects.push(removedRelatedEntitySubject);
      }
      return;
    }
    let relationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity);
    let relatedEntitySubject = this.subjects.find((operateSubject) => {
      return !!operateSubject.entity && operateSubject.entity === relatedEntity;
    });
    if (relatedEntitySubject) relationIdMap = relatedEntitySubject.identifier;
    if (!relationIdMap) {
      if (!relatedEntitySubject) return;
      relatedEntitySubject.changeMaps.push({
        relation: relation.inverseRelation,
        value: subject
      });
    }
    const areRelatedIdEqualWithDatabase = relatedEntityDatabaseRelationId && OrmUtils.compareIds(relationIdMap, relatedEntityDatabaseRelationId);
    if (!areRelatedIdEqualWithDatabase) {
      if (!relatedEntitySubject) {
        relatedEntitySubject = new Subject({
          metadata: relation.inverseEntityMetadata,
          canBeUpdated: true,
          identifier: relationIdMap
        });
        this.subjects.push(relatedEntitySubject);
      }
      relatedEntitySubject.changeMaps.push({
        relation: relation.inverseRelation,
        value: subject
      });
    }
  }
};

// ../node_modules/typeorm/browser/persistence/subject-builder/ManyToManySubjectBuilder.js
var ManyToManySubjectBuilder = class {
  // ---------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------
  constructor(subjects) {
    this.subjects = subjects;
  }
  // ---------------------------------------------------------------------
  // Public Methods
  // ---------------------------------------------------------------------
  /**
   * Builds operations for any changes in the many-to-many relations of the subjects.
   */
  build() {
    this.subjects.forEach((subject) => {
      if (!subject.entity) return;
      subject.metadata.manyToManyRelations.forEach((relation) => {
        if (relation.persistenceEnabled === false) return;
        this.buildForSubjectRelation(subject, relation);
      });
    });
  }
  /**
   * Builds operations for removal of all many-to-many records of all many-to-many relations of the given subject.
   */
  buildForAllRemoval(subject) {
    if (!subject.databaseEntity) return;
    subject.metadata.manyToManyRelations.forEach((relation) => {
      if (relation.persistenceEnabled === false) return;
      const relatedEntityRelationIdsInDatabase = relation.getEntityValue(subject.databaseEntity);
      relatedEntityRelationIdsInDatabase.forEach((relationId) => {
        const junctionSubject = new Subject({
          metadata: relation.junctionEntityMetadata,
          parentSubject: subject,
          mustBeRemoved: true,
          identifier: this.buildJunctionIdentifier(subject, relation, relationId)
        });
        this.subjects.push(junctionSubject);
      });
    });
  }
  // ---------------------------------------------------------------------
  // Protected Methods
  // ---------------------------------------------------------------------
  /**
   * Builds operations for a given subject and relation.
   *
   * by example: subject is "post" entity we are saving here and relation is "categories" inside it here.
   */
  buildForSubjectRelation(subject, relation) {
    let databaseRelatedEntityIds = [];
    if (subject.databaseEntity) {
      const databaseRelatedEntityValue = relation.getEntityValue(subject.databaseEntity);
      if (databaseRelatedEntityValue) {
        databaseRelatedEntityIds = databaseRelatedEntityValue.map((e) => relation.inverseEntityMetadata.getEntityIdMap(e));
      }
    }
    let relatedEntities = relation.getEntityValue(subject.entity);
    if (relatedEntities === null)
      relatedEntities = [];
    if (!Array.isArray(relatedEntities)) return;
    relatedEntities.forEach((relatedEntity) => {
      let relatedEntityRelationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity);
      const relatedEntitySubject = this.subjects.find((subject2) => {
        return subject2.entity === relatedEntity;
      });
      if (relatedEntitySubject) relatedEntityRelationIdMap = relatedEntitySubject.identifier;
      if (!relatedEntityRelationIdMap) {
        if (!relatedEntitySubject) return;
      }
      const relatedEntityExistInDatabase = databaseRelatedEntityIds.find((databaseRelatedEntityRelationId) => {
        return OrmUtils.compareIds(databaseRelatedEntityRelationId, relatedEntityRelationIdMap);
      });
      if (relatedEntityExistInDatabase) return;
      const ownerValue = relation.isOwning ? subject : relatedEntitySubject || relatedEntity;
      const inverseValue = relation.isOwning ? relatedEntitySubject || relatedEntity : subject;
      const junctionSubject = new Subject({
        metadata: relation.junctionEntityMetadata,
        parentSubject: subject,
        canBeInserted: true
      });
      this.subjects.push(junctionSubject);
      relation.junctionEntityMetadata.ownerColumns.forEach((column) => {
        junctionSubject.changeMaps.push({
          column,
          value: ownerValue
          // valueFactory: (value) => column.referencedColumn!.getEntityValue(value) // column.referencedColumn!.getEntityValue(ownerEntityMap),
        });
      });
      relation.junctionEntityMetadata.inverseColumns.forEach((column) => {
        junctionSubject.changeMaps.push({
          column,
          value: inverseValue
          // valueFactory: (value) => column.referencedColumn!.getEntityValue(value) // column.referencedColumn!.getEntityValue(inverseEntityMap),
        });
      });
    });
    const changedInverseEntityRelationIds = [];
    relatedEntities.forEach((relatedEntity) => {
      let relatedEntityRelationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity);
      const relatedEntitySubject = this.subjects.find((subject2) => {
        return subject2.entity === relatedEntity;
      });
      if (relatedEntitySubject) relatedEntityRelationIdMap = relatedEntitySubject.identifier;
      if (relatedEntityRelationIdMap !== void 0 && relatedEntityRelationIdMap !== null) changedInverseEntityRelationIds.push(relatedEntityRelationIdMap);
    });
    const removedJunctionEntityIds = databaseRelatedEntityIds.filter((existRelationId) => {
      return !changedInverseEntityRelationIds.find((changedRelationId) => {
        return OrmUtils.compareIds(changedRelationId, existRelationId);
      });
    });
    removedJunctionEntityIds.forEach((removedEntityRelationId) => {
      const junctionSubject = new Subject({
        metadata: relation.junctionEntityMetadata,
        parentSubject: subject,
        mustBeRemoved: true,
        identifier: this.buildJunctionIdentifier(subject, relation, removedEntityRelationId)
      });
      this.subjects.push(junctionSubject);
    });
  }
  /**
   * Creates identifiers for junction table.
   * Example: { postId: 1, categoryId: 2 }
   */
  buildJunctionIdentifier(subject, relation, relationId) {
    const ownerEntityMap = relation.isOwning ? subject.entity : relationId;
    const inverseEntityMap = relation.isOwning ? relationId : subject.entity;
    const identifier = {};
    relation.junctionEntityMetadata.ownerColumns.forEach((column) => {
      OrmUtils.mergeDeep(identifier, column.createValueMap(column.referencedColumn.getEntityValue(ownerEntityMap)));
    });
    relation.junctionEntityMetadata.inverseColumns.forEach((column) => {
      OrmUtils.mergeDeep(identifier, column.createValueMap(column.referencedColumn.getEntityValue(inverseEntityMap)));
    });
    return identifier;
  }
};

// ../node_modules/typeorm/browser/persistence/SubjectDatabaseEntityLoader.js
var SubjectDatabaseEntityLoader = class {
  // ---------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------
  constructor(queryRunner, subjects) {
    this.queryRunner = queryRunner;
    this.subjects = subjects;
  }
  // ---------------------------------------------------------------------
  // Public Methods
  // ---------------------------------------------------------------------
  /**
   * Loads database entities for all subjects.
   *
   * loadAllRelations flag is used to load all relation ids of the object, no matter if they present in subject entity or not.
   * This option is used for deletion.
   */
  load(operationType) {
    return __async(this, null, function* () {
      const promises = this.groupByEntityTargets().map((subjectGroup) => __async(this, null, function* () {
        const allIds = [];
        const allSubjects = [];
        subjectGroup.subjects.forEach((subject) => {
          if (subject.databaseEntity || !subject.identifier) return;
          allIds.push(subject.identifier);
          allSubjects.push(subject);
        });
        if (!allIds.length) return;
        const loadRelationPropertyPaths = [];
        if (operationType === "save" || operationType === "soft-remove" || operationType === "recover") {
          subjectGroup.subjects.forEach((subject) => {
            subject.metadata.relations.forEach((relation) => {
              const value = relation.getEntityValue(subject.entityWithFulfilledIds);
              if (value === void 0) return;
              if (loadRelationPropertyPaths.indexOf(relation.propertyPath) === -1) loadRelationPropertyPaths.push(relation.propertyPath);
            });
          });
        } else {
          loadRelationPropertyPaths.push(...subjectGroup.subjects[0].metadata.manyToManyRelations.map((relation) => relation.propertyPath));
        }
        const findOptions = {
          loadEagerRelations: false,
          loadRelationIds: {
            relations: loadRelationPropertyPaths,
            disableMixedMap: true
          },
          // the soft-deleted entities should be included in the loaded entities for recover operation
          withDeleted: true
        };
        let entities = [];
        if (this.queryRunner.connection.driver.options.type === "mongodb") {
          const mongoRepo = this.queryRunner.manager.getRepository(subjectGroup.target);
          entities = yield mongoRepo.findByIds(allIds, findOptions);
        } else {
          entities = yield this.queryRunner.manager.getRepository(subjectGroup.target).createQueryBuilder().setFindOptions(findOptions).whereInIds(allIds).getMany();
        }
        entities.forEach((entity) => {
          const subjects = this.findByPersistEntityLike(subjectGroup.target, entity);
          subjects.forEach((subject) => {
            subject.databaseEntity = entity;
            if (!subject.identifier) subject.identifier = subject.metadata.hasAllPrimaryKeys(entity) ? subject.metadata.getEntityIdMap(entity) : void 0;
          });
        });
        for (let subject of allSubjects) {
          subject.databaseEntityLoaded = true;
        }
      }));
      yield Promise.all(promises);
    });
  }
  // ---------------------------------------------------------------------
  // Protected Methods
  // ---------------------------------------------------------------------
  /**
   * Finds subjects where entity like given subject's entity.
   * Comparison made by entity id.
   * Multiple subjects may be returned if duplicates are present in the subject array.
   * This will likely result in the same row being updated multiple times during a transaction.
   */
  findByPersistEntityLike(entityTarget, entity) {
    return this.subjects.filter((subject) => {
      if (!subject.entity) return false;
      if (subject.entity === entity) return true;
      return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entityWithFulfilledIds, entity);
    });
  }
  /**
   * Groups given Subject objects into groups separated by entity targets.
   */
  groupByEntityTargets() {
    return this.subjects.reduce((groups, operatedEntity) => {
      let group = groups.find((group2) => group2.target === operatedEntity.metadata.target);
      if (!group) {
        group = {
          target: operatedEntity.metadata.target,
          subjects: []
        };
        groups.push(group);
      }
      group.subjects.push(operatedEntity);
      return groups;
    }, []);
  }
};

// ../node_modules/typeorm/browser/persistence/subject-builder/CascadesSubjectBuilder.js
var CascadesSubjectBuilder = class {
  // ---------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------
  constructor(allSubjects) {
    this.allSubjects = allSubjects;
  }
  // ---------------------------------------------------------------------
  // Public Methods
  // ---------------------------------------------------------------------
  /**
   * Builds a cascade subjects tree and pushes them in into the given array of subjects.
   */
  build(subject, operationType) {
    subject.metadata.extractRelationValuesFromEntity(subject.entity, subject.metadata.relations).forEach(([relation, relationEntity, relationEntityMetadata]) => {
      if (relationEntity === void 0 || relationEntity === null || !relation.isCascadeInsert && !relation.isCascadeUpdate && !relation.isCascadeSoftRemove && !relation.isCascadeRecover) return;
      if (!ObjectUtils.isObject(relationEntity)) return;
      const alreadyExistRelationEntitySubject = this.findByPersistEntityLike(relationEntityMetadata.target, relationEntity);
      if (alreadyExistRelationEntitySubject) {
        if (alreadyExistRelationEntitySubject.canBeInserted === false)
          alreadyExistRelationEntitySubject.canBeInserted = relation.isCascadeInsert === true && operationType === "save";
        if (alreadyExistRelationEntitySubject.canBeUpdated === false)
          alreadyExistRelationEntitySubject.canBeUpdated = relation.isCascadeUpdate === true && operationType === "save";
        if (alreadyExistRelationEntitySubject.canBeSoftRemoved === false)
          alreadyExistRelationEntitySubject.canBeSoftRemoved = relation.isCascadeSoftRemove === true && operationType === "soft-remove";
        if (alreadyExistRelationEntitySubject.canBeRecovered === false)
          alreadyExistRelationEntitySubject.canBeRecovered = relation.isCascadeRecover === true && operationType === "recover";
        return;
      }
      const relationEntitySubject = new Subject({
        metadata: relationEntityMetadata,
        parentSubject: subject,
        entity: relationEntity,
        canBeInserted: relation.isCascadeInsert === true && operationType === "save",
        canBeUpdated: relation.isCascadeUpdate === true && operationType === "save",
        canBeSoftRemoved: relation.isCascadeSoftRemove === true && operationType === "soft-remove",
        canBeRecovered: relation.isCascadeRecover === true && operationType === "recover"
      });
      this.allSubjects.push(relationEntitySubject);
      this.build(relationEntitySubject, operationType);
    });
  }
  // ---------------------------------------------------------------------
  // Protected Methods
  // ---------------------------------------------------------------------
  /**
   * Finds subject where entity like given subject's entity.
   * Comparison made by entity id.
   */
  findByPersistEntityLike(entityTarget, entity) {
    return this.allSubjects.find((subject) => {
      if (!subject.entity) return false;
      if (subject.entity === entity) return true;
      return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entityWithFulfilledIds, entity);
    });
  }
};

// ../node_modules/typeorm/browser/persistence/EntityPersistExecutor.js
var EntityPersistExecutor = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection, queryRunner, mode, target, entity, options) {
    this.connection = connection;
    this.queryRunner = queryRunner;
    this.mode = mode;
    this.target = target;
    this.entity = entity;
    this.options = options;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Executes persistence operation ob given entity or entities.
   */
  execute() {
    return __async(this, null, function* () {
      if (!this.entity || typeof this.entity !== "object") return Promise.reject(new MustBeEntityError(this.mode, this.entity));
      yield Promise.resolve();
      const queryRunner = this.queryRunner || this.connection.createQueryRunner();
      let oldQueryRunnerData = queryRunner.data;
      if (this.options && this.options.data) {
        queryRunner.data = this.options.data;
      }
      try {
        const entities = Array.isArray(this.entity) ? this.entity : [this.entity];
        const entitiesInChunks = this.options && this.options.chunk && this.options.chunk > 0 ? OrmUtils.chunk(entities, this.options.chunk) : [entities];
        const executors = yield Promise.all(entitiesInChunks.map((entities2) => __async(this, null, function* () {
          const subjects = [];
          entities2.forEach((entity) => {
            const entityTarget = this.target ? this.target : entity.constructor;
            if (entityTarget === Object) throw new CannotDetermineEntityError(this.mode);
            let metadata = this.connection.getMetadata(entityTarget).findInheritanceMetadata(entity);
            subjects.push(new Subject({
              metadata,
              entity,
              canBeInserted: this.mode === "save",
              canBeUpdated: this.mode === "save",
              mustBeRemoved: this.mode === "remove",
              canBeSoftRemoved: this.mode === "soft-remove",
              canBeRecovered: this.mode === "recover"
            }));
          });
          const cascadesSubjectBuilder = new CascadesSubjectBuilder(subjects);
          subjects.forEach((subject) => {
            cascadesSubjectBuilder.build(subject, this.mode);
          });
          yield new SubjectDatabaseEntityLoader(queryRunner, subjects).load(this.mode);
          if (this.mode === "save" || this.mode === "soft-remove" || this.mode === "recover") {
            new OneToManySubjectBuilder(subjects).build();
            new OneToOneInverseSideSubjectBuilder(subjects).build();
            new ManyToManySubjectBuilder(subjects).build();
          } else {
            subjects.forEach((subject) => {
              if (subject.mustBeRemoved) {
                new ManyToManySubjectBuilder(subjects).buildForAllRemoval(subject);
              }
            });
          }
          return new SubjectExecutor(queryRunner, subjects, this.options);
        })));
        const executorsWithExecutableOperations = executors.filter((executor) => executor.hasExecutableOperations);
        if (executorsWithExecutableOperations.length === 0) return;
        let isTransactionStartedByUs = false;
        try {
          if (!queryRunner.isTransactionActive) {
            if (this.connection.driver.transactionSupport !== "none" && (!this.options || this.options.transaction !== false)) {
              isTransactionStartedByUs = true;
              yield queryRunner.startTransaction();
            }
          }
          for (const executor of executorsWithExecutableOperations) {
            yield executor.execute();
          }
          if (isTransactionStartedByUs === true) yield queryRunner.commitTransaction();
        } catch (error) {
          if (isTransactionStartedByUs) {
            try {
              yield queryRunner.rollbackTransaction();
            } catch (rollbackError) {
            }
          }
          throw error;
        }
      } finally {
        queryRunner.data = oldQueryRunnerData;
        if (!this.queryRunner) yield queryRunner.release();
      }
    });
  }
};

// ../node_modules/typeorm/browser/entity-manager/EntityManager.js
var EntityManager = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection, queryRunner) {
    this["@instanceof"] = Symbol.for("EntityManager");
    this.repositories = /* @__PURE__ */ new Map();
    this.treeRepositories = [];
    this.plainObjectToEntityTransformer = new PlainObjectToNewEntityTransformer();
    this.connection = connection;
    if (queryRunner) {
      this.queryRunner = queryRunner;
      ObjectUtils.assign(this.queryRunner, {
        manager: this
      });
    }
  }
  /**
   * Wraps given function execution (and all operations made there) in a transaction.
   * All database operations must be executed using provided entity manager.
   */
  transaction(isolationOrRunInTransaction, runInTransactionParam) {
    return __async(this, null, function* () {
      const isolation = typeof isolationOrRunInTransaction === "string" ? isolationOrRunInTransaction : void 0;
      const runInTransaction = typeof isolationOrRunInTransaction === "function" ? isolationOrRunInTransaction : runInTransactionParam;
      if (!runInTransaction) {
        throw new TypeORMError(`Transaction method requires callback in second parameter if isolation level is supplied.`);
      }
      if (this.queryRunner && this.queryRunner.isReleased) throw new QueryRunnerProviderAlreadyReleasedError();
      const queryRunner = this.queryRunner || this.connection.createQueryRunner();
      try {
        yield queryRunner.startTransaction(isolation);
        const result = yield runInTransaction(queryRunner.manager);
        yield queryRunner.commitTransaction();
        return result;
      } catch (err) {
        try {
          yield queryRunner.rollbackTransaction();
        } catch (rollbackError) {
        }
        throw err;
      } finally {
        if (!this.queryRunner)
          yield queryRunner.release();
      }
    });
  }
  /**
   * Executes raw SQL query and returns raw database results.
   *
   * @see [Official docs](https://typeorm.io/entity-manager-api) for examples.
   */
  query(query, parameters) {
    return __async(this, null, function* () {
      return this.connection.query(query, parameters, this.queryRunner);
    });
  }
  /**
   * Creates a new query builder that can be used to build a SQL query.
   */
  createQueryBuilder(entityClass, alias, queryRunner) {
    if (alias) {
      return this.connection.createQueryBuilder(entityClass, alias, queryRunner || this.queryRunner);
    } else {
      return this.connection.createQueryBuilder(entityClass || queryRunner || this.queryRunner);
    }
  }
  /**
   * Checks if entity has an id by its Function type or schema name.
   */
  hasId(targetOrEntity, maybeEntity) {
    const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;
    const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;
    const metadata = this.connection.getMetadata(target);
    return metadata.hasId(entity);
  }
  /**
   * Gets entity mixed id.
   */
  getId(targetOrEntity, maybeEntity) {
    const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;
    const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;
    const metadata = this.connection.getMetadata(target);
    return metadata.getEntityIdMixedMap(entity);
  }
  /**
   * Creates a new entity instance or instances.
   * Can copy properties from the given object into new entities.
   */
  create(entityClass, plainObjectOrObjects) {
    const metadata = this.connection.getMetadata(entityClass);
    if (!plainObjectOrObjects) return metadata.create(this.queryRunner);
    if (Array.isArray(plainObjectOrObjects)) return plainObjectOrObjects.map((plainEntityLike) => this.create(entityClass, plainEntityLike));
    const mergeIntoEntity = metadata.create(this.queryRunner);
    this.plainObjectToEntityTransformer.transform(mergeIntoEntity, plainObjectOrObjects, metadata, true);
    return mergeIntoEntity;
  }
  /**
   * Merges two entities into one new entity.
   */
  merge(entityClass, mergeIntoEntity, ...entityLikes) {
    const metadata = this.connection.getMetadata(entityClass);
    entityLikes.forEach((object) => this.plainObjectToEntityTransformer.transform(mergeIntoEntity, object, metadata));
    return mergeIntoEntity;
  }
  /**
   * Creates a new entity from the given plain javascript object. If entity already exist in the database, then
   * it loads it (and everything related to it), replaces all values with the new ones from the given object
   * and returns this new entity. This new entity is actually a loaded from the db entity with all properties
   * replaced from the new object.
   */
  preload(entityClass, entityLike) {
    return __async(this, null, function* () {
      const metadata = this.connection.getMetadata(entityClass);
      const plainObjectToDatabaseEntityTransformer = new PlainObjectToDatabaseEntityTransformer(this.connection.manager);
      const transformedEntity = yield plainObjectToDatabaseEntityTransformer.transform(entityLike, metadata);
      if (transformedEntity) return this.merge(entityClass, transformedEntity, entityLike);
      return void 0;
    });
  }
  /**
   * Saves a given entity in the database.
   */
  save(targetOrEntity, maybeEntityOrOptions, maybeOptions) {
    let target = arguments.length > 1 && (typeof targetOrEntity === "function" || InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === "string") ? targetOrEntity : void 0;
    const entity = target ? maybeEntityOrOptions : targetOrEntity;
    const options = target ? maybeOptions : maybeEntityOrOptions;
    if (InstanceChecker.isEntitySchema(target)) target = target.options.name;
    if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity);
    return new EntityPersistExecutor(this.connection, this.queryRunner, "save", target, entity, options).execute().then(() => entity);
  }
  /**
   * Removes a given entity from the database.
   */
  remove(targetOrEntity, maybeEntityOrOptions, maybeOptions) {
    const target = arguments.length > 1 && (typeof targetOrEntity === "function" || InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === "string") ? targetOrEntity : void 0;
    const entity = target ? maybeEntityOrOptions : targetOrEntity;
    const options = target ? maybeOptions : maybeEntityOrOptions;
    if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity);
    return new EntityPersistExecutor(this.connection, this.queryRunner, "remove", target, entity, options).execute().then(() => entity);
  }
  /**
   * Records the delete date of one or many given entities.
   */
  softRemove(targetOrEntity, maybeEntityOrOptions, maybeOptions) {
    let target = arguments.length > 1 && (typeof targetOrEntity === "function" || InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === "string") ? targetOrEntity : void 0;
    const entity = target ? maybeEntityOrOptions : targetOrEntity;
    const options = target ? maybeOptions : maybeEntityOrOptions;
    if (InstanceChecker.isEntitySchema(target)) target = target.options.name;
    if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity);
    return new EntityPersistExecutor(this.connection, this.queryRunner, "soft-remove", target, entity, options).execute().then(() => entity);
  }
  /**
   * Recovers one or many given entities.
   */
  recover(targetOrEntity, maybeEntityOrOptions, maybeOptions) {
    let target = arguments.length > 1 && (typeof targetOrEntity === "function" || InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === "string") ? targetOrEntity : void 0;
    const entity = target ? maybeEntityOrOptions : targetOrEntity;
    const options = target ? maybeOptions : maybeEntityOrOptions;
    if (InstanceChecker.isEntitySchema(target)) target = target.options.name;
    if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity);
    return new EntityPersistExecutor(this.connection, this.queryRunner, "recover", target, entity, options).execute().then(() => entity);
  }
  /**
   * Inserts a given entity into the database.
   * Unlike save method executes a primitive operation without cascades, relations and other operations included.
   * Executes fast and efficient INSERT query.
   * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.
   * You can execute bulk inserts using this method.
   */
  insert(target, entity) {
    return __async(this, null, function* () {
      return this.createQueryBuilder().insert().into(target).values(entity).execute();
    });
  }
  upsert(target, entityOrEntities, conflictPathsOrOptions) {
    return __async(this, null, function* () {
      const metadata = this.connection.getMetadata(target);
      let options;
      if (Array.isArray(conflictPathsOrOptions)) {
        options = {
          conflictPaths: conflictPathsOrOptions
        };
      } else {
        options = conflictPathsOrOptions;
      }
      let entities;
      if (!Array.isArray(entityOrEntities)) {
        entities = [entityOrEntities];
      } else {
        entities = entityOrEntities;
      }
      const conflictColumns = metadata.mapPropertyPathsToColumns(Array.isArray(options.conflictPaths) ? options.conflictPaths : Object.keys(options.conflictPaths));
      const overwriteColumns = metadata.columns.filter((col) => !conflictColumns.includes(col) && entities.some((entity) => typeof col.getEntityValue(entity) !== "undefined"));
      return this.createQueryBuilder().insert().into(target).values(entities).orUpdate([...conflictColumns, ...overwriteColumns].map((col) => col.databaseName), conflictColumns.map((col) => col.databaseName), {
        skipUpdateIfNoValuesChanged: options.skipUpdateIfNoValuesChanged,
        indexPredicate: options.indexPredicate,
        upsertType: options.upsertType || this.connection.driver.supportedUpsertTypes[0]
      }).execute();
    });
  }
  /**
   * Updates entity partially. Entity can be found by a given condition(s).
   * Unlike save method executes a primitive operation without cascades, relations and other operations included.
   * Executes fast and efficient UPDATE query.
   * Does not check if entity exist in the database.
   * Condition(s) cannot be empty.
   */
  update(target, criteria, partialEntity) {
    if (criteria === void 0 || criteria === null || criteria === "" || Array.isArray(criteria) && criteria.length === 0) {
      return Promise.reject(new TypeORMError(`Empty criteria(s) are not allowed for the update method.`));
    }
    if (typeof criteria === "string" || typeof criteria === "number" || criteria instanceof Date || Array.isArray(criteria)) {
      return this.createQueryBuilder().update(target).set(partialEntity).whereInIds(criteria).execute();
    } else {
      return this.createQueryBuilder().update(target).set(partialEntity).where(criteria).execute();
    }
  }
  /**
   * Deletes entities by a given condition(s).
   * Unlike save method executes a primitive operation without cascades, relations and other operations included.
   * Executes fast and efficient DELETE query.
   * Does not check if entity exist in the database.
   * Condition(s) cannot be empty.
   */
  delete(targetOrEntity, criteria) {
    if (criteria === void 0 || criteria === null || criteria === "" || Array.isArray(criteria) && criteria.length === 0) {
      return Promise.reject(new TypeORMError(`Empty criteria(s) are not allowed for the delete method.`));
    }
    if (typeof criteria === "string" || typeof criteria === "number" || criteria instanceof Date || Array.isArray(criteria)) {
      return this.createQueryBuilder().delete().from(targetOrEntity).whereInIds(criteria).execute();
    } else {
      return this.createQueryBuilder().delete().from(targetOrEntity).where(criteria).execute();
    }
  }
  /**
   * Records the delete date of entities by a given condition(s).
   * Unlike save method executes a primitive operation without cascades, relations and other operations included.
   * Executes fast and efficient DELETE query.
   * Does not check if entity exist in the database.
   * Condition(s) cannot be empty.
   */
  softDelete(targetOrEntity, criteria) {
    if (criteria === void 0 || criteria === null || criteria === "" || Array.isArray(criteria) && criteria.length === 0) {
      return Promise.reject(new TypeORMError(`Empty criteria(s) are not allowed for the delete method.`));
    }
    if (typeof criteria === "string" || typeof criteria === "number" || criteria instanceof Date || Array.isArray(criteria)) {
      return this.createQueryBuilder().softDelete().from(targetOrEntity).whereInIds(criteria).execute();
    } else {
      return this.createQueryBuilder().softDelete().from(targetOrEntity).where(criteria).execute();
    }
  }
  /**
   * Restores entities by a given condition(s).
   * Unlike save method executes a primitive operation without cascades, relations and other operations included.
   * Executes fast and efficient DELETE query.
   * Does not check if entity exist in the database.
   * Condition(s) cannot be empty.
   */
  restore(targetOrEntity, criteria) {
    if (criteria === void 0 || criteria === null || criteria === "" || Array.isArray(criteria) && criteria.length === 0) {
      return Promise.reject(new TypeORMError(`Empty criteria(s) are not allowed for the delete method.`));
    }
    if (typeof criteria === "string" || typeof criteria === "number" || criteria instanceof Date || Array.isArray(criteria)) {
      return this.createQueryBuilder().restore().from(targetOrEntity).whereInIds(criteria).execute();
    } else {
      return this.createQueryBuilder().restore().from(targetOrEntity).where(criteria).execute();
    }
  }
  /**
   * Checks whether any entity exists with the given options.
   */
  exists(entityClass, options) {
    const metadata = this.connection.getMetadata(entityClass);
    return this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getExists();
  }
  /**
   * Checks whether any entity exists with the given conditions.
   */
  existsBy(entityClass, where) {
    return __async(this, null, function* () {
      const metadata = this.connection.getMetadata(entityClass);
      return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({
        where
      }).getExists();
    });
  }
  /**
   * Counts entities that match given options.
   * Useful for pagination.
   */
  count(entityClass, options) {
    const metadata = this.connection.getMetadata(entityClass);
    return this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getCount();
  }
  /**
   * Counts entities that match given conditions.
   * Useful for pagination.
   */
  countBy(entityClass, where) {
    const metadata = this.connection.getMetadata(entityClass);
    return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({
      where
    }).getCount();
  }
  /**
   * Return the SUM of a column
   */
  sum(entityClass, columnName, where) {
    return this.callAggregateFun(entityClass, "SUM", columnName, where);
  }
  /**
   * Return the AVG of a column
   */
  average(entityClass, columnName, where) {
    return this.callAggregateFun(entityClass, "AVG", columnName, where);
  }
  /**
   * Return the MIN of a column
   */
  minimum(entityClass, columnName, where) {
    return this.callAggregateFun(entityClass, "MIN", columnName, where);
  }
  /**
   * Return the MAX of a column
   */
  maximum(entityClass, columnName, where) {
    return this.callAggregateFun(entityClass, "MAX", columnName, where);
  }
  callAggregateFun(_0, _1, _2) {
    return __async(this, arguments, function* (entityClass, fnName, columnName, where = {}) {
      const metadata = this.connection.getMetadata(entityClass);
      const column = metadata.columns.find((item) => item.propertyPath === columnName);
      if (!column) {
        throw new TypeORMError(`Column "${columnName}" was not found in table "${metadata.name}"`);
      }
      const result = yield this.createQueryBuilder(entityClass, metadata.name).setFindOptions({
        where
      }).select(`${fnName}(${this.connection.driver.escape(column.databaseName)})`, fnName).getRawOne();
      return result[fnName] === null ? null : parseFloat(result[fnName]);
    });
  }
  /**
   * Finds entities that match given find options.
   */
  find(entityClass, options) {
    return __async(this, null, function* () {
      const metadata = this.connection.getMetadata(entityClass);
      return this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getMany();
    });
  }
  /**
   * Finds entities that match given find options.
   */
  findBy(entityClass, where) {
    return __async(this, null, function* () {
      const metadata = this.connection.getMetadata(entityClass);
      return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({
        where
      }).getMany();
    });
  }
  /**
   * Finds entities that match given find options.
   * Also counts all entities that match given conditions,
   * but ignores pagination settings (from and take options).
   */
  findAndCount(entityClass, options) {
    const metadata = this.connection.getMetadata(entityClass);
    return this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getManyAndCount();
  }
  /**
   * Finds entities that match given WHERE conditions.
   * Also counts all entities that match given conditions,
   * but ignores pagination settings (from and take options).
   */
  findAndCountBy(entityClass, where) {
    const metadata = this.connection.getMetadata(entityClass);
    return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({
      where
    }).getManyAndCount();
  }
  /**
   * Finds entities with ids.
   * Optionally find options or conditions can be applied.
   *
   * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:
   *
   * .findBy({
   *     id: In([1, 2, 3])
   * })
   */
  findByIds(entityClass, ids) {
    return __async(this, null, function* () {
      if (!ids.length) return Promise.resolve([]);
      const metadata = this.connection.getMetadata(entityClass);
      return this.createQueryBuilder(entityClass, metadata.name).andWhereInIds(ids).getMany();
    });
  }
  /**
   * Finds first entity by a given find options.
   * If entity was not found in the database - returns null.
   */
  findOne(entityClass, options) {
    return __async(this, null, function* () {
      const metadata = this.connection.getMetadata(entityClass);
      let alias = metadata.name;
      if (options && options.join) {
        alias = options.join.alias;
      }
      if (!options.where) {
        throw new Error(`You must provide selection conditions in order to find a single row.`);
      }
      return this.createQueryBuilder(entityClass, alias).setFindOptions(__spreadProps(__spreadValues({}, options), {
        take: 1
      })).getOne();
    });
  }
  /**
   * Finds first entity that matches given where condition.
   * If entity was not found in the database - returns null.
   */
  findOneBy(entityClass, where) {
    return __async(this, null, function* () {
      const metadata = this.connection.getMetadata(entityClass);
      return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({
        where,
        take: 1
      }).getOne();
    });
  }
  /**
   * Finds first entity that matches given id.
   * If entity was not found in the database - returns null.
   *
   * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:
   *
   * .findOneBy({
   *     id: 1 // where "id" is your primary column name
   * })
   */
  findOneById(entityClass, id) {
    return __async(this, null, function* () {
      const metadata = this.connection.getMetadata(entityClass);
      return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({
        take: 1
      }).whereInIds(metadata.ensureEntityIdMap(id)).getOne();
    });
  }
  /**
   * Finds first entity by a given find options.
   * If entity was not found in the database - rejects with error.
   */
  findOneOrFail(entityClass, options) {
    return __async(this, null, function* () {
      return this.findOne(entityClass, options).then((value) => {
        if (value === null) {
          return Promise.reject(new EntityNotFoundError(entityClass, options));
        }
        return Promise.resolve(value);
      });
    });
  }
  /**
   * Finds first entity that matches given where condition.
   * If entity was not found in the database - rejects with error.
   */
  findOneByOrFail(entityClass, where) {
    return __async(this, null, function* () {
      return this.findOneBy(entityClass, where).then((value) => {
        if (value === null) {
          return Promise.reject(new EntityNotFoundError(entityClass, where));
        }
        return Promise.resolve(value);
      });
    });
  }
  /**
   * Clears all the data from the given table (truncates/drops it).
   *
   * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.
   * @see https://stackoverflow.com/a/5972738/925151
   */
  clear(entityClass) {
    return __async(this, null, function* () {
      const metadata = this.connection.getMetadata(entityClass);
      const queryRunner = this.queryRunner || this.connection.createQueryRunner();
      try {
        return yield queryRunner.clearTable(metadata.tablePath);
      } finally {
        if (!this.queryRunner) yield queryRunner.release();
      }
    });
  }
  /**
   * Increments some column by provided value of the entities matched given conditions.
   */
  increment(entityClass, conditions, propertyPath, value) {
    return __async(this, null, function* () {
      const metadata = this.connection.getMetadata(entityClass);
      const column = metadata.findColumnWithPropertyPath(propertyPath);
      if (!column) throw new TypeORMError(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);
      if (isNaN(Number(value))) throw new TypeORMError(`Value "${value}" is not a number.`);
      const values = propertyPath.split(".").reduceRight((value2, key) => ({
        [key]: value2
      }), () => this.connection.driver.escape(column.databaseName) + " + " + value);
      return this.createQueryBuilder(entityClass, "entity").update(entityClass).set(values).where(conditions).execute();
    });
  }
  /**
   * Decrements some column by provided value of the entities matched given conditions.
   */
  decrement(entityClass, conditions, propertyPath, value) {
    return __async(this, null, function* () {
      const metadata = this.connection.getMetadata(entityClass);
      const column = metadata.findColumnWithPropertyPath(propertyPath);
      if (!column) throw new TypeORMError(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);
      if (isNaN(Number(value))) throw new TypeORMError(`Value "${value}" is not a number.`);
      const values = propertyPath.split(".").reduceRight((value2, key) => ({
        [key]: value2
      }), () => this.connection.driver.escape(column.databaseName) + " - " + value);
      return this.createQueryBuilder(entityClass, "entity").update(entityClass).set(values).where(conditions).execute();
    });
  }
  /**
   * Gets repository for the given entity class or name.
   * If single database connection mode is used, then repository is obtained from the
   * repository aggregator, where each repository is individually created for this entity manager.
   * When single database connection is not used, repository is being obtained from the connection.
   */
  getRepository(target) {
    const repoFromMap = this.repositories.get(target);
    if (repoFromMap) return repoFromMap;
    if (this.connection.driver.options.type === "mongodb") {
      const newRepository = new MongoRepository(target, this, this.queryRunner);
      this.repositories.set(target, newRepository);
      return newRepository;
    } else {
      const newRepository = new Repository(target, this, this.queryRunner);
      this.repositories.set(target, newRepository);
      return newRepository;
    }
  }
  /**
   * Gets tree repository for the given entity class or name.
   * If single database connection mode is used, then repository is obtained from the
   * repository aggregator, where each repository is individually created for this entity manager.
   * When single database connection is not used, repository is being obtained from the connection.
   */
  getTreeRepository(target) {
    if (this.connection.driver.treeSupport === false) throw new TreeRepositoryNotSupportedError(this.connection.driver);
    const repository = this.treeRepositories.find((repository2) => repository2.target === target);
    if (repository) return repository;
    const newRepository = new TreeRepository(target, this, this.queryRunner);
    this.treeRepositories.push(newRepository);
    return newRepository;
  }
  /**
   * Gets mongodb repository for the given entity class.
   */
  getMongoRepository(target) {
    return this.connection.getMongoRepository(target);
  }
  /**
   * Creates a new repository instance out of a given Repository and
   * sets current EntityManager instance to it. Used to work with custom repositories
   * in transactions.
   */
  withRepository(repository) {
    const repositoryConstructor = repository.constructor;
    const _a = repository, {
      target,
      manager,
      queryRunner
    } = _a, otherRepositoryProperties = __objRest(_a, [
      "target",
      "manager",
      "queryRunner"
    ]);
    return Object.assign(new repositoryConstructor(repository.target, this), __spreadValues({}, otherRepositoryProperties));
  }
  /**
   * Gets custom entity repository marked with @EntityRepository decorator.
   *
   * @deprecated use Repository.extend to create custom repositories
   */
  getCustomRepository(customRepository) {
    const entityRepositoryMetadataArgs = getMetadataArgsStorage().entityRepositories.find((repository) => {
      return repository.target === (typeof customRepository === "function" ? customRepository : customRepository.constructor);
    });
    if (!entityRepositoryMetadataArgs) throw new CustomRepositoryNotFoundError(customRepository);
    const entityMetadata = entityRepositoryMetadataArgs.entity ? this.connection.getMetadata(entityRepositoryMetadataArgs.entity) : void 0;
    const entityRepositoryInstance = new entityRepositoryMetadataArgs.target(this, entityMetadata);
    if (entityRepositoryInstance instanceof AbstractRepository) {
      if (!entityRepositoryInstance["manager"]) entityRepositoryInstance["manager"] = this;
    } else {
      if (!entityMetadata) throw new CustomRepositoryCannotInheritRepositoryError(customRepository);
      entityRepositoryInstance["manager"] = this;
      entityRepositoryInstance["metadata"] = entityMetadata;
    }
    return entityRepositoryInstance;
  }
  /**
   * Releases all resources used by entity manager.
   * This is used when entity manager is created with a single query runner,
   * and this single query runner needs to be released after job with entity manager is done.
   */
  release() {
    return __async(this, null, function* () {
      if (!this.queryRunner) throw new NoNeedToReleaseEntityManagerError();
      return this.queryRunner.release();
    });
  }
};

// ../node_modules/typeorm/browser/entity-manager/SqljsEntityManager.js
var SqljsEntityManager = class extends EntityManager {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection, queryRunner) {
    super(connection, queryRunner);
    this["@instanceof"] = Symbol.for("SqljsEntityManager");
    this.driver = connection.driver;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Loads either the definition from a file (Node.js) or localstorage (browser)
   * or uses the given definition to open a new database.
   */
  loadDatabase(fileNameOrLocalStorageOrData) {
    return __async(this, null, function* () {
      yield this.driver.load(fileNameOrLocalStorageOrData);
    });
  }
  /**
   * Saves the current database to a file (Node.js) or localstorage (browser)
   * if fileNameOrLocalStorage is not set options.location is used.
   */
  saveDatabase(fileNameOrLocalStorage) {
    return __async(this, null, function* () {
      yield this.driver.save(fileNameOrLocalStorage);
    });
  }
  /**
   * Returns the current database definition.
   */
  exportDatabase() {
    return this.driver.export();
  }
};

// ../node_modules/typeorm/browser/entity-manager/EntityManagerFactory.js
var EntityManagerFactory = class {
  /**
   * Creates a new entity manager depend on a given connection's driver.
   */
  create(connection, queryRunner) {
    if (connection.driver.options.type === "mongodb") return new MongoEntityManager(connection);
    if (connection.driver.options.type === "sqljs") return new SqljsEntityManager(connection, queryRunner);
    return new EntityManager(connection, queryRunner);
  }
};

// ../node_modules/typeorm/browser/schema-builder/view/View.js
var View = class _View {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(options) {
    this["@instanceof"] = Symbol.for("View");
    this.indices = [];
    if (options) {
      this.database = options.database;
      this.schema = options.schema;
      this.name = options.name;
      this.expression = options.expression;
      this.materialized = !!options.materialized;
    }
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Clones this table to a new table with all properties cloned.
   */
  clone() {
    return new _View({
      database: this.database,
      schema: this.schema,
      name: this.name,
      expression: this.expression,
      materialized: this.materialized
    });
  }
  /**
   * Add index
   */
  addIndex(index) {
    this.indices.push(index);
  }
  /**
   * Remove index
   */
  removeIndex(viewIndex) {
    const index = this.indices.find((index2) => index2.name === viewIndex.name);
    if (index) {
      this.indices.splice(this.indices.indexOf(index), 1);
    }
  }
  // -------------------------------------------------------------------------
  // Static Methods
  // -------------------------------------------------------------------------
  /**
   * Creates view from a given entity metadata.
   */
  static create(entityMetadata, driver) {
    const options = {
      database: entityMetadata.database,
      schema: entityMetadata.schema,
      name: driver.buildTableName(entityMetadata.tableName, entityMetadata.schema, entityMetadata.database),
      expression: entityMetadata.expression,
      materialized: entityMetadata.tableMetadataArgs.materialized
    };
    return new _View(options);
  }
};

// ../node_modules/typeorm/browser/schema-builder/util/ViewUtils.js
var ViewUtils = class {
  /**
   * Comparator for .sort() that will order views bases on dependencies in creation order
   */
  static viewMetadataCmp(metadataA, metadataB) {
    if (!metadataA || !metadataB) {
      return 0;
    }
    if (metadataA.dependsOn && (metadataA.dependsOn.has(metadataB.target) || metadataA.dependsOn.has(metadataB.name))) {
      return 1;
    }
    if (metadataB.dependsOn && (metadataB.dependsOn.has(metadataA.target) || metadataB.dependsOn.has(metadataA.name))) {
      return -1;
    }
    return 0;
  }
};

// ../node_modules/typeorm/browser/schema-builder/RdbmsSchemaBuilder.js
var RdbmsSchemaBuilder = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    this.connection = connection;
    this["@instanceof"] = Symbol.for("RdbmsSchemaBuilder");
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates complete schemas for the given entity metadatas.
   */
  build() {
    return __async(this, null, function* () {
      this.queryRunner = this.connection.createQueryRunner();
      this.currentDatabase = this.connection.driver.database;
      this.currentSchema = this.connection.driver.schema;
      const isUsingTransactions = !(this.connection.driver.options.type === "cockroachdb") && !(this.connection.driver.options.type === "spanner") && this.connection.options.migrationsTransactionMode !== "none";
      yield this.queryRunner.beforeMigration();
      if (isUsingTransactions) {
        yield this.queryRunner.startTransaction();
      }
      try {
        yield this.createMetadataTableIfNecessary(this.queryRunner);
        const tablePaths = this.entityToSyncMetadatas.map((metadata) => this.getTablePath(metadata));
        const viewPaths = this.viewEntityToSyncMetadatas.map((metadata) => this.getTablePath(metadata));
        yield this.queryRunner.getTables(tablePaths);
        yield this.queryRunner.getViews(viewPaths);
        yield this.executeSchemaSyncOperationsInProperOrder();
        if (this.connection.queryResultCache) yield this.connection.queryResultCache.synchronize(this.queryRunner);
        if (isUsingTransactions) {
          yield this.queryRunner.commitTransaction();
        }
      } catch (error) {
        try {
          if (isUsingTransactions) {
            yield this.queryRunner.rollbackTransaction();
          }
        } catch (rollbackError) {
        }
        throw error;
      } finally {
        yield this.queryRunner.afterMigration();
        yield this.queryRunner.release();
      }
    });
  }
  /**
   * Create the typeorm_metadata table if necessary.
   */
  createMetadataTableIfNecessary(queryRunner) {
    return __async(this, null, function* () {
      if (this.viewEntityToSyncMetadatas.length > 0 || this.hasGeneratedColumns()) {
        yield this.createTypeormMetadataTable(queryRunner);
      }
    });
  }
  /**
   * Returns sql queries to be executed by schema builder.
   */
  log() {
    return __async(this, null, function* () {
      this.queryRunner = this.connection.createQueryRunner();
      try {
        const tablePaths = this.entityToSyncMetadatas.map((metadata) => this.getTablePath(metadata));
        const viewPaths = this.viewEntityToSyncMetadatas.map((metadata) => this.getTablePath(metadata));
        yield this.queryRunner.getTables(tablePaths);
        yield this.queryRunner.getViews(viewPaths);
        this.queryRunner.enableSqlMemory();
        yield this.executeSchemaSyncOperationsInProperOrder();
        if (this.connection.queryResultCache)
          yield this.connection.queryResultCache.synchronize(this.queryRunner);
        return this.queryRunner.getMemorySql();
      } finally {
        this.queryRunner.disableSqlMemory();
        yield this.queryRunner.release();
      }
    });
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Returns only entities that should be synced in the database.
   */
  get entityToSyncMetadatas() {
    return this.connection.entityMetadatas.filter((metadata) => metadata.synchronize && metadata.tableType !== "entity-child" && metadata.tableType !== "view");
  }
  /**
   * Returns only entities that should be synced in the database.
   */
  get viewEntityToSyncMetadatas() {
    return this.connection.entityMetadatas.filter((metadata) => metadata.tableType === "view" && metadata.synchronize).sort(ViewUtils.viewMetadataCmp);
  }
  /**
   * Checks if there are at least one generated column.
   */
  hasGeneratedColumns() {
    return this.connection.entityMetadatas.some((entityMetadata) => {
      return entityMetadata.columns.some((column) => column.generatedType);
    });
  }
  /**
   * Executes schema sync operations in a proper order.
   * Order of operations matter here.
   */
  executeSchemaSyncOperationsInProperOrder() {
    return __async(this, null, function* () {
      yield this.dropOldViews();
      yield this.dropOldForeignKeys();
      yield this.dropOldIndices();
      yield this.dropOldChecks();
      yield this.dropOldExclusions();
      yield this.dropCompositeUniqueConstraints();
      yield this.renameColumns();
      yield this.changeTableComment();
      yield this.createNewTables();
      yield this.dropRemovedColumns();
      yield this.addNewColumns();
      yield this.updatePrimaryKeys();
      yield this.updateExistColumns();
      yield this.createNewIndices();
      yield this.createNewChecks();
      yield this.createNewExclusions();
      yield this.createCompositeUniqueConstraints();
      yield this.createForeignKeys();
      yield this.createViews();
      yield this.createNewViewIndices();
    });
  }
  getTablePath(target) {
    const parsed = this.connection.driver.parseTableName(target);
    return this.connection.driver.buildTableName(parsed.tableName, parsed.schema || this.currentSchema, parsed.database || this.currentDatabase);
  }
  /**
   * Drops all (old) foreign keys that exist in the tables, but do not exist in the entity metadata.
   */
  dropOldForeignKeys() {
    return __async(this, null, function* () {
      for (const metadata of this.entityToSyncMetadatas) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
        if (!table) continue;
        const tableForeignKeysToDrop = table.foreignKeys.filter((tableForeignKey) => {
          const metadataFK = metadata.foreignKeys.find((metadataForeignKey) => tableForeignKey.name === metadataForeignKey.name && this.getTablePath(tableForeignKey) === this.getTablePath(metadataForeignKey.referencedEntityMetadata));
          return !metadataFK || metadataFK.onDelete && metadataFK.onDelete !== tableForeignKey.onDelete || metadataFK.onUpdate && metadataFK.onUpdate !== tableForeignKey.onUpdate;
        });
        if (tableForeignKeysToDrop.length === 0) continue;
        this.connection.logger.logSchemaBuild(`dropping old foreign keys of ${table.name}: ${tableForeignKeysToDrop.map((dbForeignKey) => dbForeignKey.name).join(", ")}`);
        yield this.queryRunner.dropForeignKeys(table, tableForeignKeysToDrop);
      }
    });
  }
  /**
   * Rename tables
   */
  renameTables() {
    return __async(this, null, function* () {
    });
  }
  /**
   * Renames columns.
   * Works if only one column per table was changed.
   * Changes only column name. If something besides name was changed, these changes will be ignored.
   */
  renameColumns() {
    return __async(this, null, function* () {
      for (const metadata of this.entityToSyncMetadatas) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
        if (!table) continue;
        if (metadata.columns.length !== table.columns.length) continue;
        const renamedMetadataColumns = metadata.columns.filter((c) => !c.isVirtualProperty).filter((column) => {
          return !table.columns.find((tableColumn) => {
            return tableColumn.name === column.databaseName && tableColumn.type === this.connection.driver.normalizeType(column) && tableColumn.isNullable === column.isNullable && tableColumn.isUnique === this.connection.driver.normalizeIsUnique(column);
          });
        });
        if (renamedMetadataColumns.length === 0 || renamedMetadataColumns.length > 1) continue;
        const renamedTableColumns = table.columns.filter((tableColumn) => {
          return !metadata.columns.find((column) => {
            return !column.isVirtualProperty && column.databaseName === tableColumn.name && this.connection.driver.normalizeType(column) === tableColumn.type && column.isNullable === tableColumn.isNullable && this.connection.driver.normalizeIsUnique(column) === tableColumn.isUnique;
          });
        });
        if (renamedTableColumns.length === 0 || renamedTableColumns.length > 1) continue;
        const renamedColumn = renamedTableColumns[0].clone();
        renamedColumn.name = renamedMetadataColumns[0].databaseName;
        this.connection.logger.logSchemaBuild(`renaming column "${renamedTableColumns[0].name}" in "${table.name}" to "${renamedColumn.name}"`);
        yield this.queryRunner.renameColumn(table, renamedTableColumns[0], renamedColumn);
      }
    });
  }
  dropOldIndices() {
    return __async(this, null, function* () {
      for (const metadata of this.entityToSyncMetadatas) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
        if (!table) continue;
        const dropQueries = table.indices.filter((tableIndex) => {
          const indexMetadata = metadata.indices.find((index) => index.name === tableIndex.name);
          if (indexMetadata) {
            if (indexMetadata.synchronize === false) return false;
            if (indexMetadata.isUnique !== tableIndex.isUnique) return true;
            if (indexMetadata.isSpatial !== tableIndex.isSpatial) return true;
            if (this.connection.driver.isFullTextColumnTypeSupported() && indexMetadata.isFulltext !== tableIndex.isFulltext) return true;
            if (indexMetadata.columns.length !== tableIndex.columnNames.length) return true;
            return !indexMetadata.columns.every((column) => tableIndex.columnNames.indexOf(column.databaseName) !== -1);
          }
          return true;
        }).map((tableIndex) => __async(this, null, function* () {
          this.connection.logger.logSchemaBuild(`dropping an index: "${tableIndex.name}" from table ${table.name}`);
          yield this.queryRunner.dropIndex(table, tableIndex);
        }));
        yield Promise.all(dropQueries);
      }
      if (this.connection.options.type === "postgres") {
        const postgresQueryRunner = this.queryRunner;
        for (const metadata of this.viewEntityToSyncMetadatas) {
          const view = this.queryRunner.loadedViews.find((view2) => this.getTablePath(view2) === this.getTablePath(metadata));
          if (!view) continue;
          const dropQueries = view.indices.filter((tableIndex) => {
            const indexMetadata = metadata.indices.find((index) => index.name === tableIndex.name);
            if (indexMetadata) {
              if (indexMetadata.synchronize === false) return false;
              if (indexMetadata.isUnique !== tableIndex.isUnique) return true;
              if (indexMetadata.isSpatial !== tableIndex.isSpatial) return true;
              if (this.connection.driver.isFullTextColumnTypeSupported() && indexMetadata.isFulltext !== tableIndex.isFulltext) return true;
              if (indexMetadata.columns.length !== tableIndex.columnNames.length) return true;
              return !indexMetadata.columns.every((column) => tableIndex.columnNames.indexOf(column.databaseName) !== -1);
            }
            return true;
          }).map((tableIndex) => __async(this, null, function* () {
            this.connection.logger.logSchemaBuild(`dropping an index: "${tableIndex.name}" from view ${view.name}`);
            yield postgresQueryRunner.dropViewIndex(view, tableIndex);
          }));
          yield Promise.all(dropQueries);
        }
      }
    });
  }
  dropOldChecks() {
    return __async(this, null, function* () {
      if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") return;
      for (const metadata of this.entityToSyncMetadatas) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
        if (!table) continue;
        const oldChecks = table.checks.filter((tableCheck) => {
          return !metadata.checks.find((checkMetadata) => checkMetadata.name === tableCheck.name);
        });
        if (oldChecks.length === 0) continue;
        this.connection.logger.logSchemaBuild(`dropping old check constraint: ${oldChecks.map((check) => `"${check.name}"`).join(", ")} from table "${table.name}"`);
        yield this.queryRunner.dropCheckConstraints(table, oldChecks);
      }
    });
  }
  dropCompositeUniqueConstraints() {
    return __async(this, null, function* () {
      for (const metadata of this.entityToSyncMetadatas) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
        if (!table) continue;
        const compositeUniques = table.uniques.filter((tableUnique) => {
          return tableUnique.columnNames.length > 1 && !metadata.uniques.find((uniqueMetadata) => uniqueMetadata.name === tableUnique.name);
        });
        if (compositeUniques.length === 0) continue;
        this.connection.logger.logSchemaBuild(`dropping old unique constraint: ${compositeUniques.map((unique) => `"${unique.name}"`).join(", ")} from table "${table.name}"`);
        yield this.queryRunner.dropUniqueConstraints(table, compositeUniques);
      }
    });
  }
  dropOldExclusions() {
    return __async(this, null, function* () {
      if (!(this.connection.driver.options.type === "postgres")) return;
      for (const metadata of this.entityToSyncMetadatas) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
        if (!table) continue;
        const oldExclusions = table.exclusions.filter((tableExclusion) => {
          return !metadata.exclusions.find((exclusionMetadata) => exclusionMetadata.name === tableExclusion.name);
        });
        if (oldExclusions.length === 0) continue;
        this.connection.logger.logSchemaBuild(`dropping old exclusion constraint: ${oldExclusions.map((exclusion) => `"${exclusion.name}"`).join(", ")} from table "${table.name}"`);
        yield this.queryRunner.dropExclusionConstraints(table, oldExclusions);
      }
    });
  }
  /**
   * change table comment
   */
  changeTableComment() {
    return __async(this, null, function* () {
      for (const metadata of this.entityToSyncMetadatas) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
        if (!table) continue;
        if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "postgres") {
          const newComment = metadata.comment;
          yield this.queryRunner.changeTableComment(table, newComment);
        }
      }
    });
  }
  /**
   * Creates tables that do not exist in the database yet.
   * New tables are created without foreign and primary keys.
   * Primary key only can be created in conclusion with auto generated column.
   */
  createNewTables() {
    return __async(this, null, function* () {
      for (const metadata of this.entityToSyncMetadatas) {
        const existTable = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
        if (existTable) continue;
        this.connection.logger.logSchemaBuild(`creating a new table: ${this.getTablePath(metadata)}`);
        const table = Table.create(metadata, this.connection.driver);
        yield this.queryRunner.createTable(table, false, false);
        this.queryRunner.loadedTables.push(table);
      }
    });
  }
  createViews() {
    return __async(this, null, function* () {
      for (const metadata of this.viewEntityToSyncMetadatas) {
        const existView = this.queryRunner.loadedViews.find((view2) => {
          const viewExpression = typeof view2.expression === "string" ? view2.expression.trim() : view2.expression(this.connection).getQuery();
          const metadataExpression = typeof metadata.expression === "string" ? metadata.expression.trim() : metadata.expression(this.connection).getQuery();
          return this.getTablePath(view2) === this.getTablePath(metadata) && viewExpression === metadataExpression;
        });
        if (existView) continue;
        this.connection.logger.logSchemaBuild(`creating a new view: ${this.getTablePath(metadata)}`);
        const view = View.create(metadata, this.connection.driver);
        yield this.queryRunner.createView(view, true);
        this.queryRunner.loadedViews.push(view);
      }
    });
  }
  dropOldViews() {
    return __async(this, null, function* () {
      const droppedViews = [];
      const viewEntityToSyncMetadatas = this.viewEntityToSyncMetadatas;
      const viewToMetadata = /* @__PURE__ */ new Map();
      for (const view of this.queryRunner.loadedViews) {
        const viewMetadata = viewEntityToSyncMetadatas.find((metadata) => {
          return this.getTablePath(view) === this.getTablePath(metadata);
        });
        if (viewMetadata) {
          viewToMetadata.set(view, viewMetadata);
        }
      }
      for (const view of this.queryRunner.loadedViews) {
        const viewMetadata = viewToMetadata.get(view);
        if (!viewMetadata) {
          continue;
        }
        const viewExpression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
        const metadataExpression = typeof viewMetadata.expression === "string" ? viewMetadata.expression.trim() : viewMetadata.expression(this.connection).getQuery();
        if (viewExpression === metadataExpression) continue;
        this.connection.logger.logSchemaBuild(`dropping an old view: ${view.name}`);
        droppedViews.push(view);
      }
      const viewDependencyChain = (view) => {
        const viewMetadata = viewToMetadata.get(view);
        let viewWithDependencies = [view];
        if (!viewMetadata) {
          return viewWithDependencies;
        }
        for (const [currentView, currentMetadata] of viewToMetadata.entries()) {
          if (currentView === view) {
            continue;
          }
          if (currentMetadata.dependsOn && (currentMetadata.dependsOn.has(viewMetadata.target) || currentMetadata.dependsOn.has(viewMetadata.name))) {
            viewWithDependencies = viewWithDependencies.concat(viewDependencyChain(currentView));
          }
        }
        return viewWithDependencies;
      };
      const droppedViewsWithDependencies = new Set(
        // Collect all dropped views, and their dependencies
        droppedViews.map((view) => viewDependencyChain(view)).reduce((all, segment) => {
          return all.concat(segment);
        }, []).sort((a, b) => {
          return ViewUtils.viewMetadataCmp(viewToMetadata.get(a), viewToMetadata.get(b));
        }).reverse()
      );
      for (const view of droppedViewsWithDependencies) {
        yield this.queryRunner.dropView(view);
      }
      this.queryRunner.loadedViews = this.queryRunner.loadedViews.filter((view) => !droppedViewsWithDependencies.has(view));
    });
  }
  /**
   * Drops all columns that exist in the table, but does not exist in the metadata (left old).
   * We drop their keys too, since it should be safe.
   */
  dropRemovedColumns() {
    return __async(this, null, function* () {
      for (const metadata of this.entityToSyncMetadatas) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
        if (!table) continue;
        const droppedTableColumns = table.columns.filter((tableColumn) => {
          return !metadata.columns.find((columnMetadata) => columnMetadata.isVirtualProperty || columnMetadata.databaseName === tableColumn.name);
        });
        if (droppedTableColumns.length === 0) continue;
        this.connection.logger.logSchemaBuild(`columns dropped in ${table.name}: ` + droppedTableColumns.map((column) => column.name).join(", "));
        yield this.queryRunner.dropColumns(table, droppedTableColumns);
      }
    });
  }
  /**
   * Adds columns from metadata which does not exist in the table.
   * Columns are created without keys.
   */
  addNewColumns() {
    return __async(this, null, function* () {
      for (const metadata of this.entityToSyncMetadatas) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
        if (!table) continue;
        const newColumnMetadatas = metadata.columns.filter((columnMetadata) => {
          return !columnMetadata.isVirtualProperty && !table.columns.find((tableColumn) => tableColumn.name === columnMetadata.databaseName);
        });
        if (newColumnMetadatas.length === 0) continue;
        const newTableColumnOptions = this.metadataColumnsToTableColumnOptions(newColumnMetadatas);
        const newTableColumns = newTableColumnOptions.map((option) => new TableColumn(option));
        if (newTableColumns.length === 0) continue;
        this.connection.logger.logSchemaBuild(`new columns added: ` + newColumnMetadatas.map((column) => column.databaseName).join(", "));
        yield this.queryRunner.addColumns(table, newTableColumns);
      }
    });
  }
  /**
   * Updates composite primary keys.
   */
  updatePrimaryKeys() {
    return __async(this, null, function* () {
      for (const metadata of this.entityToSyncMetadatas) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
        if (!table) continue;
        const primaryMetadataColumns = metadata.columns.filter((column) => column.isPrimary);
        const primaryTableColumns = table.columns.filter((column) => column.isPrimary);
        if (primaryTableColumns.length !== primaryMetadataColumns.length && primaryMetadataColumns.length > 1) {
          const changedPrimaryColumns = primaryMetadataColumns.map((primaryMetadataColumn) => {
            return new TableColumn(TableUtils.createTableColumnOptions(primaryMetadataColumn, this.connection.driver));
          });
          yield this.queryRunner.updatePrimaryKeys(table, changedPrimaryColumns);
        }
      }
    });
  }
  /**
   * Update all exist columns which metadata has changed.
   * Still don't create keys. Also we don't touch foreign keys of the changed columns.
   */
  updateExistColumns() {
    return __async(this, null, function* () {
      for (const metadata of this.entityToSyncMetadatas) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
        if (!table) continue;
        const changedColumns = this.connection.driver.findChangedColumns(table.columns, metadata.columns);
        if (changedColumns.length === 0) continue;
        for (const changedColumn of changedColumns) {
          yield this.dropColumnReferencedForeignKeys(this.getTablePath(metadata), changedColumn.databaseName);
        }
        for (const changedColumn of changedColumns) {
          yield this.dropColumnCompositeIndices(this.getTablePath(metadata), changedColumn.databaseName);
        }
        if (!(DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql" || this.connection.driver.options.type === "spanner")) {
          for (const changedColumn of changedColumns) {
            yield this.dropColumnCompositeUniques(this.getTablePath(metadata), changedColumn.databaseName);
          }
        }
        const newAndOldTableColumns = changedColumns.map((changedColumn) => {
          const oldTableColumn = table.columns.find((column) => column.name === changedColumn.databaseName);
          const newTableColumnOptions = TableUtils.createTableColumnOptions(changedColumn, this.connection.driver);
          const newTableColumn = new TableColumn(newTableColumnOptions);
          return {
            oldColumn: oldTableColumn,
            newColumn: newTableColumn
          };
        });
        if (newAndOldTableColumns.length === 0) continue;
        this.connection.logger.logSchemaBuild(`columns changed in "${table.name}". updating: ` + changedColumns.map((column) => column.databaseName).join(", "));
        yield this.queryRunner.changeColumns(table, newAndOldTableColumns);
      }
    });
  }
  /**
   * Creates composite indices which are missing in db yet.
   */
  createNewIndices() {
    return __async(this, null, function* () {
      for (const metadata of this.entityToSyncMetadatas) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
        if (!table) continue;
        const newIndices = metadata.indices.filter((indexMetadata) => !table.indices.find((tableIndex) => tableIndex.name === indexMetadata.name) && indexMetadata.synchronize === true).map((indexMetadata) => TableIndex.create(indexMetadata));
        if (newIndices.length === 0) continue;
        this.connection.logger.logSchemaBuild(`adding new indices ${newIndices.map((index) => `"${index.name}"`).join(", ")} in table "${table.name}"`);
        yield this.queryRunner.createIndices(table, newIndices);
      }
    });
  }
  /**
   * Creates indices for materialized views.
   */
  createNewViewIndices() {
    return __async(this, null, function* () {
      if (this.connection.options.type !== "postgres" || !DriverUtils.isPostgresFamily(this.connection.driver)) {
        return;
      }
      const postgresQueryRunner = this.queryRunner;
      for (const metadata of this.viewEntityToSyncMetadatas) {
        const view = this.queryRunner.loadedViews.find((view2) => {
          const viewExpression = typeof view2.expression === "string" ? view2.expression.trim() : view2.expression(this.connection).getQuery();
          const metadataExpression = typeof metadata.expression === "string" ? metadata.expression.trim() : metadata.expression(this.connection).getQuery();
          return this.getTablePath(view2) === this.getTablePath(metadata) && viewExpression === metadataExpression;
        });
        if (!view || !view.materialized) continue;
        const newIndices = metadata.indices.filter((indexMetadata) => !view.indices.find((tableIndex) => tableIndex.name === indexMetadata.name) && indexMetadata.synchronize === true).map((indexMetadata) => TableIndex.create(indexMetadata));
        if (newIndices.length === 0) continue;
        this.connection.logger.logSchemaBuild(`adding new indices ${newIndices.map((index) => `"${index.name}"`).join(", ")} in view "${view.name}"`);
        yield postgresQueryRunner.createViewIndices(view, newIndices);
      }
    });
  }
  createNewChecks() {
    return __async(this, null, function* () {
      if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") return;
      for (const metadata of this.entityToSyncMetadatas) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
        if (!table) continue;
        const newChecks = metadata.checks.filter((checkMetadata) => !table.checks.find((tableCheck) => tableCheck.name === checkMetadata.name)).map((checkMetadata) => TableCheck.create(checkMetadata));
        if (newChecks.length === 0) continue;
        this.connection.logger.logSchemaBuild(`adding new check constraints: ${newChecks.map((index) => `"${index.name}"`).join(", ")} in table "${table.name}"`);
        yield this.queryRunner.createCheckConstraints(table, newChecks);
      }
    });
  }
  /**
   * Creates composite uniques which are missing in db yet.
   */
  createCompositeUniqueConstraints() {
    return __async(this, null, function* () {
      for (const metadata of this.entityToSyncMetadatas) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
        if (!table) continue;
        const compositeUniques = metadata.uniques.filter((uniqueMetadata) => uniqueMetadata.columns.length > 1 && !table.uniques.find((tableUnique) => tableUnique.name === uniqueMetadata.name)).map((uniqueMetadata) => TableUnique.create(uniqueMetadata));
        if (compositeUniques.length === 0) continue;
        this.connection.logger.logSchemaBuild(`adding new unique constraints: ${compositeUniques.map((unique) => `"${unique.name}"`).join(", ")} in table "${table.name}"`);
        yield this.queryRunner.createUniqueConstraints(table, compositeUniques);
      }
    });
  }
  /**
   * Creates exclusions which are missing in db yet.
   */
  createNewExclusions() {
    return __async(this, null, function* () {
      if (!(this.connection.driver.options.type === "postgres")) return;
      for (const metadata of this.entityToSyncMetadatas) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
        if (!table) continue;
        const newExclusions = metadata.exclusions.filter((exclusionMetadata) => !table.exclusions.find((tableExclusion) => tableExclusion.name === exclusionMetadata.name)).map((exclusionMetadata) => TableExclusion.create(exclusionMetadata));
        if (newExclusions.length === 0) continue;
        this.connection.logger.logSchemaBuild(`adding new exclusion constraints: ${newExclusions.map((exclusion) => `"${exclusion.name}"`).join(", ")} in table "${table.name}"`);
        yield this.queryRunner.createExclusionConstraints(table, newExclusions);
      }
    });
  }
  /**
   * Creates foreign keys which does not exist in the table yet.
   */
  createForeignKeys() {
    return __async(this, null, function* () {
      for (const metadata of this.entityToSyncMetadatas) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
        if (!table) continue;
        const newKeys = metadata.foreignKeys.filter((foreignKey) => {
          return !table.foreignKeys.find((dbForeignKey) => dbForeignKey.name === foreignKey.name && this.getTablePath(dbForeignKey) === this.getTablePath(foreignKey.referencedEntityMetadata));
        });
        if (newKeys.length === 0) continue;
        const dbForeignKeys = newKeys.map((foreignKeyMetadata) => TableForeignKey.create(foreignKeyMetadata, this.connection.driver));
        this.connection.logger.logSchemaBuild(`creating a foreign keys: ${newKeys.map((key) => key.name).join(", ")} on table "${table.name}"`);
        yield this.queryRunner.createForeignKeys(table, dbForeignKeys);
      }
    });
  }
  /**
   * Drops all foreign keys where given column of the given table is being used.
   */
  dropColumnReferencedForeignKeys(tablePath, columnName) {
    return __async(this, null, function* () {
      const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === tablePath);
      if (!table) return;
      const tablesWithFK = [];
      const columnForeignKey = table.foreignKeys.find((foreignKey) => foreignKey.columnNames.indexOf(columnName) !== -1);
      if (columnForeignKey) {
        const clonedTable = table.clone();
        clonedTable.foreignKeys = [columnForeignKey];
        tablesWithFK.push(clonedTable);
        table.removeForeignKey(columnForeignKey);
      }
      for (const loadedTable of this.queryRunner.loadedTables) {
        const dependForeignKeys = loadedTable.foreignKeys.filter((foreignKey) => {
          return this.getTablePath(foreignKey) === tablePath && foreignKey.referencedColumnNames.indexOf(columnName) !== -1;
        });
        if (dependForeignKeys.length > 0) {
          const clonedTable = loadedTable.clone();
          clonedTable.foreignKeys = dependForeignKeys;
          tablesWithFK.push(clonedTable);
          dependForeignKeys.forEach((dependForeignKey) => loadedTable.removeForeignKey(dependForeignKey));
        }
      }
      if (tablesWithFK.length > 0) {
        for (const tableWithFK of tablesWithFK) {
          this.connection.logger.logSchemaBuild(`dropping related foreign keys of ${tableWithFK.name}: ${tableWithFK.foreignKeys.map((foreignKey) => foreignKey.name).join(", ")}`);
          yield this.queryRunner.dropForeignKeys(tableWithFK, tableWithFK.foreignKeys);
        }
      }
    });
  }
  /**
   * Drops all composite indices, related to given column.
   */
  dropColumnCompositeIndices(tablePath, columnName) {
    return __async(this, null, function* () {
      const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === tablePath);
      if (!table) return;
      const relatedIndices = table.indices.filter((index) => index.columnNames.length > 1 && index.columnNames.indexOf(columnName) !== -1);
      if (relatedIndices.length === 0) return;
      this.connection.logger.logSchemaBuild(`dropping related indices of "${tablePath}"."${columnName}": ${relatedIndices.map((index) => index.name).join(", ")}`);
      yield this.queryRunner.dropIndices(table, relatedIndices);
    });
  }
  /**
   * Drops all composite uniques, related to given column.
   */
  dropColumnCompositeUniques(tablePath, columnName) {
    return __async(this, null, function* () {
      const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === tablePath);
      if (!table) return;
      const relatedUniques = table.uniques.filter((unique) => unique.columnNames.length > 1 && unique.columnNames.indexOf(columnName) !== -1);
      if (relatedUniques.length === 0) return;
      this.connection.logger.logSchemaBuild(`dropping related unique constraints of "${tablePath}"."${columnName}": ${relatedUniques.map((unique) => unique.name).join(", ")}`);
      yield this.queryRunner.dropUniqueConstraints(table, relatedUniques);
    });
  }
  /**
   * Creates new columns from the given column metadatas.
   */
  metadataColumnsToTableColumnOptions(columns) {
    return columns.map((columnMetadata) => TableUtils.createTableColumnOptions(columnMetadata, this.connection.driver));
  }
  /**
   * Creates typeorm service table for storing user defined Views and generate columns.
   */
  createTypeormMetadataTable(queryRunner) {
    return __async(this, null, function* () {
      const schema = this.currentSchema;
      const database = this.currentDatabase;
      const typeormMetadataTable = this.connection.driver.buildTableName(this.connection.metadataTableName, schema, database);
      const isPrimary = this.connection.driver.options.type === "spanner";
      yield queryRunner.createTable(new Table({
        database,
        schema,
        name: typeormMetadataTable,
        columns: [{
          name: "type",
          type: this.connection.driver.normalizeType({
            type: this.connection.driver.mappedDataTypes.metadataType
          }),
          isNullable: false,
          isPrimary
        }, {
          name: "database",
          type: this.connection.driver.normalizeType({
            type: this.connection.driver.mappedDataTypes.metadataDatabase
          }),
          isNullable: true,
          isPrimary
        }, {
          name: "schema",
          type: this.connection.driver.normalizeType({
            type: this.connection.driver.mappedDataTypes.metadataSchema
          }),
          isNullable: true,
          isPrimary
        }, {
          name: "table",
          type: this.connection.driver.normalizeType({
            type: this.connection.driver.mappedDataTypes.metadataTable
          }),
          isNullable: true,
          isPrimary
        }, {
          name: "name",
          type: this.connection.driver.normalizeType({
            type: this.connection.driver.mappedDataTypes.metadataName
          }),
          isNullable: true,
          isPrimary
        }, {
          name: "value",
          type: this.connection.driver.normalizeType({
            type: this.connection.driver.mappedDataTypes.metadataValue
          }),
          isNullable: true,
          isPrimary
        }]
      }), true);
    });
  }
};

// ../node_modules/typeorm/browser/driver/sqlite-abstract/AbstractSqliteDriver.js
var AbstractSqliteDriver = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    this.isReplicated = false;
    this.treeSupport = true;
    this.transactionSupport = "nested";
    this.supportedDataTypes = ["int", "integer", "tinyint", "smallint", "mediumint", "bigint", "unsigned big int", "int2", "int8", "integer", "character", "varchar", "varying character", "nchar", "native character", "nvarchar", "text", "clob", "text", "blob", "real", "double", "double precision", "float", "real", "numeric", "decimal", "boolean", "date", "time", "datetime", "json"];
    this.supportedUpsertTypes = ["on-conflict-do-update"];
    this.withLengthColumnTypes = ["character", "varchar", "varying character", "nchar", "native character", "nvarchar", "text", "blob", "clob"];
    this.spatialTypes = [];
    this.withPrecisionColumnTypes = ["real", "double", "double precision", "float", "real", "numeric", "decimal", "date", "time", "datetime"];
    this.withScaleColumnTypes = ["real", "double", "double precision", "float", "real", "numeric", "decimal"];
    this.mappedDataTypes = {
      createDate: "datetime",
      createDateDefault: "datetime('now')",
      updateDate: "datetime",
      updateDateDefault: "datetime('now')",
      deleteDate: "datetime",
      deleteDateNullable: true,
      version: "integer",
      treeLevel: "integer",
      migrationId: "integer",
      migrationName: "varchar",
      migrationTimestamp: "bigint",
      cacheId: "int",
      cacheIdentifier: "varchar",
      cacheTime: "bigint",
      cacheDuration: "int",
      cacheQuery: "text",
      cacheResult: "text",
      metadataType: "varchar",
      metadataDatabase: "varchar",
      metadataSchema: "varchar",
      metadataTable: "varchar",
      metadataName: "varchar",
      metadataValue: "text"
    };
    this.cteCapabilities = {
      enabled: true,
      requiresRecursiveHint: true
    };
    this.attachedDatabases = {};
    this.connection = connection;
    this.options = connection.options;
    this.database = DriverUtils.buildDriverOptions(this.options).database;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Performs connection to the database.
   */
  connect() {
    return __async(this, null, function* () {
      this.databaseConnection = yield this.createDatabaseConnection();
    });
  }
  /**
   * Makes any action after connection (e.g. create extensions in Postgres driver).
   */
  afterConnect() {
    return Promise.resolve();
  }
  /**
   * Closes connection with database.
   */
  disconnect() {
    return __async(this, null, function* () {
      return new Promise((ok, fail) => {
        this.queryRunner = void 0;
        this.databaseConnection.close((err) => err ? fail(err) : ok());
      });
    });
  }
  hasAttachedDatabases() {
    return !!Object.keys(this.attachedDatabases).length;
  }
  getAttachedDatabaseHandleByRelativePath(path) {
    return this.attachedDatabases?.[path]?.attachHandle;
  }
  getAttachedDatabasePathRelativeByHandle(handle) {
    return Object.values(this.attachedDatabases).find(({
      attachHandle
    }) => handle === attachHandle)?.attachFilepathRelative;
  }
  /**
   * Creates a schema builder used to build and sync a schema.
   */
  createSchemaBuilder() {
    return new RdbmsSchemaBuilder(this.connection);
  }
  /**
   * Prepares given value to a value to be persisted, based on its column type and metadata.
   */
  preparePersistentValue(value, columnMetadata) {
    if (columnMetadata.transformer) value = ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
    if (value === null || value === void 0) return value;
    if (columnMetadata.type === Boolean || columnMetadata.type === "boolean") {
      return value === true ? 1 : 0;
    } else if (columnMetadata.type === "date") {
      return DateUtils.mixedDateToDateString(value);
    } else if (columnMetadata.type === "time") {
      return DateUtils.mixedDateToTimeString(value);
    } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
      return DateUtils.mixedDateToUtcDatetimeString(value);
    } else if (columnMetadata.type === "json" || columnMetadata.type === "simple-json") {
      return DateUtils.simpleJsonToString(value);
    } else if (columnMetadata.type === "simple-array") {
      return DateUtils.simpleArrayToString(value);
    } else if (columnMetadata.type === "simple-enum") {
      return DateUtils.simpleEnumToString(value);
    }
    return value;
  }
  /**
   * Prepares given value to a value to be hydrated, based on its column type or metadata.
   */
  prepareHydratedValue(value, columnMetadata) {
    if (value === null || value === void 0) return columnMetadata.transformer ? ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
    if (columnMetadata.type === Boolean || columnMetadata.type === "boolean") {
      value = value ? true : false;
    } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
      if (value && typeof value === "string") {
        if (/^\d\d\d\d-\d\d-\d\d \d\d:\d\d/.test(value)) {
          value = value.replace(" ", "T");
        }
        if (/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d(:\d\d(\.\d\d\d)?)?$/.test(value)) {
          value += "Z";
        }
      }
      value = DateUtils.normalizeHydratedDate(value);
    } else if (columnMetadata.type === "date") {
      value = DateUtils.mixedDateToDateString(value);
    } else if (columnMetadata.type === "time") {
      value = DateUtils.mixedTimeToString(value);
    } else if (columnMetadata.type === "json" || columnMetadata.type === "simple-json") {
      value = DateUtils.stringToSimpleJson(value);
    } else if (columnMetadata.type === "simple-array") {
      value = DateUtils.stringToSimpleArray(value);
    } else if (columnMetadata.type === "simple-enum") {
      value = DateUtils.stringToSimpleEnum(value, columnMetadata);
    } else if (columnMetadata.type === Number) {
      value = !isNaN(+value) ? parseInt(value) : value;
    }
    if (columnMetadata.transformer) value = ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
    return value;
  }
  /**
   * Replaces parameters in the given sql with special escaping character
   * and an array of parameter names to be passed to a query.
   */
  escapeQueryWithParameters(sql, parameters, nativeParameters) {
    const escapedParameters = Object.keys(nativeParameters).map((key) => {
      if (typeof nativeParameters[key] === "boolean") {
        return nativeParameters[key] === true ? 1 : 0;
      }
      if (nativeParameters[key] instanceof Date) {
        return DateUtils.mixedDateToUtcDatetimeString(nativeParameters[key]);
      }
      return nativeParameters[key];
    });
    if (!parameters || !Object.keys(parameters).length) return [sql, escapedParameters];
    sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {
      if (!parameters.hasOwnProperty(key)) {
        return full;
      }
      let value = parameters[key];
      if (isArray) {
        return value.map((v) => {
          escapedParameters.push(v);
          return this.createParameter(key, escapedParameters.length - 1);
        }).join(", ");
      }
      if (typeof value === "function") {
        return value();
      } else if (typeof value === "number") {
        return String(value);
      }
      if (typeof value === "boolean") {
        escapedParameters.push(+value);
        return this.createParameter(key, escapedParameters.length - 1);
      }
      if (value instanceof Date) {
        escapedParameters.push(DateUtils.mixedDateToUtcDatetimeString(value));
        return this.createParameter(key, escapedParameters.length - 1);
      }
      escapedParameters.push(value);
      return this.createParameter(key, escapedParameters.length - 1);
    });
    return [sql, escapedParameters];
  }
  /**
   * Escapes a column name.
   */
  escape(columnName) {
    return '"' + columnName + '"';
  }
  /**
   * Build full table name with database name, schema name and table name.
   * E.g. myDB.mySchema.myTable
   *
   * Returns only simple table name because all inherited drivers does not supports schema and database.
   */
  buildTableName(tableName, schema, database) {
    return tableName;
  }
  /**
   * Parse a target table name or other types and return a normalized table definition.
   */
  parseTableName(target) {
    const driverDatabase = this.database;
    const driverSchema = void 0;
    if (InstanceChecker.isTable(target) || InstanceChecker.isView(target)) {
      const parsed = this.parseTableName(target.schema ? `"${target.schema}"."${target.name}"` : target.name);
      return {
        database: target.database || parsed.database || driverDatabase,
        schema: target.schema || parsed.schema || driverSchema,
        tableName: parsed.tableName
      };
    }
    if (InstanceChecker.isTableForeignKey(target)) {
      const parsed = this.parseTableName(target.referencedTableName);
      return {
        database: target.referencedDatabase || parsed.database || driverDatabase,
        schema: target.referencedSchema || parsed.schema || driverSchema,
        tableName: parsed.tableName
      };
    }
    if (InstanceChecker.isEntityMetadata(target)) {
      return {
        database: target.database || driverDatabase,
        schema: target.schema || driverSchema,
        tableName: target.tableName
      };
    }
    const parts = target.split(".");
    if (parts.length === 3) {
      return {
        database: parts[0] || driverDatabase,
        schema: parts[1] || driverSchema,
        tableName: parts[2]
      };
    } else if (parts.length === 2) {
      const database = this.getAttachedDatabasePathRelativeByHandle(parts[0]) ?? driverDatabase;
      return {
        database,
        schema: parts[0],
        tableName: parts[1]
      };
    } else {
      return {
        database: driverDatabase,
        schema: driverSchema,
        tableName: target
      };
    }
  }
  /**
   * Creates a database type from a given column metadata.
   */
  normalizeType(column) {
    if (column.type === Number || column.type === "int") {
      return "integer";
    } else if (column.type === String) {
      return "varchar";
    } else if (column.type === Date) {
      return "datetime";
    } else if (column.type === Boolean) {
      return "boolean";
    } else if (column.type === "uuid") {
      return "varchar";
    } else if (column.type === "simple-array") {
      return "text";
    } else if (column.type === "simple-json") {
      return "text";
    } else if (column.type === "simple-enum") {
      return "varchar";
    } else {
      return column.type || "";
    }
  }
  /**
   * Normalizes "default" value of the column.
   */
  normalizeDefault(columnMetadata) {
    const defaultValue = columnMetadata.default;
    if (typeof defaultValue === "number") {
      return "" + defaultValue;
    }
    if (typeof defaultValue === "boolean") {
      return defaultValue ? "1" : "0";
    }
    if (typeof defaultValue === "function") {
      return defaultValue();
    }
    if (typeof defaultValue === "string") {
      return `'${defaultValue}'`;
    }
    if (defaultValue === null || defaultValue === void 0) {
      return void 0;
    }
    return `${defaultValue}`;
  }
  /**
   * Normalizes "isUnique" value of the column.
   */
  normalizeIsUnique(column) {
    return column.entityMetadata.uniques.some((uq) => uq.columns.length === 1 && uq.columns[0] === column);
  }
  /**
   * Calculates column length taking into account the default length values.
   */
  getColumnLength(column) {
    return column.length ? column.length.toString() : "";
  }
  /**
   * Normalizes "default" value of the column.
   */
  createFullType(column) {
    let type = column.type;
    if (column.enum) {
      return "varchar";
    }
    if (column.length) {
      type += "(" + column.length + ")";
    } else if (column.precision !== null && column.precision !== void 0 && column.scale !== null && column.scale !== void 0) {
      type += "(" + column.precision + "," + column.scale + ")";
    } else if (column.precision !== null && column.precision !== void 0) {
      type += "(" + column.precision + ")";
    }
    if (column.isArray) type += " array";
    return type;
  }
  /**
   * Obtains a new database connection to a master server.
   * Used for replication.
   * If replication is not setup then returns default connection's database connection.
   */
  obtainMasterConnection() {
    return Promise.resolve();
  }
  /**
   * Obtains a new database connection to a slave server.
   * Used for replication.
   * If replication is not setup then returns master (default) connection's database connection.
   */
  obtainSlaveConnection() {
    return Promise.resolve();
  }
  /**
   * Creates generated map of values generated or returned by database after INSERT query.
   */
  createGeneratedMap(metadata, insertResult, entityIndex, entityNum) {
    const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {
      let value;
      if (generatedColumn.generationStrategy === "increment" && insertResult) {
        value = insertResult - entityNum + entityIndex + 1;
      }
      if (!value) return map;
      return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
    }, {});
    return Object.keys(generatedMap).length > 0 ? generatedMap : void 0;
  }
  /**
   * Differentiate columns of this table and columns from the given column metadatas columns
   * and returns only changed.
   */
  findChangedColumns(tableColumns, columnMetadatas) {
    return columnMetadatas.filter((columnMetadata) => {
      const tableColumn = tableColumns.find((c) => c.name === columnMetadata.databaseName);
      if (!tableColumn) return false;
      const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadata.length || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale || this.normalizeDefault(columnMetadata) !== tableColumn.default || tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || tableColumn.enum && columnMetadata.enum && !OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map((val) => val + "")) || columnMetadata.generationStrategy !== "uuid" && tableColumn.isGenerated !== columnMetadata.isGenerated;
      return isColumnChanged;
    });
  }
  /**
   * Returns true if driver supports RETURNING / OUTPUT statement.
   */
  isReturningSqlSupported() {
    return false;
  }
  /**
   * Returns true if driver supports uuid values generation on its own.
   */
  isUUIDGenerationSupported() {
    return false;
  }
  /**
   * Returns true if driver supports fulltext indices.
   */
  isFullTextColumnTypeSupported() {
    return false;
  }
  /**
   * Creates an escaped parameter.
   */
  createParameter(parameterName, index) {
    return "?";
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Creates connection with the database.
   */
  createDatabaseConnection() {
    throw new TypeORMError("Do not use AbstractSqlite directly, it has to be used with one of the sqlite drivers");
  }
  /**
   * If driver dependency is not given explicitly, then try to load it via "require".
   */
  loadDependencies() {
  }
};

// ../node_modules/typeorm/browser/driver/Query.js
var Query = class {
  constructor(query, parameters) {
    this.query = query;
    this.parameters = parameters;
    this["@instanceof"] = Symbol.for("Query");
  }
};

// ../node_modules/typeorm/browser/driver/SqlInMemory.js
var SqlInMemory = class {
  constructor() {
    this.upQueries = [];
    this.downQueries = [];
  }
};

// ../node_modules/typeorm/browser/query-runner/BaseQueryRunner.js
var BaseQueryRunner = class {
  constructor() {
    this.isReleased = false;
    this.isTransactionActive = false;
    this.data = {};
    this.loadedTables = [];
    this.loadedViews = [];
    this.sqlMemoryMode = false;
    this.sqlInMemory = new SqlInMemory();
    this.transactionDepth = 0;
    this.cachedTablePaths = {};
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Called before migrations are run.
   */
  beforeMigration() {
    return __async(this, null, function* () {
    });
  }
  /**
   * Called after migrations are run.
   */
  afterMigration() {
    return __async(this, null, function* () {
    });
  }
  /**
   * Loads given table's data from the database.
   */
  getTable(tablePath) {
    return __async(this, null, function* () {
      this.loadedTables = yield this.loadTables([tablePath]);
      return this.loadedTables.length > 0 ? this.loadedTables[0] : void 0;
    });
  }
  /**
   * Loads all tables (with given names) from the database.
   */
  getTables(tableNames) {
    return __async(this, null, function* () {
      if (!tableNames) {
        return yield this.loadTables(tableNames);
      }
      this.loadedTables = yield this.loadTables(tableNames);
      return this.loadedTables;
    });
  }
  /**
   * Loads given view's data from the database.
   */
  getView(viewPath) {
    return __async(this, null, function* () {
      this.loadedViews = yield this.loadViews([viewPath]);
      return this.loadedViews.length > 0 ? this.loadedViews[0] : void 0;
    });
  }
  /**
   * Loads given view's data from the database.
   */
  getViews(viewPaths) {
    return __async(this, null, function* () {
      this.loadedViews = yield this.loadViews(viewPaths);
      return this.loadedViews;
    });
  }
  /**
   * Enables special query runner mode in which sql queries won't be executed,
   * instead they will be memorized into a special variable inside query runner.
   * You can get memorized sql using getMemorySql() method.
   */
  enableSqlMemory() {
    this.sqlInMemory = new SqlInMemory();
    this.sqlMemoryMode = true;
  }
  /**
   * Disables special query runner mode in which sql queries won't be executed
   * started by calling enableSqlMemory() method.
   *
   * Previously memorized sql will be flushed.
   */
  disableSqlMemory() {
    this.sqlInMemory = new SqlInMemory();
    this.sqlMemoryMode = false;
  }
  /**
   * Flushes all memorized sqls.
   */
  clearSqlMemory() {
    this.sqlInMemory = new SqlInMemory();
  }
  /**
   * Gets sql stored in the memory. Parameters in the sql are already replaced.
   */
  getMemorySql() {
    return this.sqlInMemory;
  }
  /**
   * Executes up sql queries.
   */
  executeMemoryUpSql() {
    return __async(this, null, function* () {
      for (const {
        query,
        parameters
      } of this.sqlInMemory.upQueries) {
        yield this.query(query, parameters);
      }
    });
  }
  /**
   * Executes down sql queries.
   */
  executeMemoryDownSql() {
    return __async(this, null, function* () {
      for (const {
        query,
        parameters
      } of this.sqlInMemory.downQueries.reverse()) {
        yield this.query(query, parameters);
      }
    });
  }
  getReplicationMode() {
    return this.mode;
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Gets view from previously loaded views, otherwise loads it from database.
   */
  getCachedView(viewName) {
    return __async(this, null, function* () {
      const view = this.loadedViews.find((view2) => view2.name === viewName);
      if (view) return view;
      const foundViews = yield this.loadViews([viewName]);
      if (foundViews.length > 0) {
        this.loadedViews.push(foundViews[0]);
        return foundViews[0];
      } else {
        throw new TypeORMError(`View "${viewName}" does not exist.`);
      }
    });
  }
  /**
   * Gets table from previously loaded tables, otherwise loads it from database.
   */
  getCachedTable(tableName) {
    return __async(this, null, function* () {
      if (tableName in this.cachedTablePaths) {
        const tablePath = this.cachedTablePaths[tableName];
        const table = this.loadedTables.find((table2) => this.getTablePath(table2) === tablePath);
        if (table) {
          return table;
        }
      }
      const foundTables = yield this.loadTables([tableName]);
      if (foundTables.length > 0) {
        const foundTablePath = this.getTablePath(foundTables[0]);
        const cachedTable = this.loadedTables.find((table) => this.getTablePath(table) === foundTablePath);
        if (!cachedTable) {
          this.cachedTablePaths[tableName] = this.getTablePath(foundTables[0]);
          this.loadedTables.push(foundTables[0]);
          return foundTables[0];
        } else {
          return cachedTable;
        }
      } else {
        throw new TypeORMError(`Table "${tableName}" does not exist.`);
      }
    });
  }
  /**
   * Replaces loaded table with given changed table.
   */
  replaceCachedTable(table, changedTable) {
    const oldTablePath = this.getTablePath(table);
    const foundTable = this.loadedTables.find((loadedTable) => this.getTablePath(loadedTable) === oldTablePath);
    for (const [key, cachedPath] of Object.entries(this.cachedTablePaths)) {
      if (cachedPath === oldTablePath) {
        this.cachedTablePaths[key] = this.getTablePath(changedTable);
      }
    }
    if (foundTable) {
      foundTable.database = changedTable.database;
      foundTable.schema = changedTable.schema;
      foundTable.name = changedTable.name;
      foundTable.columns = changedTable.columns;
      foundTable.indices = changedTable.indices;
      foundTable.foreignKeys = changedTable.foreignKeys;
      foundTable.uniques = changedTable.uniques;
      foundTable.checks = changedTable.checks;
      foundTable.justCreated = changedTable.justCreated;
      foundTable.engine = changedTable.engine;
      foundTable.comment = changedTable.comment;
    }
  }
  getTablePath(target) {
    const parsed = this.connection.driver.parseTableName(target);
    return this.connection.driver.buildTableName(parsed.tableName, parsed.schema, parsed.database);
  }
  getTypeormMetadataTableName() {
    const options = this.connection.driver.options;
    return this.connection.driver.buildTableName(this.connection.metadataTableName, options.schema, options.database);
  }
  /**
   * Generates SQL query to select record from typeorm metadata table.
   */
  selectTypeormMetadataSql({
    database,
    schema,
    table,
    type,
    name
  }) {
    const qb = this.connection.createQueryBuilder();
    const selectQb = qb.select().from(this.getTypeormMetadataTableName(), "t").where(`${qb.escape("type")} = :type`, {
      type
    }).andWhere(`${qb.escape("name")} = :name`, {
      name
    });
    if (database) {
      selectQb.andWhere(`${qb.escape("database")} = :database`, {
        database
      });
    }
    if (schema) {
      selectQb.andWhere(`${qb.escape("schema")} = :schema`, {
        schema
      });
    }
    if (table) {
      selectQb.andWhere(`${qb.escape("table")} = :table`, {
        table
      });
    }
    const [query, parameters] = selectQb.getQueryAndParameters();
    return new Query(query, parameters);
  }
  /**
   * Generates SQL query to insert a record into typeorm metadata table.
   */
  insertTypeormMetadataSql({
    database,
    schema,
    table,
    type,
    name,
    value
  }) {
    const [query, parameters] = this.connection.createQueryBuilder().insert().into(this.getTypeormMetadataTableName()).values({
      database,
      schema,
      table,
      type,
      name,
      value
    }).getQueryAndParameters();
    return new Query(query, parameters);
  }
  /**
   * Generates SQL query to delete a record from typeorm metadata table.
   */
  deleteTypeormMetadataSql({
    database,
    schema,
    table,
    type,
    name
  }) {
    const qb = this.connection.createQueryBuilder();
    const deleteQb = qb.delete().from(this.getTypeormMetadataTableName()).where(`${qb.escape("type")} = :type`, {
      type
    }).andWhere(`${qb.escape("name")} = :name`, {
      name
    });
    if (database) {
      deleteQb.andWhere(`${qb.escape("database")} = :database`, {
        database
      });
    }
    if (schema) {
      deleteQb.andWhere(`${qb.escape("schema")} = :schema`, {
        schema
      });
    }
    if (table) {
      deleteQb.andWhere(`${qb.escape("table")} = :table`, {
        table
      });
    }
    const [query, parameters] = deleteQb.getQueryAndParameters();
    return new Query(query, parameters);
  }
  /**
   * Checks if at least one of column properties was changed.
   * Does not checks column type, length and autoincrement, because these properties changes separately.
   */
  isColumnChanged(oldColumn, newColumn, checkDefault, checkComment, checkEnum = true) {
    return oldColumn.charset !== newColumn.charset || oldColumn.collation !== newColumn.collation || oldColumn.precision !== newColumn.precision || oldColumn.scale !== newColumn.scale || oldColumn.width !== newColumn.width || // MySQL only
    oldColumn.zerofill !== newColumn.zerofill || // MySQL only
    oldColumn.unsigned !== newColumn.unsigned || // MySQL only
    oldColumn.asExpression !== newColumn.asExpression || checkDefault && oldColumn.default !== newColumn.default || oldColumn.onUpdate !== newColumn.onUpdate || // MySQL only
    oldColumn.isNullable !== newColumn.isNullable || checkComment && oldColumn.comment !== newColumn.comment || checkEnum && this.isEnumChanged(oldColumn, newColumn);
  }
  isEnumChanged(oldColumn, newColumn) {
    return !OrmUtils.isArraysEqual(oldColumn.enum || [], newColumn.enum || []);
  }
  /**
   * Checks if column length is by default.
   */
  isDefaultColumnLength(table, column, length) {
    if (this.connection.hasMetadata(table.name)) {
      const metadata = this.connection.getMetadata(table.name);
      const columnMetadata = metadata.findColumnWithDatabaseName(column.name);
      if (columnMetadata) {
        const columnMetadataLength = this.connection.driver.getColumnLength(columnMetadata);
        if (columnMetadataLength) return false;
      }
    }
    if (this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].length) {
      return this.connection.driver.dataTypeDefaults[column.type].length.toString() === length.toString();
    }
    return false;
  }
  /**
   * Checks if column precision is by default.
   */
  isDefaultColumnPrecision(table, column, precision) {
    if (this.connection.hasMetadata(table.name)) {
      const metadata = this.connection.getMetadata(table.name);
      const columnMetadata = metadata.findColumnWithDatabaseName(column.name);
      if (columnMetadata && columnMetadata.precision !== null && columnMetadata.precision !== void 0) return false;
    }
    if (this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].precision !== null && this.connection.driver.dataTypeDefaults[column.type].precision !== void 0) return this.connection.driver.dataTypeDefaults[column.type].precision === precision;
    return false;
  }
  /**
   * Checks if column scale is by default.
   */
  isDefaultColumnScale(table, column, scale) {
    if (this.connection.hasMetadata(table.name)) {
      const metadata = this.connection.getMetadata(table.name);
      const columnMetadata = metadata.findColumnWithDatabaseName(column.name);
      if (columnMetadata && columnMetadata.scale !== null && columnMetadata.scale !== void 0) return false;
    }
    if (this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].scale !== null && this.connection.driver.dataTypeDefaults[column.type].scale !== void 0) return this.connection.driver.dataTypeDefaults[column.type].scale === scale;
    return false;
  }
  /**
   * Executes sql used special for schema build.
   */
  executeQueries(upQueries, downQueries) {
    return __async(this, null, function* () {
      if (InstanceChecker.isQuery(upQueries)) upQueries = [upQueries];
      if (InstanceChecker.isQuery(downQueries)) downQueries = [downQueries];
      this.sqlInMemory.upQueries.push(...upQueries);
      this.sqlInMemory.downQueries.push(...downQueries);
      if (this.sqlMemoryMode === true) return Promise.resolve();
      for (const {
        query,
        parameters
      } of upQueries) {
        yield this.query(query, parameters);
      }
    });
  }
  /**
   * Generated an index name for a table and index
   */
  generateIndexName(table, index) {
    return this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
  }
};

// ../node_modules/typeorm/browser/driver/types/MetadataTableType.js
var MetadataTableType;
(function(MetadataTableType2) {
  MetadataTableType2["VIEW"] = "VIEW";
  MetadataTableType2["MATERIALIZED_VIEW"] = "MATERIALIZED_VIEW";
  MetadataTableType2["GENERATED_COLUMN"] = "GENERATED_COLUMN";
})(MetadataTableType || (MetadataTableType = {}));

// ../node_modules/typeorm/browser/driver/sqlite-abstract/AbstractSqliteQueryRunner.js
var AbstractSqliteQueryRunner = class extends BaseQueryRunner {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor() {
    super();
    this.transactionPromise = null;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates/uses database connection from the connection pool to perform further operations.
   * Returns obtained database connection.
   */
  connect() {
    return Promise.resolve(this.driver.databaseConnection);
  }
  /**
   * Releases used database connection.
   * We just clear loaded tables and sql in memory, because sqlite do not support multiple connections thus query runners.
   */
  release() {
    this.loadedTables = [];
    this.clearSqlMemory();
    return Promise.resolve();
  }
  /**
   * Starts transaction.
   */
  startTransaction(isolationLevel) {
    return __async(this, null, function* () {
      if (this.driver.transactionSupport === "none") throw new TypeORMError(`Transactions aren't supported by ${this.connection.driver.options.type}.`);
      if (this.isTransactionActive && this.driver.transactionSupport === "simple") throw new TransactionAlreadyStartedError();
      if (isolationLevel && isolationLevel !== "READ UNCOMMITTED" && isolationLevel !== "SERIALIZABLE") throw new TypeORMError(`SQLite only supports SERIALIZABLE and READ UNCOMMITTED isolation`);
      this.isTransactionActive = true;
      try {
        yield this.broadcaster.broadcast("BeforeTransactionStart");
      } catch (err) {
        this.isTransactionActive = false;
        throw err;
      }
      if (this.transactionDepth === 0) {
        this.transactionDepth += 1;
        if (isolationLevel) {
          if (isolationLevel === "READ UNCOMMITTED") {
            yield this.query("PRAGMA read_uncommitted = true");
          } else {
            yield this.query("PRAGMA read_uncommitted = false");
          }
        }
        yield this.query("BEGIN TRANSACTION");
      } else {
        this.transactionDepth += 1;
        yield this.query(`SAVEPOINT typeorm_${this.transactionDepth - 1}`);
      }
      yield this.broadcaster.broadcast("AfterTransactionStart");
    });
  }
  /**
   * Commits transaction.
   * Error will be thrown if transaction was not started.
   */
  commitTransaction() {
    return __async(this, null, function* () {
      if (!this.isTransactionActive) throw new TransactionNotStartedError();
      yield this.broadcaster.broadcast("BeforeTransactionCommit");
      if (this.transactionDepth > 1) {
        this.transactionDepth -= 1;
        yield this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth}`);
      } else {
        this.transactionDepth -= 1;
        yield this.query("COMMIT");
        this.isTransactionActive = false;
      }
      yield this.broadcaster.broadcast("AfterTransactionCommit");
    });
  }
  /**
   * Rollbacks transaction.
   * Error will be thrown if transaction was not started.
   */
  rollbackTransaction() {
    return __async(this, null, function* () {
      if (!this.isTransactionActive) throw new TransactionNotStartedError();
      yield this.broadcaster.broadcast("BeforeTransactionRollback");
      if (this.transactionDepth > 1) {
        this.transactionDepth -= 1;
        yield this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth}`);
      } else {
        this.transactionDepth -= 1;
        yield this.query("ROLLBACK");
        this.isTransactionActive = false;
      }
      yield this.broadcaster.broadcast("AfterTransactionRollback");
    });
  }
  /**
   * Returns raw data stream.
   */
  stream(query, parameters, onEnd, onError) {
    throw new TypeORMError(`Stream is not supported by sqlite driver.`);
  }
  /**
   * Returns all available database names including system databases.
   */
  getDatabases() {
    return __async(this, null, function* () {
      return Promise.resolve([]);
    });
  }
  /**
   * Returns all available schema names including system schemas.
   * If database parameter specified, returns schemas of that database.
   */
  getSchemas(database) {
    return __async(this, null, function* () {
      return Promise.resolve([]);
    });
  }
  /**
   * Checks if database with the given name exist.
   */
  hasDatabase(database) {
    return __async(this, null, function* () {
      return Promise.resolve(false);
    });
  }
  /**
   * Loads currently using database
   */
  getCurrentDatabase() {
    return __async(this, null, function* () {
      return Promise.resolve(void 0);
    });
  }
  /**
   * Checks if schema with the given name exist.
   */
  hasSchema(schema) {
    return __async(this, null, function* () {
      throw new TypeORMError(`This driver does not support table schemas`);
    });
  }
  /**
   * Loads currently using database schema
   */
  getCurrentSchema() {
    return __async(this, null, function* () {
      return Promise.resolve(void 0);
    });
  }
  /**
   * Checks if table with the given name exist in the database.
   */
  hasTable(tableOrName) {
    return __async(this, null, function* () {
      const tableName = InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;
      const sql = `SELECT * FROM "sqlite_master" WHERE "type" = 'table' AND "name" = '${tableName}'`;
      const result = yield this.query(sql);
      return result.length ? true : false;
    });
  }
  /**
   * Checks if column with the given name exist in the given table.
   */
  hasColumn(tableOrName, columnName) {
    return __async(this, null, function* () {
      const tableName = InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;
      const sql = `PRAGMA table_xinfo(${this.escapePath(tableName)})`;
      const columns = yield this.query(sql);
      return !!columns.find((column) => column["name"] === columnName);
    });
  }
  /**
   * Creates a new database.
   */
  createDatabase(database, ifNotExist) {
    return __async(this, null, function* () {
      return Promise.resolve();
    });
  }
  /**
   * Drops database.
   */
  dropDatabase(database, ifExist) {
    return __async(this, null, function* () {
      return Promise.resolve();
    });
  }
  /**
   * Creates a new table schema.
   */
  createSchema(schemaPath, ifNotExist) {
    return __async(this, null, function* () {
      return Promise.resolve();
    });
  }
  /**
   * Drops table schema.
   */
  dropSchema(schemaPath, ifExist) {
    return __async(this, null, function* () {
      return Promise.resolve();
    });
  }
  /**
   * Creates a new table.
   */
  createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {
    return __async(this, null, function* () {
      const upQueries = [];
      const downQueries = [];
      if (ifNotExist) {
        const isTableExist = yield this.hasTable(table);
        if (isTableExist) return Promise.resolve();
      }
      upQueries.push(this.createTableSql(table, createForeignKeys));
      downQueries.push(this.dropTableSql(table));
      if (createIndices) {
        table.indices.forEach((index) => {
          if (!index.name) index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
          upQueries.push(this.createIndexSql(table, index));
          downQueries.push(this.dropIndexSql(index));
        });
      }
      const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
      for (const column of generatedColumns) {
        const insertQuery = this.insertTypeormMetadataSql({
          table: table.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name,
          value: column.asExpression
        });
        const deleteQuery = this.deleteTypeormMetadataSql({
          table: table.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name
        });
        upQueries.push(insertQuery);
        downQueries.push(deleteQuery);
      }
      yield this.executeQueries(upQueries, downQueries);
    });
  }
  /**
   * Drops the table.
   */
  dropTable(tableOrName, ifExist, dropForeignKeys = true, dropIndices = true) {
    return __async(this, null, function* () {
      if (ifExist) {
        const isTableExist = yield this.hasTable(tableOrName);
        if (!isTableExist) return Promise.resolve();
      }
      const createForeignKeys = dropForeignKeys;
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const upQueries = [];
      const downQueries = [];
      if (dropIndices) {
        table.indices.forEach((index) => {
          upQueries.push(this.dropIndexSql(index));
          downQueries.push(this.createIndexSql(table, index));
        });
      }
      upQueries.push(this.dropTableSql(table, ifExist));
      downQueries.push(this.createTableSql(table, createForeignKeys));
      const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
      for (const column of generatedColumns) {
        const deleteQuery = this.deleteTypeormMetadataSql({
          table: table.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name
        });
        const insertQuery = this.insertTypeormMetadataSql({
          table: table.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name,
          value: column.asExpression
        });
        upQueries.push(deleteQuery);
        downQueries.push(insertQuery);
      }
      yield this.executeQueries(upQueries, downQueries);
    });
  }
  /**
   * Creates a new view.
   */
  createView(view, syncWithMetadata = false) {
    return __async(this, null, function* () {
      const upQueries = [];
      const downQueries = [];
      upQueries.push(this.createViewSql(view));
      if (syncWithMetadata) upQueries.push(this.insertViewDefinitionSql(view));
      downQueries.push(this.dropViewSql(view));
      if (syncWithMetadata) downQueries.push(this.deleteViewDefinitionSql(view));
      yield this.executeQueries(upQueries, downQueries);
    });
  }
  /**
   * Drops the view.
   */
  dropView(target) {
    return __async(this, null, function* () {
      const viewName = InstanceChecker.isView(target) ? target.name : target;
      const view = yield this.getCachedView(viewName);
      const upQueries = [];
      const downQueries = [];
      upQueries.push(this.deleteViewDefinitionSql(view));
      upQueries.push(this.dropViewSql(view));
      downQueries.push(this.insertViewDefinitionSql(view));
      downQueries.push(this.createViewSql(view));
      yield this.executeQueries(upQueries, downQueries);
    });
  }
  /**
   * Renames the given table.
   */
  renameTable(oldTableOrName, newTableName) {
    return __async(this, null, function* () {
      const oldTable = InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : yield this.getCachedTable(oldTableOrName);
      const newTable = oldTable.clone();
      newTable.name = newTableName;
      const up = new Query(`ALTER TABLE ${this.escapePath(oldTable.name)} RENAME TO ${this.escapePath(newTableName)}`);
      const down = new Query(`ALTER TABLE ${this.escapePath(newTableName)} RENAME TO ${this.escapePath(oldTable.name)}`);
      yield this.executeQueries(up, down);
      newTable.uniques.forEach((unique) => {
        const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames);
        if (unique.name !== oldUniqueName) return;
        unique.name = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);
      });
      newTable.foreignKeys.forEach((foreignKey) => {
        const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
        if (foreignKey.name !== oldForeignKeyName) return;
        foreignKey.name = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
      });
      newTable.indices.forEach((index) => {
        const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where);
        if (index.name !== oldIndexName) return;
        index.name = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
      });
      oldTable.name = newTable.name;
      yield this.recreateTable(newTable, oldTable);
    });
  }
  /**
   * Creates a new column from the column in the table.
   */
  addColumn(tableOrName, column) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      return this.addColumns(table, [column]);
    });
  }
  /**
   * Creates a new columns from the column in the table.
   */
  addColumns(tableOrName, columns) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const changedTable = table.clone();
      columns.forEach((column) => changedTable.addColumn(column));
      yield this.recreateTable(changedTable, table);
    });
  }
  /**
   * Renames column in the given table.
   */
  renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c) => c.name === oldTableColumnOrName);
      if (!oldColumn) throw new TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
      let newColumn = void 0;
      if (InstanceChecker.isTableColumn(newTableColumnOrName)) {
        newColumn = newTableColumnOrName;
      } else {
        newColumn = oldColumn.clone();
        newColumn.name = newTableColumnOrName;
      }
      return this.changeColumn(table, oldColumn, newColumn);
    });
  }
  /**
   * Changes a column in the table.
   */
  changeColumn(tableOrName, oldTableColumnOrName, newColumn) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c) => c.name === oldTableColumnOrName);
      if (!oldColumn) throw new TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
      yield this.changeColumns(table, [{
        oldColumn,
        newColumn
      }]);
    });
  }
  /**
   * Changes a column in the table.
   * Changed column looses all its keys in the db.
   */
  changeColumns(tableOrName, changedColumns) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const changedTable = table.clone();
      changedColumns.forEach((changedColumnSet) => {
        if (changedColumnSet.newColumn.name !== changedColumnSet.oldColumn.name) {
          changedTable.findColumnUniques(changedColumnSet.oldColumn).forEach((unique) => {
            const uniqueName = this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);
            unique.columnNames.splice(unique.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);
            unique.columnNames.push(changedColumnSet.newColumn.name);
            if (unique.name === uniqueName) {
              unique.name = this.connection.namingStrategy.uniqueConstraintName(changedTable, unique.columnNames);
            }
          });
          changedTable.findColumnForeignKeys(changedColumnSet.oldColumn).forEach((foreignKey) => {
            const foreignKeyName = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
            foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);
            foreignKey.columnNames.push(changedColumnSet.newColumn.name);
            if (foreignKey.name === foreignKeyName) {
              foreignKey.name = this.connection.namingStrategy.foreignKeyName(changedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
            }
          });
          changedTable.findColumnIndices(changedColumnSet.oldColumn).forEach((index) => {
            const indexName = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
            index.columnNames.splice(index.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);
            index.columnNames.push(changedColumnSet.newColumn.name);
            if (index.name === indexName) {
              index.name = this.connection.namingStrategy.indexName(changedTable, index.columnNames, index.where);
            }
          });
        }
        const originalColumn = changedTable.columns.find((column) => column.name === changedColumnSet.oldColumn.name);
        if (originalColumn) changedTable.columns[changedTable.columns.indexOf(originalColumn)] = changedColumnSet.newColumn;
      });
      yield this.recreateTable(changedTable, table);
    });
  }
  /**
   * Drops column in the table.
   */
  dropColumn(tableOrName, columnOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const column = InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);
      if (!column) throw new TypeORMError(`Column "${columnOrName}" was not found in table "${table.name}"`);
      yield this.dropColumns(table, [column]);
    });
  }
  /**
   * Drops the columns in the table.
   */
  dropColumns(tableOrName, columns) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const changedTable = table.clone();
      columns.forEach((column) => {
        const columnInstance = InstanceChecker.isTableColumn(column) ? column : table.findColumnByName(column);
        if (!columnInstance) throw new Error(`Column "${column}" was not found in table "${table.name}"`);
        changedTable.removeColumn(columnInstance);
        changedTable.findColumnUniques(columnInstance).forEach((unique) => changedTable.removeUniqueConstraint(unique));
        changedTable.findColumnIndices(columnInstance).forEach((index) => changedTable.removeIndex(index));
        changedTable.findColumnForeignKeys(columnInstance).forEach((fk) => changedTable.removeForeignKey(fk));
      });
      yield this.recreateTable(changedTable, table);
    });
  }
  /**
   * Creates a new primary key.
   */
  createPrimaryKey(tableOrName, columnNames) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const changedTable = table.clone();
      changedTable.columns.forEach((column) => {
        if (columnNames.find((columnName) => columnName === column.name)) column.isPrimary = true;
      });
      yield this.recreateTable(changedTable, table);
      table.columns.forEach((column) => {
        if (columnNames.find((columnName) => columnName === column.name)) column.isPrimary = true;
      });
    });
  }
  /**
   * Updates composite primary keys.
   */
  updatePrimaryKeys(tableOrName, columns) {
    return __async(this, null, function* () {
      yield Promise.resolve();
    });
  }
  /**
   * Drops a primary key.
   */
  dropPrimaryKey(tableOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const changedTable = table.clone();
      changedTable.primaryColumns.forEach((column) => {
        column.isPrimary = false;
      });
      yield this.recreateTable(changedTable, table);
      table.primaryColumns.forEach((column) => {
        column.isPrimary = false;
      });
    });
  }
  /**
   * Creates a new unique constraint.
   */
  createUniqueConstraint(tableOrName, uniqueConstraint) {
    return __async(this, null, function* () {
      yield this.createUniqueConstraints(tableOrName, [uniqueConstraint]);
    });
  }
  /**
   * Creates a new unique constraints.
   */
  createUniqueConstraints(tableOrName, uniqueConstraints) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const changedTable = table.clone();
      uniqueConstraints.forEach((uniqueConstraint) => changedTable.addUniqueConstraint(uniqueConstraint));
      yield this.recreateTable(changedTable, table);
    });
  }
  /**
   * Drops an unique constraint.
   */
  dropUniqueConstraint(tableOrName, uniqueOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const uniqueConstraint = InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName : table.uniques.find((u) => u.name === uniqueOrName);
      if (!uniqueConstraint) throw new TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);
      yield this.dropUniqueConstraints(table, [uniqueConstraint]);
    });
  }
  /**
   * Creates an unique constraints.
   */
  dropUniqueConstraints(tableOrName, uniqueConstraints) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const changedTable = table.clone();
      uniqueConstraints.forEach((uniqueConstraint) => changedTable.removeUniqueConstraint(uniqueConstraint));
      yield this.recreateTable(changedTable, table);
    });
  }
  /**
   * Creates new check constraint.
   */
  createCheckConstraint(tableOrName, checkConstraint) {
    return __async(this, null, function* () {
      yield this.createCheckConstraints(tableOrName, [checkConstraint]);
    });
  }
  /**
   * Creates new check constraints.
   */
  createCheckConstraints(tableOrName, checkConstraints) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const changedTable = table.clone();
      checkConstraints.forEach((checkConstraint) => changedTable.addCheckConstraint(checkConstraint));
      yield this.recreateTable(changedTable, table);
    });
  }
  /**
   * Drops check constraint.
   */
  dropCheckConstraint(tableOrName, checkOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const checkConstraint = InstanceChecker.isTableCheck(checkOrName) ? checkOrName : table.checks.find((c) => c.name === checkOrName);
      if (!checkConstraint) throw new TypeORMError(`Supplied check constraint was not found in table ${table.name}`);
      yield this.dropCheckConstraints(table, [checkConstraint]);
    });
  }
  /**
   * Drops check constraints.
   */
  dropCheckConstraints(tableOrName, checkConstraints) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const changedTable = table.clone();
      checkConstraints.forEach((checkConstraint) => changedTable.removeCheckConstraint(checkConstraint));
      yield this.recreateTable(changedTable, table);
    });
  }
  /**
   * Creates a new exclusion constraint.
   */
  createExclusionConstraint(tableOrName, exclusionConstraint) {
    return __async(this, null, function* () {
      throw new TypeORMError(`Sqlite does not support exclusion constraints.`);
    });
  }
  /**
   * Creates a new exclusion constraints.
   */
  createExclusionConstraints(tableOrName, exclusionConstraints) {
    return __async(this, null, function* () {
      throw new TypeORMError(`Sqlite does not support exclusion constraints.`);
    });
  }
  /**
   * Drops exclusion constraint.
   */
  dropExclusionConstraint(tableOrName, exclusionOrName) {
    return __async(this, null, function* () {
      throw new TypeORMError(`Sqlite does not support exclusion constraints.`);
    });
  }
  /**
   * Drops exclusion constraints.
   */
  dropExclusionConstraints(tableOrName, exclusionConstraints) {
    return __async(this, null, function* () {
      throw new TypeORMError(`Sqlite does not support exclusion constraints.`);
    });
  }
  /**
   * Creates a new foreign key.
   */
  createForeignKey(tableOrName, foreignKey) {
    return __async(this, null, function* () {
      yield this.createForeignKeys(tableOrName, [foreignKey]);
    });
  }
  /**
   * Creates a new foreign keys.
   */
  createForeignKeys(tableOrName, foreignKeys) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const changedTable = table.clone();
      foreignKeys.forEach((foreignKey) => changedTable.addForeignKey(foreignKey));
      yield this.recreateTable(changedTable, table);
    });
  }
  /**
   * Drops a foreign key from the table.
   */
  dropForeignKey(tableOrName, foreignKeyOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName);
      if (!foreignKey) throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
      yield this.dropForeignKeys(tableOrName, [foreignKey]);
    });
  }
  /**
   * Drops a foreign keys from the table.
   */
  dropForeignKeys(tableOrName, foreignKeys) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const changedTable = table.clone();
      foreignKeys.forEach((foreignKey) => changedTable.removeForeignKey(foreignKey));
      yield this.recreateTable(changedTable, table);
    });
  }
  /**
   * Creates a new index.
   */
  createIndex(tableOrName, index) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      if (!index.name) index.name = this.generateIndexName(table, index);
      const up = this.createIndexSql(table, index);
      const down = this.dropIndexSql(index);
      yield this.executeQueries(up, down);
      table.addIndex(index);
    });
  }
  /**
   * Creates a new indices
   */
  createIndices(tableOrName, indices) {
    return __async(this, null, function* () {
      const promises = indices.map((index) => this.createIndex(tableOrName, index));
      yield Promise.all(promises);
    });
  }
  /**
   * Drops an index from the table.
   */
  dropIndex(tableOrName, indexOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const index = InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find((i) => i.name === indexOrName);
      if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);
      if (!index.name) index.name = this.generateIndexName(table, index);
      const up = this.dropIndexSql(index);
      const down = this.createIndexSql(table, index);
      yield this.executeQueries(up, down);
      table.removeIndex(index);
    });
  }
  /**
   * Drops an indices from the table.
   */
  dropIndices(tableOrName, indices) {
    return __async(this, null, function* () {
      const promises = indices.map((index) => this.dropIndex(tableOrName, index));
      yield Promise.all(promises);
    });
  }
  /**
   * Clears all table contents.
   * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
   */
  clearTable(tableName) {
    return __async(this, null, function* () {
      yield this.query(`DELETE FROM ${this.escapePath(tableName)}`);
    });
  }
  /**
   * Removes all tables from the currently connected database.
   */
  clearDatabase(database) {
    return __async(this, null, function* () {
      let dbPath = void 0;
      if (database && this.driver.getAttachedDatabaseHandleByRelativePath(database)) {
        dbPath = this.driver.getAttachedDatabaseHandleByRelativePath(database);
      }
      yield this.query(`PRAGMA foreign_keys = OFF`);
      const isAnotherTransactionActive = this.isTransactionActive;
      if (!isAnotherTransactionActive) yield this.startTransaction();
      try {
        const selectViewDropsQuery = dbPath ? `SELECT 'DROP VIEW "${dbPath}"."' || name || '";' as query FROM "${dbPath}"."sqlite_master" WHERE "type" = 'view'` : `SELECT 'DROP VIEW "' || name || '";' as query FROM "sqlite_master" WHERE "type" = 'view'`;
        const dropViewQueries = yield this.query(selectViewDropsQuery);
        yield Promise.all(dropViewQueries.map((q) => this.query(q["query"])));
        const selectTableDropsQuery = dbPath ? `SELECT 'DROP TABLE "${dbPath}"."' || name || '";' as query FROM "${dbPath}"."sqlite_master" WHERE "type" = 'table' AND "name" != 'sqlite_sequence'` : `SELECT 'DROP TABLE "' || name || '";' as query FROM "sqlite_master" WHERE "type" = 'table' AND "name" != 'sqlite_sequence'`;
        const dropTableQueries = yield this.query(selectTableDropsQuery);
        yield Promise.all(dropTableQueries.map((q) => this.query(q["query"])));
        if (!isAnotherTransactionActive) yield this.commitTransaction();
      } catch (error) {
        try {
          if (!isAnotherTransactionActive) yield this.rollbackTransaction();
        } catch (rollbackError) {
        }
        throw error;
      } finally {
        yield this.query(`PRAGMA foreign_keys = ON`);
      }
    });
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  loadViews(viewNames) {
    return __async(this, null, function* () {
      const hasTable = yield this.hasTable(this.getTypeormMetadataTableName());
      if (!hasTable) {
        return [];
      }
      if (!viewNames) {
        viewNames = [];
      }
      const viewNamesString = viewNames.map((name) => "'" + name + "'").join(", ");
      let query = `SELECT "t".* FROM "${this.getTypeormMetadataTableName()}" "t" INNER JOIN "sqlite_master" s ON "s"."name" = "t"."name" AND "s"."type" = 'view' WHERE "t"."type" = '${MetadataTableType.VIEW}'`;
      if (viewNamesString.length > 0) query += ` AND "t"."name" IN (${viewNamesString})`;
      const dbViews = yield this.query(query);
      return dbViews.map((dbView) => {
        const view = new View();
        view.name = dbView["name"];
        view.expression = dbView["value"];
        return view;
      });
    });
  }
  loadTableRecords(tablePath, tableOrIndex) {
    return __async(this, null, function* () {
      let database = void 0;
      const [schema, tableName] = this.splitTablePath(tablePath);
      if (schema && this.driver.getAttachedDatabasePathRelativeByHandle(schema)) {
        database = this.driver.getAttachedDatabasePathRelativeByHandle(schema);
      }
      return this.query(`SELECT ${database ? `'${database}'` : null} as database, ${schema ? `'${schema}'` : null} as schema, * FROM ${schema ? `"${schema}".` : ""}${this.escapePath(`sqlite_master`)} WHERE "type" = '${tableOrIndex}' AND "${tableOrIndex === "table" ? "name" : "tbl_name"}" IN ('${tableName}')`);
    });
  }
  loadPragmaRecords(tablePath, pragma) {
    return __async(this, null, function* () {
      const [, tableName] = this.splitTablePath(tablePath);
      return this.query(`PRAGMA ${pragma}("${tableName}")`);
    });
  }
  /**
   * Loads all tables (with given names) from the database and creates a Table from them.
   */
  loadTables(tableNames) {
    return __async(this, null, function* () {
      if (tableNames && tableNames.length === 0) {
        return [];
      }
      let dbTables = [];
      let dbIndicesDef;
      if (!tableNames) {
        const tablesSql = `SELECT * FROM "sqlite_master" WHERE "type" = 'table'`;
        dbTables.push(...yield this.query(tablesSql));
        const tableNamesString = dbTables.map(({
          name
        }) => `'${name}'`).join(", ");
        dbIndicesDef = yield this.query(`SELECT * FROM "sqlite_master" WHERE "type" = 'index' AND "tbl_name" IN (${tableNamesString})`);
      } else {
        const tableNamesWithoutDot = tableNames.filter((tableName) => {
          return tableName.split(".").length === 1;
        }).map((tableName) => `'${tableName}'`);
        const tableNamesWithDot = tableNames.filter((tableName) => {
          return tableName.split(".").length > 1;
        });
        const queryPromises = (type) => {
          const promises = [...tableNamesWithDot.map((tableName) => this.loadTableRecords(tableName, type))];
          if (tableNamesWithoutDot.length) {
            promises.push(this.query(`SELECT * FROM "sqlite_master" WHERE "type" = '${type}' AND "${type === "table" ? "name" : "tbl_name"}" IN (${tableNamesWithoutDot})`));
          }
          return promises;
        };
        dbTables = (yield Promise.all(queryPromises("table"))).reduce((acc, res) => [...acc, ...res], []).filter(Boolean);
        dbIndicesDef = (yield Promise.all(queryPromises("index"))).reduce((acc, res) => [...acc, ...res], []).filter(Boolean);
      }
      if (dbTables.length === 0) {
        return [];
      }
      return Promise.all(dbTables.map((dbTable) => __async(this, null, function* () {
        const tablePath = dbTable["database"] && this.driver.getAttachedDatabaseHandleByRelativePath(dbTable["database"]) ? `${this.driver.getAttachedDatabaseHandleByRelativePath(dbTable["database"])}.${dbTable["name"]}` : dbTable["name"];
        const sql = dbTable["sql"];
        const withoutRowid = sql.includes("WITHOUT ROWID");
        const table = new Table({
          name: tablePath,
          withoutRowid
        });
        const [dbColumns, dbIndices, dbForeignKeys] = yield Promise.all([this.loadPragmaRecords(tablePath, `table_xinfo`), this.loadPragmaRecords(tablePath, `index_list`), this.loadPragmaRecords(tablePath, `foreign_key_list`)]);
        let autoIncrementColumnName = void 0;
        const tableSql = dbTable["sql"];
        let autoIncrementIndex = tableSql.toUpperCase().indexOf("AUTOINCREMENT");
        if (autoIncrementIndex !== -1) {
          autoIncrementColumnName = tableSql.substr(0, autoIncrementIndex);
          const comma = autoIncrementColumnName.lastIndexOf(",");
          const bracket = autoIncrementColumnName.lastIndexOf("(");
          if (comma !== -1) {
            autoIncrementColumnName = autoIncrementColumnName.substr(comma);
            autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf('"'));
            autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf('"') + 1);
          } else if (bracket !== -1) {
            autoIncrementColumnName = autoIncrementColumnName.substr(bracket);
            autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf('"'));
            autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf('"') + 1);
          }
        }
        table.columns = yield Promise.all(dbColumns.map((dbColumn) => __async(this, null, function* () {
          const tableColumn = new TableColumn();
          tableColumn.name = dbColumn["name"];
          tableColumn.type = dbColumn["type"].toLowerCase();
          tableColumn.default = dbColumn["dflt_value"] !== null && dbColumn["dflt_value"] !== void 0 ? dbColumn["dflt_value"] : void 0;
          tableColumn.isNullable = dbColumn["notnull"] === 0;
          tableColumn.isPrimary = dbColumn["pk"] > 0;
          tableColumn.comment = "";
          tableColumn.isGenerated = autoIncrementColumnName === dbColumn["name"];
          if (tableColumn.isGenerated) {
            tableColumn.generationStrategy = "increment";
          }
          if (dbColumn["hidden"] === 2 || dbColumn["hidden"] === 3) {
            tableColumn.generatedType = dbColumn["hidden"] === 2 ? "VIRTUAL" : "STORED";
            const asExpressionQuery = this.selectTypeormMetadataSql({
              table: table.name,
              type: MetadataTableType.GENERATED_COLUMN,
              name: tableColumn.name
            });
            const results = yield this.query(asExpressionQuery.query, asExpressionQuery.parameters);
            if (results[0] && results[0].value) {
              tableColumn.asExpression = results[0].value;
            } else {
              tableColumn.asExpression = "";
            }
          }
          if (tableColumn.type === "varchar") {
            tableColumn.enum = OrmUtils.parseSqlCheckExpression(sql, tableColumn.name);
          }
          let pos = tableColumn.type.indexOf("(");
          if (pos !== -1) {
            const fullType = tableColumn.type;
            let dataType = fullType.substr(0, pos);
            if (this.driver.withLengthColumnTypes.find((col) => col === dataType)) {
              let len = parseInt(fullType.substring(pos + 1, fullType.length - 1));
              if (len) {
                tableColumn.length = len.toString();
                tableColumn.type = dataType;
              }
            }
            if (this.driver.withPrecisionColumnTypes.find((col) => col === dataType)) {
              const re = new RegExp(`^${dataType}\\((\\d+),?\\s?(\\d+)?\\)`);
              const matches = fullType.match(re);
              if (matches && matches[1]) {
                tableColumn.precision = +matches[1];
              }
              if (this.driver.withScaleColumnTypes.find((col) => col === dataType)) {
                if (matches && matches[2]) {
                  tableColumn.scale = +matches[2];
                }
              }
              tableColumn.type = dataType;
            }
          }
          return tableColumn;
        })));
        let fkResult;
        const fkMappings = [];
        const fkRegex = /CONSTRAINT "([^"]*)" FOREIGN KEY ?\((.*?)\) REFERENCES "([^"]*)"/g;
        while ((fkResult = fkRegex.exec(sql)) !== null) {
          fkMappings.push({
            name: fkResult[1],
            columns: fkResult[2].substr(1, fkResult[2].length - 2).split(`", "`),
            referencedTableName: fkResult[3]
          });
        }
        const tableForeignKeyConstraints = OrmUtils.uniq(dbForeignKeys, (dbForeignKey) => dbForeignKey["id"]);
        table.foreignKeys = tableForeignKeyConstraints.map((foreignKey) => {
          const ownForeignKeys = dbForeignKeys.filter((dbForeignKey) => dbForeignKey["id"] === foreignKey["id"] && dbForeignKey["table"] === foreignKey["table"]);
          const columnNames = ownForeignKeys.map((dbForeignKey) => dbForeignKey["from"]);
          const referencedColumnNames = ownForeignKeys.map((dbForeignKey) => dbForeignKey["to"]);
          const fkMapping = fkMappings.find((it) => it.referencedTableName === foreignKey["table"] && it.columns.every((column) => columnNames.indexOf(column) !== -1));
          return new TableForeignKey({
            name: fkMapping?.name,
            columnNames,
            referencedTableName: foreignKey["table"],
            referencedColumnNames,
            onDelete: foreignKey["on_delete"],
            onUpdate: foreignKey["on_update"]
          });
        });
        let uniqueRegexResult;
        const uniqueMappings = [];
        const uniqueRegex = /CONSTRAINT "([^"]*)" UNIQUE ?\((.*?)\)/g;
        while ((uniqueRegexResult = uniqueRegex.exec(sql)) !== null) {
          uniqueMappings.push({
            name: uniqueRegexResult[1],
            columns: uniqueRegexResult[2].substr(1, uniqueRegexResult[2].length - 2).split(`", "`)
          });
        }
        const tableUniquePromises = dbIndices.filter((dbIndex) => dbIndex["origin"] === "u").map((dbIndex) => dbIndex["name"]).filter((value, index, self2) => self2.indexOf(value) === index).map((dbIndexName) => __async(this, null, function* () {
          const dbIndex = dbIndices.find((dbIndex2) => dbIndex2["name"] === dbIndexName);
          const indexInfos = yield this.query(`PRAGMA index_info("${dbIndex["name"]}")`);
          const indexColumns = indexInfos.sort((indexInfo1, indexInfo2) => parseInt(indexInfo1["seqno"]) - parseInt(indexInfo2["seqno"])).map((indexInfo) => indexInfo["name"]);
          if (indexColumns.length === 1) {
            const column = table.columns.find((column2) => {
              return !!indexColumns.find((indexColumn) => indexColumn === column2.name);
            });
            if (column) column.isUnique = true;
          }
          const foundMapping = uniqueMappings.find((mapping) => {
            return mapping.columns.every((column) => indexColumns.indexOf(column) !== -1);
          });
          return new TableUnique({
            name: foundMapping ? foundMapping.name : this.connection.namingStrategy.uniqueConstraintName(table, indexColumns),
            columnNames: indexColumns
          });
        }));
        table.uniques = yield Promise.all(tableUniquePromises);
        let result;
        const regexp = /CONSTRAINT "([^"]*)" CHECK ?(\(.*?\))([,]|[)]$)/g;
        while ((result = regexp.exec(sql)) !== null) {
          table.checks.push(new TableCheck({
            name: result[1],
            expression: result[2]
          }));
        }
        const indicesPromises = dbIndices.filter((dbIndex) => dbIndex["origin"] === "c").map((dbIndex) => dbIndex["name"]).filter((value, index, self2) => self2.indexOf(value) === index).map((dbIndexName) => __async(this, null, function* () {
          const indexDef = dbIndicesDef.find((dbIndexDef) => dbIndexDef["name"] === dbIndexName);
          const condition = /WHERE (.*)/.exec(indexDef["sql"]);
          const dbIndex = dbIndices.find((dbIndex2) => dbIndex2["name"] === dbIndexName);
          const indexInfos = yield this.query(`PRAGMA index_info("${dbIndex["name"]}")`);
          const indexColumns = indexInfos.sort((indexInfo1, indexInfo2) => parseInt(indexInfo1["seqno"]) - parseInt(indexInfo2["seqno"])).map((indexInfo) => indexInfo["name"]);
          const dbIndexPath = `${dbTable["database"] ? `${dbTable["database"]}.` : ""}${dbIndex["name"]}`;
          const isUnique = dbIndex["unique"] === "1" || dbIndex["unique"] === 1;
          return new TableIndex({
            table,
            name: dbIndexPath,
            columnNames: indexColumns,
            isUnique,
            where: condition ? condition[1] : void 0
          });
        }));
        const indices = yield Promise.all(indicesPromises);
        table.indices = indices.filter((index) => !!index);
        return table;
      })));
    });
  }
  /**
   * Builds create table sql.
   */
  createTableSql(table, createForeignKeys, temporaryTable) {
    const primaryColumns = table.columns.filter((column) => column.isPrimary);
    const hasAutoIncrement = primaryColumns.find((column) => column.isGenerated && column.generationStrategy === "increment");
    const skipPrimary = primaryColumns.length > 1;
    if (skipPrimary && hasAutoIncrement) throw new TypeORMError(`Sqlite does not support AUTOINCREMENT on composite primary key`);
    const columnDefinitions = table.columns.map((column) => this.buildCreateColumnSql(column, skipPrimary)).join(", ");
    const [database] = this.splitTablePath(table.name);
    let sql = `CREATE TABLE ${this.escapePath(table.name)} (${columnDefinitions}`;
    let [databaseNew, tableName] = this.splitTablePath(table.name);
    const newTableName = temporaryTable ? `${databaseNew ? `${databaseNew}.` : ""}${tableName.replace(/^temporary_/, "")}` : table.name;
    table.columns.filter((column) => column.isUnique).forEach((column) => {
      const isUniqueExist = table.uniques.some((unique) => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);
      if (!isUniqueExist) table.uniques.push(new TableUnique({
        name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
        columnNames: [column.name]
      }));
    });
    if (table.uniques.length > 0) {
      const uniquesSql = table.uniques.map((unique) => {
        const uniqueName = unique.name ? unique.name : this.connection.namingStrategy.uniqueConstraintName(newTableName, unique.columnNames);
        const columnNames = unique.columnNames.map((columnName) => `"${columnName}"`).join(", ");
        return `CONSTRAINT "${uniqueName}" UNIQUE (${columnNames})`;
      }).join(", ");
      sql += `, ${uniquesSql}`;
    }
    if (table.checks.length > 0) {
      const checksSql = table.checks.map((check) => {
        const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(newTableName, check.expression);
        return `CONSTRAINT "${checkName}" CHECK (${check.expression})`;
      }).join(", ");
      sql += `, ${checksSql}`;
    }
    if (table.foreignKeys.length > 0 && createForeignKeys) {
      const foreignKeysSql = table.foreignKeys.filter((fk) => {
        const [referencedDatabase] = this.splitTablePath(fk.referencedTableName);
        if (referencedDatabase !== database) {
          return false;
        }
        return true;
      }).map((fk) => {
        const [, referencedTable] = this.splitTablePath(fk.referencedTableName);
        const columnNames = fk.columnNames.map((columnName) => `"${columnName}"`).join(", ");
        if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(newTableName, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);
        const referencedColumnNames = fk.referencedColumnNames.map((columnName) => `"${columnName}"`).join(", ");
        let constraint = `CONSTRAINT "${fk.name}" FOREIGN KEY (${columnNames}) REFERENCES "${referencedTable}" (${referencedColumnNames})`;
        if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`;
        if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`;
        if (fk.deferrable) constraint += ` DEFERRABLE ${fk.deferrable}`;
        return constraint;
      }).join(", ");
      sql += `, ${foreignKeysSql}`;
    }
    if (primaryColumns.length > 1) {
      const columnNames = primaryColumns.map((column) => `"${column.name}"`).join(", ");
      sql += `, PRIMARY KEY (${columnNames})`;
    }
    sql += `)`;
    if (table.withoutRowid) {
      sql += " WITHOUT ROWID";
    }
    return new Query(sql);
  }
  /**
   * Builds drop table sql.
   */
  dropTableSql(tableOrName, ifExist) {
    const tableName = InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;
    const query = ifExist ? `DROP TABLE IF EXISTS ${this.escapePath(tableName)}` : `DROP TABLE ${this.escapePath(tableName)}`;
    return new Query(query);
  }
  createViewSql(view) {
    if (typeof view.expression === "string") {
      return new Query(`CREATE VIEW "${view.name}" AS ${view.expression}`);
    } else {
      return new Query(`CREATE VIEW "${view.name}" AS ${view.expression(this.connection).getQuery()}`);
    }
  }
  insertViewDefinitionSql(view) {
    const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
    return this.insertTypeormMetadataSql({
      type: MetadataTableType.VIEW,
      name: view.name,
      value: expression
    });
  }
  /**
   * Builds drop view sql.
   */
  dropViewSql(viewOrPath) {
    const viewName = InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;
    return new Query(`DROP VIEW "${viewName}"`);
  }
  /**
   * Builds remove view sql.
   */
  deleteViewDefinitionSql(viewOrPath) {
    const viewName = InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;
    return this.deleteTypeormMetadataSql({
      type: MetadataTableType.VIEW,
      name: viewName
    });
  }
  /**
   * Builds create index sql.
   */
  createIndexSql(table, index) {
    const columns = index.columnNames.map((columnName) => `"${columnName}"`).join(", ");
    const [database, tableName] = this.splitTablePath(table.name);
    return new Query(`CREATE ${index.isUnique ? "UNIQUE " : ""}INDEX ${database ? `"${database}".` : ""}${this.escapePath(index.name)} ON "${tableName}" (${columns}) ${index.where ? "WHERE " + index.where : ""}`);
  }
  /**
   * Builds drop index sql.
   */
  dropIndexSql(indexOrName) {
    let indexName = InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;
    return new Query(`DROP INDEX ${this.escapePath(indexName)}`);
  }
  /**
   * Builds a query for create column.
   */
  buildCreateColumnSql(column, skipPrimary) {
    let c = '"' + column.name + '"';
    if (InstanceChecker.isColumnMetadata(column)) {
      c += " " + this.driver.normalizeType(column);
    } else {
      c += " " + this.connection.driver.createFullType(column);
    }
    if (column.enum) c += ' CHECK( "' + column.name + '" IN (' + column.enum.map((val) => "'" + val + "'").join(",") + ") )";
    if (column.isPrimary && !skipPrimary) c += " PRIMARY KEY";
    if (column.isGenerated === true && column.generationStrategy === "increment")
      c += " AUTOINCREMENT";
    if (column.collation) c += " COLLATE " + column.collation;
    if (column.isNullable !== true) c += " NOT NULL";
    if (column.asExpression) {
      c += ` AS (${column.asExpression}) ${column.generatedType ? column.generatedType : "VIRTUAL"}`;
    } else {
      if (column.default !== void 0 && column.default !== null) c += " DEFAULT (" + column.default + ")";
    }
    return c;
  }
  recreateTable(newTable, oldTable, migrateData = true) {
    return __async(this, null, function* () {
      const upQueries = [];
      const downQueries = [];
      oldTable.indices.forEach((index) => {
        upQueries.push(this.dropIndexSql(index));
        downQueries.push(this.createIndexSql(oldTable, index));
      });
      let [databaseNew, tableNameNew] = this.splitTablePath(newTable.name);
      let [, tableNameOld] = this.splitTablePath(oldTable.name);
      newTable.name = tableNameNew = `${databaseNew ? `${databaseNew}.` : ""}temporary_${tableNameNew}`;
      upQueries.push(this.createTableSql(newTable, true, true));
      downQueries.push(this.dropTableSql(newTable));
      if (migrateData) {
        let newColumnNames = newTable.columns.filter((column) => !column.generatedType).map((column) => `"${column.name}"`);
        let oldColumnNames = oldTable.columns.filter((column) => !column.generatedType).map((column) => `"${column.name}"`);
        if (oldColumnNames.length < newColumnNames.length) {
          newColumnNames = newTable.columns.filter((column) => {
            const oldColumn = oldTable.columns.find((c) => c.name === column.name);
            if (oldColumn && oldColumn.generatedType) return false;
            return !column.generatedType && oldColumn;
          }).map((column) => `"${column.name}"`);
        } else if (oldColumnNames.length > newColumnNames.length) {
          oldColumnNames = oldTable.columns.filter((column) => {
            return !column.generatedType && newTable.columns.find((c) => c.name === column.name);
          }).map((column) => `"${column.name}"`);
        }
        upQueries.push(new Query(`INSERT INTO ${this.escapePath(newTable.name)}(${newColumnNames.join(", ")}) SELECT ${oldColumnNames.join(", ")} FROM ${this.escapePath(oldTable.name)}`));
        downQueries.push(new Query(`INSERT INTO ${this.escapePath(oldTable.name)}(${oldColumnNames.join(", ")}) SELECT ${newColumnNames.join(", ")} FROM ${this.escapePath(newTable.name)}`));
      }
      upQueries.push(this.dropTableSql(oldTable));
      downQueries.push(this.createTableSql(oldTable, true));
      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable.name)} RENAME TO ${this.escapePath(tableNameOld)}`));
      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(oldTable.name)} RENAME TO ${this.escapePath(tableNameNew)}`));
      newTable.name = oldTable.name;
      newTable.indices.forEach((index) => {
        if (!index.name) index.name = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
        upQueries.push(this.createIndexSql(newTable, index));
        downQueries.push(this.dropIndexSql(index));
      });
      oldTable.columns.filter((column) => {
        const newTableColumn = newTable.columns.find((c) => c.name === column.name);
        return column.generatedType && column.asExpression && (!newTableColumn || !newTableColumn.generatedType && !newTableColumn.asExpression);
      }).forEach((column) => {
        const deleteQuery = this.deleteTypeormMetadataSql({
          table: oldTable.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name
        });
        const insertQuery = this.insertTypeormMetadataSql({
          table: oldTable.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name,
          value: column.asExpression
        });
        upQueries.push(deleteQuery);
        downQueries.push(insertQuery);
      });
      newTable.columns.filter((column) => column.generatedType && column.asExpression && !oldTable.columns.some((c) => c.name === column.name)).forEach((column) => {
        const insertQuery = this.insertTypeormMetadataSql({
          table: newTable.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name,
          value: column.asExpression
        });
        const deleteQuery = this.deleteTypeormMetadataSql({
          table: newTable.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name
        });
        upQueries.push(insertQuery);
        downQueries.push(deleteQuery);
      });
      newTable.columns.filter((column) => column.generatedType && column.asExpression).forEach((column) => {
        const oldColumn = oldTable.columns.find((c) => c.name === column.name && c.generatedType && column.generatedType && c.asExpression !== column.asExpression);
        if (!oldColumn) return;
        const deleteQuery = this.deleteTypeormMetadataSql({
          table: oldTable.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: oldColumn.name
        });
        const insertQuery = this.insertTypeormMetadataSql({
          table: newTable.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name,
          value: column.asExpression
        });
        upQueries.push(deleteQuery);
        upQueries.push(insertQuery);
        const revertInsertQuery = this.insertTypeormMetadataSql({
          table: newTable.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: oldColumn.name,
          value: oldColumn.asExpression
        });
        const revertDeleteQuery = this.deleteTypeormMetadataSql({
          table: oldTable.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name
        });
        downQueries.push(revertInsertQuery);
        downQueries.push(revertDeleteQuery);
      });
      yield this.executeQueries(upQueries, downQueries);
      this.replaceCachedTable(oldTable, newTable);
    });
  }
  /**
   * tablePath e.g. "myDB.myTable", "myTable"
   */
  splitTablePath(tablePath) {
    return tablePath.indexOf(".") !== -1 ? tablePath.split(".") : [void 0, tablePath];
  }
  /**
   * Escapes given table or view path. Tolerates leading/trailing dots
   */
  escapePath(target, disableEscape) {
    const tableName = InstanceChecker.isTable(target) || InstanceChecker.isView(target) ? target.name : target;
    return tableName.replace(/^\.+|\.+$/g, "").split(".").map((i) => disableEscape ? i : `"${i}"`).join(".");
  }
  /**
   * Change table comment.
   */
  changeTableComment(tableOrName, comment) {
    throw new TypeORMError(`sqlit driver does not support change comment.`);
  }
};

// ../node_modules/typeorm/browser/subscriber/Broadcaster.js
var Broadcaster = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(queryRunner) {
    this.queryRunner = queryRunner;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  broadcast(event, ...args) {
    return __async(this, null, function* () {
      const result = new BroadcasterResult();
      const broadcastFunction = this[`broadcast${event}Event`];
      if (typeof broadcastFunction === "function") {
        ;
        broadcastFunction.call(this, result, ...args);
      }
      yield result.wait();
    });
  }
  /**
   * Broadcasts "BEFORE_INSERT" event.
   * Before insert event is executed before entity is being inserted to the database for the first time.
   * All subscribers and entity listeners who listened to this event will be executed at this point.
   * Subscribers and entity listeners can return promises, it will wait until they are resolved.
   *
   * Note: this method has a performance-optimized code organization, do not change code structure.
   */
  broadcastBeforeInsertEvent(result, metadata, entity) {
    if (entity && metadata.beforeInsertListeners.length) {
      metadata.beforeInsertListeners.forEach((listener) => {
        if (listener.isAllowed(entity)) {
          const executionResult = listener.execute(entity);
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeInsert) {
          const executionResult = subscriber.beforeInsert({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager,
            entity,
            metadata
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * Broadcasts "BEFORE_UPDATE" event.
   * Before update event is executed before entity is being updated in the database.
   * All subscribers and entity listeners who listened to this event will be executed at this point.
   * Subscribers and entity listeners can return promises, it will wait until they are resolved.
   *
   * Note: this method has a performance-optimized code organization, do not change code structure.
   */
  broadcastBeforeUpdateEvent(result, metadata, entity, databaseEntity, updatedColumns, updatedRelations) {
    if (entity && metadata.beforeUpdateListeners.length) {
      metadata.beforeUpdateListeners.forEach((listener) => {
        if (listener.isAllowed(entity)) {
          const executionResult = listener.execute(entity);
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeUpdate) {
          const executionResult = subscriber.beforeUpdate({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager,
            entity,
            metadata,
            databaseEntity,
            updatedColumns: updatedColumns || [],
            updatedRelations: updatedRelations || []
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * Broadcasts "BEFORE_REMOVE" event.
   * Before remove event is executed before entity is being removed from the database.
   * All subscribers and entity listeners who listened to this event will be executed at this point.
   * Subscribers and entity listeners can return promises, it will wait until they are resolved.
   *
   * Note: this method has a performance-optimized code organization, do not change code structure.
   */
  broadcastBeforeRemoveEvent(result, metadata, entity, databaseEntity, identifier) {
    if (entity && metadata.beforeRemoveListeners.length) {
      metadata.beforeRemoveListeners.forEach((listener) => {
        if (listener.isAllowed(entity)) {
          const executionResult = listener.execute(entity);
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeRemove) {
          const executionResult = subscriber.beforeRemove({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager,
            entity,
            metadata,
            databaseEntity,
            entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * Broadcasts "BEFORE_SOFT_REMOVE" event.
   * Before soft remove event is executed before entity is being soft removed from the database.
   * All subscribers and entity listeners who listened to this event will be executed at this point.
   * Subscribers and entity listeners can return promises, it will wait until they are resolved.
   *
   * Note: this method has a performance-optimized code organization, do not change code structure.
   */
  broadcastBeforeSoftRemoveEvent(result, metadata, entity, databaseEntity, identifier) {
    if (entity && metadata.beforeSoftRemoveListeners.length) {
      metadata.beforeSoftRemoveListeners.forEach((listener) => {
        if (listener.isAllowed(entity)) {
          const executionResult = listener.execute(entity);
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeSoftRemove) {
          const executionResult = subscriber.beforeSoftRemove({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager,
            entity,
            metadata,
            databaseEntity,
            entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * Broadcasts "BEFORE_RECOVER" event.
   * Before recover event is executed before entity is being recovered in the database.
   * All subscribers and entity listeners who listened to this event will be executed at this point.
   * Subscribers and entity listeners can return promises, it will wait until they are resolved.
   *
   * Note: this method has a performance-optimized code organization, do not change code structure.
   */
  broadcastBeforeRecoverEvent(result, metadata, entity, databaseEntity, identifier) {
    if (entity && metadata.beforeRecoverListeners.length) {
      metadata.beforeRecoverListeners.forEach((listener) => {
        if (listener.isAllowed(entity)) {
          const executionResult = listener.execute(entity);
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeRecover) {
          const executionResult = subscriber.beforeRecover({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager,
            entity,
            metadata,
            databaseEntity,
            entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * Broadcasts "AFTER_INSERT" event.
   * After insert event is executed after entity is being persisted to the database for the first time.
   * All subscribers and entity listeners who listened to this event will be executed at this point.
   * Subscribers and entity listeners can return promises, it will wait until they are resolved.
   *
   * Note: this method has a performance-optimized code organization, do not change code structure.
   */
  broadcastAfterInsertEvent(result, metadata, entity, identifier) {
    if (entity && metadata.afterInsertListeners.length) {
      metadata.afterInsertListeners.forEach((listener) => {
        if (listener.isAllowed(entity)) {
          const executionResult = listener.execute(entity);
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterInsert) {
          const executionResult = subscriber.afterInsert({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager,
            entity,
            metadata,
            entityId: metadata.getEntityIdMixedMap(identifier)
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * Broadcasts "BEFORE_QUERY" event.
   */
  broadcastBeforeQueryEvent(result, query, parameters) {
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (subscriber.beforeQuery) {
          const executionResult = subscriber.beforeQuery({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager,
            query,
            parameters
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * Broadcasts "AFTER_QUERY" event.
   */
  broadcastAfterQueryEvent(result, query, parameters, success, executionTime, rawResults, error) {
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (subscriber.afterQuery) {
          const executionResult = subscriber.afterQuery({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager,
            query,
            parameters,
            success,
            executionTime,
            rawResults,
            error
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * Broadcasts "BEFORE_TRANSACTION_START" event.
   */
  broadcastBeforeTransactionStartEvent(result) {
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (subscriber.beforeTransactionStart) {
          const executionResult = subscriber.beforeTransactionStart({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * Broadcasts "AFTER_TRANSACTION_START" event.
   */
  broadcastAfterTransactionStartEvent(result) {
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (subscriber.afterTransactionStart) {
          const executionResult = subscriber.afterTransactionStart({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * Broadcasts "BEFORE_TRANSACTION_COMMIT" event.
   */
  broadcastBeforeTransactionCommitEvent(result) {
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (subscriber.beforeTransactionCommit) {
          const executionResult = subscriber.beforeTransactionCommit({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * Broadcasts "AFTER_TRANSACTION_COMMIT" event.
   */
  broadcastAfterTransactionCommitEvent(result) {
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (subscriber.afterTransactionCommit) {
          const executionResult = subscriber.afterTransactionCommit({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * Broadcasts "BEFORE_TRANSACTION_ROLLBACK" event.
   */
  broadcastBeforeTransactionRollbackEvent(result) {
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (subscriber.beforeTransactionRollback) {
          const executionResult = subscriber.beforeTransactionRollback({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * Broadcasts "AFTER_TRANSACTION_ROLLBACK" event.
   */
  broadcastAfterTransactionRollbackEvent(result) {
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (subscriber.afterTransactionRollback) {
          const executionResult = subscriber.afterTransactionRollback({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * Broadcasts "AFTER_UPDATE" event.
   * After update event is executed after entity is being updated in the database.
   * All subscribers and entity listeners who listened to this event will be executed at this point.
   * Subscribers and entity listeners can return promises, it will wait until they are resolved.
   *
   * Note: this method has a performance-optimized code organization, do not change code structure.
   */
  broadcastAfterUpdateEvent(result, metadata, entity, databaseEntity, updatedColumns, updatedRelations) {
    if (entity && metadata.afterUpdateListeners.length) {
      metadata.afterUpdateListeners.forEach((listener) => {
        if (listener.isAllowed(entity)) {
          const executionResult = listener.execute(entity);
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterUpdate) {
          const executionResult = subscriber.afterUpdate({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager,
            entity,
            metadata,
            databaseEntity,
            updatedColumns: updatedColumns || [],
            updatedRelations: updatedRelations || []
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * Broadcasts "AFTER_REMOVE" event.
   * After remove event is executed after entity is being removed from the database.
   * All subscribers and entity listeners who listened to this event will be executed at this point.
   * Subscribers and entity listeners can return promises, it will wait until they are resolved.
   *
   * Note: this method has a performance-optimized code organization, do not change code structure.
   */
  broadcastAfterRemoveEvent(result, metadata, entity, databaseEntity, identifier) {
    if (entity && metadata.afterRemoveListeners.length) {
      metadata.afterRemoveListeners.forEach((listener) => {
        if (listener.isAllowed(entity)) {
          const executionResult = listener.execute(entity);
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterRemove) {
          const executionResult = subscriber.afterRemove({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager,
            entity,
            metadata,
            databaseEntity,
            entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * Broadcasts "AFTER_SOFT_REMOVE" event.
   * After soft remove event is executed after entity is being soft removed from the database.
   * All subscribers and entity listeners who listened to this event will be executed at this point.
   * Subscribers and entity listeners can return promises, it will wait until they are resolved.
   *
   * Note: this method has a performance-optimized code organization, do not change code structure.
   */
  broadcastAfterSoftRemoveEvent(result, metadata, entity, databaseEntity, identifier) {
    if (entity && metadata.afterSoftRemoveListeners.length) {
      metadata.afterSoftRemoveListeners.forEach((listener) => {
        if (listener.isAllowed(entity)) {
          const executionResult = listener.execute(entity);
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterSoftRemove) {
          const executionResult = subscriber.afterSoftRemove({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager,
            entity,
            metadata,
            databaseEntity,
            entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * Broadcasts "AFTER_RECOVER" event.
   * After recover event is executed after entity is being recovered in the database.
   * All subscribers and entity listeners who listened to this event will be executed at this point.
   * Subscribers and entity listeners can return promises, it will wait until they are resolved.
   *
   * Note: this method has a performance-optimized code organization, do not change code structure.
   */
  broadcastAfterRecoverEvent(result, metadata, entity, databaseEntity, identifier) {
    if (entity && metadata.afterRecoverListeners.length) {
      metadata.afterRecoverListeners.forEach((listener) => {
        if (listener.isAllowed(entity)) {
          const executionResult = listener.execute(entity);
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
    if (this.queryRunner.connection.subscribers.length) {
      this.queryRunner.connection.subscribers.forEach((subscriber) => {
        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterRecover) {
          const executionResult = subscriber.afterRecover({
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager,
            entity,
            metadata,
            databaseEntity,
            entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        }
      });
    }
  }
  /**
   * @deprecated Use `broadcastLoadForAllEvent`
   */
  broadcastLoadEventsForAll(result, metadata, entities) {
    return this.broadcastLoadEvent(result, metadata, entities);
  }
  /**
   * Broadcasts "AFTER_LOAD" event for all given entities, and their sub-entities.
   * After load event is executed after entity has been loaded from the database.
   * All subscribers and entity listeners who listened to this event will be executed at this point.
   * Subscribers and entity listeners can return promises, it will wait until they are resolved.
   *
   * Note: this method has a performance-optimized code organization, do not change code structure.
   */
  broadcastLoadEvent(result, metadata, entities) {
    const fittingSubscribers = this.queryRunner.connection.subscribers.filter((subscriber) => this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterLoad);
    if (metadata.relations.length || metadata.afterLoadListeners.length || fittingSubscribers.length) {
      const nonPromiseEntities = entities.filter((entity) => !(entity instanceof Promise));
      if (metadata.relations.length) {
        metadata.relations.forEach((relation) => {
          nonPromiseEntities.forEach((entity) => {
            if (relation.isLazy && !entity.hasOwnProperty(relation.propertyName)) return;
            const value = relation.getEntityValue(entity);
            if (ObjectUtils.isObject(value)) this.broadcastLoadEvent(result, relation.inverseEntityMetadata, Array.isArray(value) ? value : [value]);
          });
        });
      }
      if (metadata.afterLoadListeners.length) {
        metadata.afterLoadListeners.forEach((listener) => {
          nonPromiseEntities.forEach((entity) => {
            if (listener.isAllowed(entity)) {
              const executionResult = listener.execute(entity);
              if (executionResult instanceof Promise) result.promises.push(executionResult);
              result.count++;
            }
          });
        });
      }
      fittingSubscribers.forEach((subscriber) => {
        nonPromiseEntities.forEach((entity) => {
          const executionResult = subscriber.afterLoad(entity, {
            entity,
            metadata,
            connection: this.queryRunner.connection,
            queryRunner: this.queryRunner,
            manager: this.queryRunner.manager
          });
          if (executionResult instanceof Promise) result.promises.push(executionResult);
          result.count++;
        });
      });
    }
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,
   * or listens our entity.
   */
  isAllowedSubscriber(subscriber, target) {
    return !subscriber.listenTo || !subscriber.listenTo() || subscriber.listenTo() === Object || subscriber.listenTo() === target || subscriber.listenTo().isPrototypeOf(target);
  }
};

// ../node_modules/typeorm/browser/query-runner/QueryResult.js
var QueryResult = class {
  constructor() {
    this.records = [];
  }
};

// ../node_modules/typeorm/browser/driver/cordova/CordovaQueryRunner.js
var CordovaQueryRunner = class extends AbstractSqliteQueryRunner {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(driver) {
    super();
    this.driver = driver;
    this.connection = driver.connection;
    this.broadcaster = new Broadcaster(this);
  }
  /**
   * Called before migrations are run.
   */
  beforeMigration() {
    return __async(this, null, function* () {
      yield this.query(`PRAGMA foreign_keys = OFF`);
    });
  }
  /**
   * Called after migrations are run.
   */
  afterMigration() {
    return __async(this, null, function* () {
      yield this.query(`PRAGMA foreign_keys = ON`);
    });
  }
  /**
   * Executes a given SQL query.
   */
  query(query, parameters, useStructuredResult = false) {
    return __async(this, null, function* () {
      if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();
      const databaseConnection = yield this.connect();
      const broadcasterResult = new BroadcasterResult();
      this.driver.connection.logger.logQuery(query, parameters, this);
      this.broadcaster.broadcastBeforeQueryEvent(broadcasterResult, query, parameters);
      const queryStartTime = +/* @__PURE__ */ new Date();
      try {
        const raw = yield new Promise((ok, fail) => __async(this, null, function* () {
          databaseConnection.executeSql(query, parameters, (raw2) => ok(raw2), (err) => fail(err));
        }));
        const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
        const queryEndTime = +/* @__PURE__ */ new Date();
        const queryExecutionTime = queryEndTime - queryStartTime;
        this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, void 0);
        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {
          this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
        }
        const result = new QueryResult();
        if (query.substr(0, 11) === "INSERT INTO") {
          result.raw = raw.insertId;
        } else {
          let resultSet = [];
          for (let i = 0; i < raw.rows.length; i++) {
            resultSet.push(raw.rows.item(i));
          }
          result.records = resultSet;
          result.raw = resultSet;
        }
        if (useStructuredResult) {
          return result;
        } else {
          return result.raw;
        }
      } catch (err) {
        this.driver.connection.logger.logQueryError(err, query, parameters, this);
        this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
        throw new QueryFailedError(query, parameters, err);
      } finally {
        yield broadcasterResult.wait();
      }
    });
  }
  /**
   * Insert a new row with given values into the given table.
   * Returns value of the generated column if given and generate column exist in the table.
   // todo: implement new syntax
  async insert(tableName: string, keyValues: ObjectLiteral): Promise<InsertResult> {
      const keys = Object.keys(keyValues);
      const columns = keys.map(key => `"${key}"`).join(", ");
      const values = keys.map(key => "?").join(",");
      const generatedColumns = this.connection.hasMetadata(tableName) ? this.connection.getMetadata(tableName).generatedColumns : [];
      const sql = columns.length > 0 ? (`INSERT INTO "${tableName}"(${columns}) VALUES (${values})`) : `INSERT INTO "${tableName}" DEFAULT VALUES`;
      const parameters = keys.map(key => keyValues[key]);
       return new Promise<InsertResult>(async (ok, fail) => {
          this.driver.connection.logger.logQuery(sql, parameters, this);
          const __this = this;
          const databaseConnection = await this.connect();
          databaseConnection.executeSql(sql, parameters, (resultSet: any) => {
              const generatedMap = generatedColumns.reduce((map, generatedColumn) => {
                  const value = generatedColumn.isPrimary && generatedColumn.generationStrategy === "increment" && resultSet.insertId ? resultSet.insertId : keyValues[generatedColumn.databaseName];
                  if (!value) return map;
                  return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
              }, {} as ObjectLiteral);
               ok({
                  result: undefined,
                  generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined
              });
          }, (err: any) => {
              __this.driver.connection.logger.logQueryError(err, sql, parameters, this);
              fail(err);
          });
      });
  }*/
  /**
   * Would start a transaction but this driver does not support transactions.
   */
  startTransaction() {
    return __async(this, null, function* () {
      throw new TypeORMError("Transactions are not supported by the Cordova driver");
    });
  }
  /**
   * Would start a transaction but this driver does not support transactions.
   */
  commitTransaction() {
    return __async(this, null, function* () {
      throw new TypeORMError("Transactions are not supported by the Cordova driver");
    });
  }
  /**
   * Would start a transaction but this driver does not support transactions.
   */
  rollbackTransaction() {
    return __async(this, null, function* () {
      throw new TypeORMError("Transactions are not supported by the Cordova driver");
    });
  }
  /**
   * Removes all tables from the currently connected database.
   * Be careful with using this method and avoid using it in production or migrations
   * (because it can clear all your database).
   */
  clearDatabase() {
    return __async(this, null, function* () {
      yield this.query(`PRAGMA foreign_keys = OFF`);
      try {
        const selectViewDropsQuery = `SELECT 'DROP VIEW "' || name || '";' as query FROM "sqlite_master" WHERE "type" = 'view'`;
        const dropViewQueries = yield this.query(selectViewDropsQuery);
        const selectTableDropsQuery = `SELECT 'DROP TABLE "' || name || '";' as query FROM "sqlite_master" WHERE "type" = 'table' AND "name" != 'sqlite_sequence'`;
        const dropTableQueries = yield this.query(selectTableDropsQuery);
        yield Promise.all(dropViewQueries.map((q) => this.query(q["query"])));
        yield Promise.all(dropTableQueries.map((q) => this.query(q["query"])));
      } finally {
        yield this.query(`PRAGMA foreign_keys = ON`);
      }
    });
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Parametrizes given object of values. Used to create column=value queries.
   */
  parametrize(objectLiteral, startIndex = 0) {
    return Object.keys(objectLiteral).map((key, index) => `"${key}"=?`);
  }
};

// ../node_modules/typeorm/browser/driver/cordova/CordovaDriver.js
var CordovaDriver = class extends AbstractSqliteDriver {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    super(connection);
    this.transactionSupport = "none";
    this.database = this.options.database;
    this.loadDependencies();
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Closes connection with database.
   */
  disconnect() {
    return __async(this, null, function* () {
      this.queryRunner = void 0;
      return new Promise((ok, fail) => {
        this.databaseConnection.close(ok, fail);
      });
    });
  }
  /**
   * Creates a query runner used to execute database queries.
   */
  createQueryRunner(mode) {
    if (!this.queryRunner) this.queryRunner = new CordovaQueryRunner(this);
    return this.queryRunner;
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Creates connection with the database.
   */
  createDatabaseConnection() {
    return __async(this, null, function* () {
      const options = Object.assign({}, {
        name: this.options.database,
        location: this.options.location
      }, this.options.extra || {});
      const connection = yield new Promise((resolve, fail) => {
        this.sqlite.openDatabase(options, (db) => resolve(db), (err) => fail(err));
      });
      yield new Promise((ok, fail) => {
        connection.executeSql(`PRAGMA foreign_keys = ON`, [], () => ok(), (err) => fail(err));
      });
      return connection;
    });
  }
  /**
   * If driver dependency is not given explicitly, then try to load it via "require".
   */
  loadDependencies() {
    try {
      const sqlite = this.options.driver || window.sqlitePlugin;
      this.sqlite = sqlite;
    } catch (e) {
      throw new DriverPackageNotInstalledError("Cordova-SQLite", "cordova-sqlite-storage");
    }
  }
};

// ../node_modules/typeorm/browser/driver/react-native/ReactNativeQueryRunner.js
var ReactNativeQueryRunner = class extends AbstractSqliteQueryRunner {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(driver) {
    super();
    this.driver = driver;
    this.connection = driver.connection;
    this.broadcaster = new Broadcaster(this);
  }
  /**
   * Called before migrations are run.
   */
  beforeMigration() {
    return __async(this, null, function* () {
      yield this.query(`PRAGMA foreign_keys = OFF`);
    });
  }
  /**
   * Called after migrations are run.
   */
  afterMigration() {
    return __async(this, null, function* () {
      yield this.query(`PRAGMA foreign_keys = ON`);
    });
  }
  /**
   * Executes a given SQL query.
   */
  query(query, parameters, useStructuredResult = false) {
    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();
    return new Promise((ok, fail) => __async(this, null, function* () {
      const databaseConnection = yield this.connect();
      const broadcasterResult = new BroadcasterResult();
      this.driver.connection.logger.logQuery(query, parameters, this);
      this.broadcaster.broadcastBeforeQueryEvent(broadcasterResult, query, parameters);
      const queryStartTime = +/* @__PURE__ */ new Date();
      databaseConnection.executeSql(query, parameters, (raw) => __async(this, null, function* () {
        const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
        const queryEndTime = +/* @__PURE__ */ new Date();
        const queryExecutionTime = queryEndTime - queryStartTime;
        this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, void 0);
        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
        if (broadcasterResult.promises.length > 0) yield Promise.all(broadcasterResult.promises);
        const result = new QueryResult();
        if (raw?.hasOwnProperty("rowsAffected")) {
          result.affected = raw.rowsAffected;
        }
        if (raw?.hasOwnProperty("rows")) {
          let records = [];
          for (let i = 0; i < raw.rows.length; i++) {
            records.push(raw.rows.item(i));
          }
          result.raw = records;
          result.records = records;
        }
        if (query.substr(0, 11) === "INSERT INTO") {
          result.raw = raw.insertId;
        }
        if (useStructuredResult) {
          ok(result);
        } else {
          ok(result.raw);
        }
      }), (err) => __async(this, null, function* () {
        this.driver.connection.logger.logQueryError(err, query, parameters, this);
        this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
        yield broadcasterResult.wait();
        fail(new QueryFailedError(query, parameters, err));
      }));
    }));
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Parametrizes given object of values. Used to create column=value queries.
   */
  parametrize(objectLiteral, startIndex = 0) {
    return Object.keys(objectLiteral).map((key, index) => `"${key}"=?`);
  }
};

// ../node_modules/typeorm/browser/driver/react-native/ReactNativeDriver.js
var ReactNativeDriver = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    this.isReplicated = false;
    this.treeSupport = true;
    this.transactionSupport = "nested";
    this.supportedDataTypes = ["int", "integer", "tinyint", "smallint", "mediumint", "bigint", "unsigned big int", "int2", "int8", "integer", "character", "varchar", "varying character", "nchar", "native character", "nvarchar", "text", "clob", "text", "blob", "real", "double", "double precision", "float", "real", "numeric", "decimal", "boolean", "date", "time", "datetime"];
    this.supportedUpsertTypes = ["on-conflict-do-update"];
    this.withLengthColumnTypes = ["character", "varchar", "varying character", "nchar", "native character", "nvarchar", "text", "blob", "clob"];
    this.spatialTypes = [];
    this.withPrecisionColumnTypes = ["real", "double", "double precision", "float", "real", "numeric", "decimal", "date", "time", "datetime"];
    this.withScaleColumnTypes = ["real", "double", "double precision", "float", "real", "numeric", "decimal"];
    this.mappedDataTypes = {
      createDate: "datetime",
      createDateDefault: "datetime('now')",
      updateDate: "datetime",
      updateDateDefault: "datetime('now')",
      deleteDate: "datetime",
      deleteDateNullable: true,
      version: "integer",
      treeLevel: "integer",
      migrationId: "integer",
      migrationName: "varchar",
      migrationTimestamp: "bigint",
      cacheId: "int",
      cacheIdentifier: "varchar",
      cacheTime: "bigint",
      cacheDuration: "int",
      cacheQuery: "text",
      cacheResult: "text",
      metadataType: "varchar",
      metadataDatabase: "varchar",
      metadataSchema: "varchar",
      metadataTable: "varchar",
      metadataName: "varchar",
      metadataValue: "text"
    };
    this.cteCapabilities = {
      enabled: true,
      requiresRecursiveHint: true
    };
    this.attachedDatabases = {};
    this.connection = connection;
    this.options = connection.options;
    this.database = this.options.database;
    this.loadDependencies();
  }
  // -------------------------------------------------------------------------
  // Public Abstract
  // -------------------------------------------------------------------------
  /**
   * Creates a query runner used to execute database queries.
   */
  createQueryRunner(mode) {
    if (!this.queryRunner) this.queryRunner = new ReactNativeQueryRunner(this);
    return this.queryRunner;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Performs connection to the database.
   */
  connect() {
    return __async(this, null, function* () {
      this.databaseConnection = yield this.createDatabaseConnection();
    });
  }
  /**
   * Makes any action after connection (e.g. create extensions in Postgres driver).
   */
  afterConnect() {
    return Promise.resolve();
  }
  /**
   * Closes connection with database.
   */
  disconnect() {
    return __async(this, null, function* () {
      return new Promise((ok, fail) => {
        this.queryRunner = void 0;
        this.databaseConnection.close(ok, fail);
      });
    });
  }
  hasAttachedDatabases() {
    return !!Object.keys(this.attachedDatabases).length;
  }
  getAttachedDatabaseHandleByRelativePath(path) {
    return this.attachedDatabases?.[path]?.attachHandle;
  }
  getAttachedDatabasePathRelativeByHandle(handle) {
    return Object.values(this.attachedDatabases).find(({
      attachHandle
    }) => handle === attachHandle)?.attachFilepathRelative;
  }
  /**
   * Creates a schema builder used to build and sync a schema.
   */
  createSchemaBuilder() {
    return new RdbmsSchemaBuilder(this.connection);
  }
  /**
   * Prepares given value to a value to be persisted, based on its column type and metadata.
   */
  preparePersistentValue(value, columnMetadata) {
    if (columnMetadata.transformer) value = ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
    if (value === null || value === void 0) return value;
    if (columnMetadata.type === Boolean || columnMetadata.type === "boolean") {
      return value === true ? 1 : 0;
    } else if (columnMetadata.type === "date") {
      return DateUtils.mixedDateToDateString(value);
    } else if (columnMetadata.type === "time") {
      return DateUtils.mixedDateToTimeString(value);
    } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
      return DateUtils.mixedDateToUtcDatetimeString(value);
    } else if (columnMetadata.type === "simple-array") {
      return DateUtils.simpleArrayToString(value);
    } else if (columnMetadata.type === "simple-json") {
      return DateUtils.simpleJsonToString(value);
    } else if (columnMetadata.type === "simple-enum") {
      return DateUtils.simpleEnumToString(value);
    }
    return value;
  }
  /**
   * Prepares given value to a value to be hydrated, based on its column type or metadata.
   */
  prepareHydratedValue(value, columnMetadata) {
    if (value === null || value === void 0) return columnMetadata.transformer ? ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
    if (columnMetadata.type === Boolean || columnMetadata.type === "boolean") {
      value = value ? true : false;
    } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
      if (value && typeof value === "string") {
        if (/^\d\d\d\d-\d\d-\d\d \d\d:\d\d/.test(value)) {
          value = value.replace(" ", "T");
        }
        if (/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d(:\d\d(\.\d\d\d)?)?$/.test(value)) {
          value += "Z";
        }
      }
      value = DateUtils.normalizeHydratedDate(value);
    } else if (columnMetadata.type === "date") {
      value = DateUtils.mixedDateToDateString(value);
    } else if (columnMetadata.type === "time") {
      value = DateUtils.mixedTimeToString(value);
    } else if (columnMetadata.type === "simple-array") {
      value = DateUtils.stringToSimpleArray(value);
    } else if (columnMetadata.type === "simple-json") {
      value = DateUtils.stringToSimpleJson(value);
    } else if (columnMetadata.type === "simple-enum") {
      value = DateUtils.stringToSimpleEnum(value, columnMetadata);
    } else if (columnMetadata.type === Number) {
      value = !isNaN(+value) ? parseInt(value) : value;
    }
    if (columnMetadata.transformer) value = ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
    return value;
  }
  /**
   * Replaces parameters in the given sql with special escaping character
   * and an array of parameter names to be passed to a query.
   */
  escapeQueryWithParameters(sql, parameters, nativeParameters) {
    const escapedParameters = Object.keys(nativeParameters).map((key) => {
      if (typeof nativeParameters[key] === "boolean") {
        return nativeParameters[key] === true ? 1 : 0;
      }
      if (nativeParameters[key] instanceof Date) {
        return DateUtils.mixedDateToUtcDatetimeString(nativeParameters[key]);
      }
      return nativeParameters[key];
    });
    if (!parameters || !Object.keys(parameters).length) return [sql, escapedParameters];
    sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {
      if (!parameters.hasOwnProperty(key)) {
        return full;
      }
      let value = parameters[key];
      if (isArray) {
        return value.map((v) => {
          escapedParameters.push(v);
          return this.createParameter(key, escapedParameters.length - 1);
        }).join(", ");
      }
      if (typeof value === "function") {
        return value();
      } else if (typeof value === "number") {
        return String(value);
      }
      if (typeof value === "boolean") {
        escapedParameters.push(+value);
        return this.createParameter(key, escapedParameters.length - 1);
      }
      if (value instanceof Date) {
        escapedParameters.push(DateUtils.mixedDateToUtcDatetimeString(value));
        return this.createParameter(key, escapedParameters.length - 1);
      }
      escapedParameters.push(value);
      return this.createParameter(key, escapedParameters.length - 1);
    });
    return [sql, escapedParameters];
  }
  /**
   * Escapes a column name.
   */
  escape(columnName) {
    return '"' + columnName + '"';
  }
  /**
   * Build full table name with database name, schema name and table name.
   * E.g. myDB.mySchema.myTable
   *
   * Returns only simple table name because all inherited drivers does not supports schema and database.
   */
  buildTableName(tableName, schema, database) {
    return tableName;
  }
  /**
   * Parse a target table name or other types and return a normalized table definition.
   */
  parseTableName(target) {
    const driverDatabase = this.database;
    const driverSchema = void 0;
    if (InstanceChecker.isTable(target) || InstanceChecker.isView(target)) {
      const parsed = this.parseTableName(target.schema ? `"${target.schema}"."${target.name}"` : target.name);
      return {
        database: target.database || parsed.database || driverDatabase,
        schema: target.schema || parsed.schema || driverSchema,
        tableName: parsed.tableName
      };
    }
    if (InstanceChecker.isTableForeignKey(target)) {
      const parsed = this.parseTableName(target.referencedTableName);
      return {
        database: target.referencedDatabase || parsed.database || driverDatabase,
        schema: target.referencedSchema || parsed.schema || driverSchema,
        tableName: parsed.tableName
      };
    }
    if (InstanceChecker.isEntityMetadata(target)) {
      return {
        database: target.database || driverDatabase,
        schema: target.schema || driverSchema,
        tableName: target.tableName
      };
    }
    const parts = target.split(".");
    if (parts.length === 3) {
      return {
        database: parts[0] || driverDatabase,
        schema: parts[1] || driverSchema,
        tableName: parts[2]
      };
    } else if (parts.length === 2) {
      const database = this.getAttachedDatabasePathRelativeByHandle(parts[0]) ?? driverDatabase;
      return {
        database,
        schema: parts[0],
        tableName: parts[1]
      };
    } else {
      return {
        database: driverDatabase,
        schema: driverSchema,
        tableName: target
      };
    }
  }
  /**
   * Creates a database type from a given column metadata.
   */
  normalizeType(column) {
    if (column.type === Number || column.type === "int") {
      return "integer";
    } else if (column.type === String) {
      return "varchar";
    } else if (column.type === Date) {
      return "datetime";
    } else if (column.type === Boolean) {
      return "boolean";
    } else if (column.type === "uuid") {
      return "varchar";
    } else if (column.type === "simple-array") {
      return "text";
    } else if (column.type === "simple-json") {
      return "text";
    } else if (column.type === "simple-enum") {
      return "varchar";
    } else {
      return column.type || "";
    }
  }
  /**
   * Normalizes "default" value of the column.
   */
  normalizeDefault(columnMetadata) {
    const defaultValue = columnMetadata.default;
    if (typeof defaultValue === "number") {
      return "" + defaultValue;
    }
    if (typeof defaultValue === "boolean") {
      return defaultValue ? "1" : "0";
    }
    if (typeof defaultValue === "function") {
      return defaultValue();
    }
    if (typeof defaultValue === "string") {
      return `'${defaultValue}'`;
    }
    if (defaultValue === null || defaultValue === void 0) {
      return void 0;
    }
    return `${defaultValue}`;
  }
  /**
   * Normalizes "isUnique" value of the column.
   */
  normalizeIsUnique(column) {
    return column.entityMetadata.uniques.some((uq) => uq.columns.length === 1 && uq.columns[0] === column);
  }
  /**
   * Calculates column length taking into account the default length values.
   */
  getColumnLength(column) {
    return column.length ? column.length.toString() : "";
  }
  /**
   * Normalizes "default" value of the column.
   */
  createFullType(column) {
    let type = column.type;
    if (column.enum) {
      return "varchar";
    }
    if (column.length) {
      type += "(" + column.length + ")";
    } else if (column.precision !== null && column.precision !== void 0 && column.scale !== null && column.scale !== void 0) {
      type += "(" + column.precision + "," + column.scale + ")";
    } else if (column.precision !== null && column.precision !== void 0) {
      type += "(" + column.precision + ")";
    }
    if (column.isArray) type += " array";
    return type;
  }
  /**
   * Obtains a new database connection to a master server.
   * Used for replication.
   * If replication is not setup then returns default connection's database connection.
   */
  obtainMasterConnection() {
    return Promise.resolve();
  }
  /**
   * Obtains a new database connection to a slave server.
   * Used for replication.
   * If replication is not setup then returns master (default) connection's database connection.
   */
  obtainSlaveConnection() {
    return Promise.resolve();
  }
  /**
   * Creates generated map of values generated or returned by database after INSERT query.
   */
  createGeneratedMap(metadata, insertResult, entityIndex, entityNum) {
    const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {
      let value;
      if (generatedColumn.generationStrategy === "increment" && insertResult) {
        value = insertResult - entityNum + entityIndex + 1;
      }
      if (!value) return map;
      return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
    }, {});
    return Object.keys(generatedMap).length > 0 ? generatedMap : void 0;
  }
  /**
   * Differentiate columns of this table and columns from the given column metadatas columns
   * and returns only changed.
   */
  findChangedColumns(tableColumns, columnMetadatas) {
    return columnMetadatas.filter((columnMetadata) => {
      const tableColumn = tableColumns.find((c) => c.name === columnMetadata.databaseName);
      if (!tableColumn) return false;
      const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadata.length || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale || this.normalizeDefault(columnMetadata) !== tableColumn.default || tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || tableColumn.enum && columnMetadata.enum && !OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map((val) => val + "")) || columnMetadata.generationStrategy !== "uuid" && tableColumn.isGenerated !== columnMetadata.isGenerated;
      return isColumnChanged;
    });
  }
  /**
   * Returns true if driver supports RETURNING / OUTPUT statement.
   */
  isReturningSqlSupported() {
    return false;
  }
  /**
   * Returns true if driver supports uuid values generation on its own.
   */
  isUUIDGenerationSupported() {
    return false;
  }
  /**
   * Returns true if driver supports fulltext indices.
   */
  isFullTextColumnTypeSupported() {
    return false;
  }
  /**
   * Creates an escaped parameter.
   */
  createParameter(parameterName, index) {
    return "?";
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Creates connection with the database.
   */
  createDatabaseConnection() {
    return new Promise((ok, fail) => {
      const options = Object.assign({}, {
        name: this.options.database,
        location: this.options.location
      }, this.options.extra || {});
      this.sqlite.openDatabase(options, (db) => {
        const databaseConnection = db;
        databaseConnection.executeSql(`PRAGMA foreign_keys = ON`, [], (result) => {
          ok(databaseConnection);
        }, (error) => {
          fail(error);
        });
      }, (error) => {
        fail(error);
      });
    });
  }
  /**
   * If driver dependency is not given explicitly, then try to load it via "require".
   */
  loadDependencies() {
    try {
      const sqlite = this.options.driver || __require("react-native-sqlite-storage");
      this.sqlite = sqlite;
    } catch (e) {
      throw new DriverPackageNotInstalledError("React-Native", "react-native-sqlite-storage");
    }
  }
};

// ../node_modules/typeorm/browser/driver/nativescript/NativescriptQueryRunner.js
var NativescriptQueryRunner = class extends AbstractSqliteQueryRunner {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(driver) {
    super();
    this.driver = driver;
    this.connection = driver.connection;
    this.broadcaster = new Broadcaster(this);
  }
  /**
   * Called before migrations are run.
   */
  beforeMigration() {
    return __async(this, null, function* () {
      yield this.query(`PRAGMA foreign_keys = OFF`);
    });
  }
  /**
   * Called after migrations are run.
   */
  afterMigration() {
    return __async(this, null, function* () {
      yield this.query(`PRAGMA foreign_keys = ON`);
    });
  }
  /**
   * Executes a given SQL query.
   */
  query(query, parameters, useStructuredResult = false) {
    return __async(this, null, function* () {
      if (this.isReleased) {
        throw new QueryRunnerAlreadyReleasedError();
      }
      const connection = this.driver.connection;
      return new Promise((ok, fail) => __async(this, null, function* () {
        const databaseConnection = yield this.connect();
        const isInsertQuery = query.substr(0, 11) === "INSERT INTO";
        connection.logger.logQuery(query, parameters, this);
        const handler = (err, raw) => {
          const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
          const queryEndTime = +/* @__PURE__ */ new Date();
          const queryExecutionTime = queryEndTime - queryStartTime;
          if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {
            connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
          }
          if (err) {
            connection.logger.logQueryError(err, query, parameters, this);
            fail(new QueryFailedError(query, parameters, err));
          }
          const result = new QueryResult();
          result.raw = raw;
          if (!isInsertQuery && Array.isArray(raw)) {
            result.records = raw;
          }
          if (useStructuredResult) {
            ok(result);
          } else {
            ok(result.raw);
          }
        };
        const queryStartTime = +/* @__PURE__ */ new Date();
        if (isInsertQuery) {
          databaseConnection.execSQL(query, parameters, handler);
        } else {
          databaseConnection.all(query, parameters, handler);
        }
      }));
    });
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Parametrizes given object of values. Used to create column=value queries.
   */
  parametrize(objectLiteral, startIndex = 0) {
    return Object.keys(objectLiteral).map((key, index) => `"${key}"=?`);
  }
};

// ../node_modules/typeorm/browser/driver/nativescript/NativescriptDriver.js
var NativescriptDriver = class extends AbstractSqliteDriver {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    super(connection);
    this.connection = connection;
    this.options = connection.options;
    this.database = this.options.database;
    this.driver = this.options.driver;
    this.loadDependencies();
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Closes connection with database.
   */
  disconnect() {
    return __async(this, null, function* () {
      return new Promise((ok, fail) => {
        this.queryRunner = void 0;
        this.databaseConnection.close().then(ok).catch(fail);
      });
    });
  }
  /**
   * Creates a query runner used to execute database queries.
   */
  createQueryRunner(mode) {
    if (!this.queryRunner) {
      this.queryRunner = new NativescriptQueryRunner(this);
    }
    return this.queryRunner;
  }
  normalizeType(column) {
    if (column.type === Buffer) {
      return "blob";
    }
    return super.normalizeType(column);
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Creates connection with the database.
   */
  createDatabaseConnection() {
    return new Promise((ok, fail) => {
      const options = Object.assign({}, {
        readOnly: this.options.readOnly,
        key: this.options.key,
        multithreading: this.options.multithreading,
        migrate: this.options.migrate,
        iosFlags: this.options.iosFlags,
        androidFlags: this.options.androidFlags
      }, this.options.extra || {});
      new this.sqlite(this.options.database, options, (err, db) => {
        if (err) return fail(err);
        db.resultType(this.sqlite.RESULTSASOBJECT);
        db.execSQL(`PRAGMA foreign_keys = ON`, [], (err2, result) => {
          if (err2) return fail(err2);
          ok(db);
        });
      });
    });
  }
  /**
   * If driver dependency is not given explicitly, then try to load it via "require".
   */
  loadDependencies() {
    this.sqlite = this.driver;
    if (!this.driver) {
      throw new DriverPackageNotInstalledError("Nativescript", "nativescript-sqlite");
    }
  }
};

// ../node_modules/typeorm/browser/driver/sqljs/SqljsQueryRunner.js
var SqljsQueryRunner = class _SqljsQueryRunner extends AbstractSqliteQueryRunner {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(driver) {
    super();
    this.isDirty = false;
    this.driver = driver;
    this.connection = driver.connection;
    this.broadcaster = new Broadcaster(this);
  }
  // -------------------------------------------------------------------------
  // Public methods
  // -------------------------------------------------------------------------
  /**
   * Called before migrations are run.
   */
  beforeMigration() {
    return __async(this, null, function* () {
      yield this.query(`PRAGMA foreign_keys = OFF`);
    });
  }
  /**
   * Called after migrations are run.
   */
  afterMigration() {
    return __async(this, null, function* () {
      yield this.query(`PRAGMA foreign_keys = ON`);
    });
  }
  flush() {
    return __async(this, null, function* () {
      if (this.isDirty) {
        yield this.driver.autoSave();
        this.isDirty = false;
      }
    });
  }
  release() {
    return __async(this, null, function* () {
      yield this.flush();
      return __superGet(_SqljsQueryRunner.prototype, this, "release").call(this);
    });
  }
  /**
   * Commits transaction.
   * Error will be thrown if transaction was not started.
   */
  commitTransaction() {
    return __async(this, null, function* () {
      yield __superGet(_SqljsQueryRunner.prototype, this, "commitTransaction").call(this);
      if (!this.isTransactionActive) {
        yield this.flush();
      }
    });
  }
  /**
   * Executes a given SQL query.
   */
  query(_0) {
    return __async(this, arguments, function* (query, parameters = [], useStructuredResult = false) {
      if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();
      const command = query.trim().split(" ", 1)[0];
      const databaseConnection = this.driver.databaseConnection;
      const broadcasterResult = new BroadcasterResult();
      this.driver.connection.logger.logQuery(query, parameters, this);
      this.broadcaster.broadcastBeforeQueryEvent(broadcasterResult, query, parameters);
      const queryStartTime = +/* @__PURE__ */ new Date();
      let statement;
      try {
        statement = databaseConnection.prepare(query);
        if (parameters) {
          parameters = parameters.map((p) => typeof p !== "undefined" ? p : null);
          statement.bind(parameters);
        }
        const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
        const queryEndTime = +/* @__PURE__ */ new Date();
        const queryExecutionTime = queryEndTime - queryStartTime;
        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
        const records = [];
        while (statement.step()) {
          records.push(statement.getAsObject());
        }
        this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, records, void 0);
        const result = new QueryResult();
        result.affected = databaseConnection.getRowsModified();
        result.records = records;
        result.raw = records;
        statement.free();
        if (command !== "SELECT") {
          this.isDirty = true;
        }
        if (useStructuredResult) {
          return result;
        } else {
          return result.raw;
        }
      } catch (err) {
        if (statement) {
          statement.free();
        }
        this.driver.connection.logger.logQueryError(err, query, parameters, this);
        this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
        throw new QueryFailedError(query, parameters, err);
      } finally {
        yield broadcasterResult.wait();
      }
    });
  }
};

// ../node_modules/typeorm/browser/driver/sqljs/SqljsDriver.js
var SqljsDriver = class extends AbstractSqliteDriver {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    super(connection);
    if (this.options.autoSave && !this.options.location && !this.options.autoSaveCallback) {
      throw new DriverOptionNotSetError(`location or autoSaveCallback`);
    }
    this.loadDependencies();
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Performs connection to the database.
   */
  connect() {
    return __async(this, null, function* () {
      this.databaseConnection = yield this.createDatabaseConnection();
    });
  }
  /**
   * Closes connection with database.
   */
  disconnect() {
    return __async(this, null, function* () {
      this.queryRunner = void 0;
      this.databaseConnection.close();
    });
  }
  /**
   * Creates a query runner used to execute database queries.
   */
  createQueryRunner(mode) {
    if (!this.queryRunner) this.queryRunner = new SqljsQueryRunner(this);
    return this.queryRunner;
  }
  /**
   * Loads a database from a given file (Node.js), local storage key (browser) or array.
   * This will delete the current database!
   */
  load(fileNameOrLocalStorageOrData, checkIfFileOrLocalStorageExists = true) {
    return __async(this, null, function* () {
      if (typeof fileNameOrLocalStorageOrData === "string") {
        if (PlatformTools.type === "node") {
          if (PlatformTools.fileExist(fileNameOrLocalStorageOrData)) {
            const database = PlatformTools.readFileSync(fileNameOrLocalStorageOrData);
            return this.createDatabaseConnectionWithImport(database);
          } else if (checkIfFileOrLocalStorageExists) {
            throw new TypeORMError(`File ${fileNameOrLocalStorageOrData} does not exist`);
          } else {
            return this.createDatabaseConnectionWithImport();
          }
        } else {
          let localStorageContent = null;
          if (this.options.useLocalForage) {
            if (window.localforage) {
              localStorageContent = yield window.localforage.getItem(fileNameOrLocalStorageOrData);
            } else {
              throw new TypeORMError(`localforage is not defined - please import localforage.js into your site`);
            }
          } else {
            localStorageContent = PlatformTools.getGlobalVariable().localStorage.getItem(fileNameOrLocalStorageOrData);
          }
          if (localStorageContent != null) {
            return this.createDatabaseConnectionWithImport(JSON.parse(localStorageContent));
          } else if (checkIfFileOrLocalStorageExists) {
            throw new TypeORMError(`File ${fileNameOrLocalStorageOrData} does not exist`);
          } else {
            return this.createDatabaseConnectionWithImport();
          }
        }
      } else {
        return this.createDatabaseConnectionWithImport(fileNameOrLocalStorageOrData);
      }
    });
  }
  /**
   * Saved the current database to the given file (Node.js), local storage key (browser) or
   * indexedDB key (browser with enabled useLocalForage option).
   * If no location path is given, the location path in the options (if specified) will be used.
   */
  save(location) {
    return __async(this, null, function* () {
      if (!location && !this.options.location) {
        throw new TypeORMError(`No location is set, specify a location parameter or add the location option to your configuration`);
      }
      let path = "";
      if (location) {
        path = location;
      } else if (this.options.location) {
        path = this.options.location;
      }
      if (PlatformTools.type === "node") {
        try {
          const content = Buffer.from(this.databaseConnection.export());
          yield PlatformTools.writeFile(path, content);
        } catch (e) {
          throw new TypeORMError(`Could not save database, error: ${e}`);
        }
      } else {
        const database = this.databaseConnection.export();
        const databaseArray = [].slice.call(database);
        if (this.options.useLocalForage) {
          if (window.localforage) {
            yield window.localforage.setItem(path, JSON.stringify(databaseArray));
          } else {
            throw new TypeORMError(`localforage is not defined - please import localforage.js into your site`);
          }
        } else {
          PlatformTools.getGlobalVariable().localStorage.setItem(path, JSON.stringify(databaseArray));
        }
      }
    });
  }
  /**
   * This gets called by the QueryRunner when a change to the database is made.
   * If a custom autoSaveCallback is specified, it get's called with the database as Uint8Array,
   * otherwise the save method is called which saves it to file (Node.js), local storage (browser)
   * or indexedDB (browser with enabled useLocalForage option).
   * Don't auto-save when in transaction as the call to export will end the current transaction
   */
  autoSave() {
    return __async(this, null, function* () {
      if (this.options.autoSave && !this.queryRunner?.isTransactionActive) {
        if (this.options.autoSaveCallback) {
          yield this.options.autoSaveCallback(this.export());
        } else {
          yield this.save();
        }
      }
    });
  }
  /**
   * Returns the current database as Uint8Array.
   */
  export() {
    return this.databaseConnection.export();
  }
  /**
   * Creates generated map of values generated or returned by database after INSERT query.
   */
  createGeneratedMap(metadata, insertResult) {
    const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {
      if (generatedColumn.isPrimary && generatedColumn.generationStrategy === "increment") {
        const query = "SELECT last_insert_rowid()";
        try {
          let result = this.databaseConnection.exec(query);
          this.connection.logger.logQuery(query);
          return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(result[0].values[0][0]));
        } catch (e) {
          this.connection.logger.logQueryError(e, query, []);
        }
      }
      return map;
    }, {});
    return Object.keys(generatedMap).length > 0 ? generatedMap : void 0;
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Creates connection with the database.
   * If the location option is set, the database is loaded first.
   */
  createDatabaseConnection() {
    if (this.options.location) {
      return this.load(this.options.location, false);
    }
    return this.createDatabaseConnectionWithImport(this.options.database);
  }
  /**
   * Creates connection with an optional database.
   * If database is specified it is loaded, otherwise a new empty database is created.
   */
  createDatabaseConnectionWithImport(database) {
    return __async(this, null, function* () {
      const isLegacyVersion = typeof this.sqlite.Database === "function";
      const sqlite = isLegacyVersion ? this.sqlite : yield this.sqlite(this.options.sqlJsConfig);
      if (database && database.length > 0) {
        this.databaseConnection = new sqlite.Database(database);
      } else {
        this.databaseConnection = new sqlite.Database();
      }
      this.databaseConnection.exec(`PRAGMA foreign_keys = ON`);
      return this.databaseConnection;
    });
  }
  /**
   * If driver dependency is not given explicitly, then try to load it via "require".
   */
  loadDependencies() {
    if (PlatformTools.type === "browser") {
      const sqlite = this.options.driver || window.SQL;
      this.sqlite = sqlite;
    } else {
      try {
        const sqlite = this.options.driver || PlatformTools.load("sql.js");
        this.sqlite = sqlite;
      } catch (e) {
        throw new DriverPackageNotInstalledError("sql.js", "sql.js");
      }
    }
  }
};

// ../node_modules/typeorm/browser/driver/expo/ExpoQueryRunner.js
var ExpoQueryRunner = class extends AbstractSqliteQueryRunner {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(driver) {
    super();
    this.driver = driver;
    this.connection = driver.connection;
    this.broadcaster = new Broadcaster(this);
  }
  /**
   * Starts transaction. Within Expo, all database operations happen in a
   * transaction context, so issuing a `BEGIN TRANSACTION` command is
   * redundant and will result in the following error:
   *
   * `Error: Error code 1: cannot start a transaction within a transaction`
   *
   * Instead, we keep track of a `Transaction` object in `this.transaction`
   * and continue using the same object until we wish to commit the
   * transaction.
   */
  startTransaction() {
    return __async(this, null, function* () {
      this.isTransactionActive = true;
      try {
        yield this.broadcaster.broadcast("BeforeTransactionStart");
      } catch (err) {
        this.isTransactionActive = false;
        throw err;
      }
      this.transactionDepth += 1;
      yield this.broadcaster.broadcast("AfterTransactionStart");
    });
  }
  /**
   * Commits transaction.
   * Error will be thrown if transaction was not started.
   * Since Expo will automatically commit the transaction once all the
   * callbacks of the transaction object have been completed, "committing" a
   * transaction in this driver's context means that we delete the transaction
   * object and set the stage for the next transaction.
   */
  commitTransaction() {
    return __async(this, null, function* () {
      if (!this.isTransactionActive && typeof this.transaction === "undefined") throw new TransactionNotStartedError();
      yield this.broadcaster.broadcast("BeforeTransactionCommit");
      this.transaction = void 0;
      this.isTransactionActive = false;
      this.transactionDepth -= 1;
      yield this.broadcaster.broadcast("AfterTransactionCommit");
    });
  }
  /**
   * Rollbacks transaction.
   * Error will be thrown if transaction was not started.
   * This method's functionality is identical to `commitTransaction()` because
   * the transaction lifecycle is handled within the Expo transaction object.
   * Issuing separate statements for `COMMIT` or `ROLLBACK` aren't necessary.
   */
  rollbackTransaction() {
    return __async(this, null, function* () {
      if (!this.isTransactionActive && typeof this.transaction === "undefined") throw new TransactionNotStartedError();
      yield this.broadcaster.broadcast("BeforeTransactionRollback");
      this.transaction = void 0;
      this.isTransactionActive = false;
      this.transactionDepth -= 1;
      yield this.broadcaster.broadcast("AfterTransactionRollback");
    });
  }
  /**
   * Called before migrations are run.
   */
  beforeMigration() {
    return __async(this, null, function* () {
      const databaseConnection = yield this.connect();
      return new Promise((ok, fail) => {
        databaseConnection.exec([{
          sql: "PRAGMA foreign_keys = OFF",
          args: []
        }], false, (err) => err ? fail(err) : ok());
      });
    });
  }
  /**
   * Called after migrations are run.
   */
  afterMigration() {
    return __async(this, null, function* () {
      const databaseConnection = yield this.connect();
      return new Promise((ok, fail) => {
        databaseConnection.exec([{
          sql: "PRAGMA foreign_keys = ON",
          args: []
        }], false, (err) => err ? fail(err) : ok());
      });
    });
  }
  /**
   * Executes a given SQL query.
   */
  query(query, parameters, useStructuredResult = false) {
    return __async(this, null, function* () {
      if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();
      return new Promise((ok, fail) => __async(this, null, function* () {
        const databaseConnection = yield this.connect();
        const broadcasterResult = new BroadcasterResult();
        this.driver.connection.logger.logQuery(query, parameters, this);
        this.broadcaster.broadcastBeforeQueryEvent(broadcasterResult, query, parameters);
        const queryStartTime = +/* @__PURE__ */ new Date();
        databaseConnection.transaction((transaction) => __async(this, null, function* () {
          if (typeof this.transaction === "undefined") {
            yield this.startTransaction();
            this.transaction = transaction;
          }
          this.transaction.executeSql(query, parameters, (t, raw) => __async(this, null, function* () {
            const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
            const queryEndTime = +/* @__PURE__ */ new Date();
            const queryExecutionTime = queryEndTime - queryStartTime;
            this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, void 0);
            yield broadcasterResult.wait();
            if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {
              this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
            }
            const result = new QueryResult();
            if (raw?.hasOwnProperty("rowsAffected")) {
              result.affected = raw.rowsAffected;
            }
            if (raw?.hasOwnProperty("rows")) {
              let resultSet = [];
              for (let i = 0; i < raw.rows.length; i++) {
                resultSet.push(raw.rows.item(i));
              }
              result.raw = resultSet;
              result.records = resultSet;
            }
            if (query.startsWith("INSERT INTO")) {
              result.raw = raw.insertId;
            }
            if (useStructuredResult) {
              ok(result);
            } else {
              ok(result.raw);
            }
          }), (t, err) => __async(this, null, function* () {
            this.driver.connection.logger.logQueryError(err, query, parameters, this);
            this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
            yield broadcasterResult.wait();
            fail(new QueryFailedError(query, parameters, err));
          }));
        }), (err) => __async(this, null, function* () {
          yield this.rollbackTransaction();
          fail(err);
        }), () => {
          this.isTransactionActive = false;
          this.transaction = void 0;
        });
      }));
    });
  }
};

// ../node_modules/typeorm/browser/driver/expo/ExpoDriver.js
var ExpoDriver = class extends AbstractSqliteDriver {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    super(connection);
    this.database = this.options.database;
    this.sqlite = this.options.driver;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Closes connection with database.
   */
  disconnect() {
    return __async(this, null, function* () {
      return new Promise((ok, fail) => {
        try {
          this.queryRunner = void 0;
          this.databaseConnection._db.close();
          this.databaseConnection = void 0;
          ok();
        } catch (error) {
          fail(error);
        }
      });
    });
  }
  /**
   * Creates a query runner used to execute database queries.
   */
  createQueryRunner(mode) {
    if (!this.queryRunner) this.queryRunner = new ExpoQueryRunner(this);
    return this.queryRunner;
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Creates connection with the database.
   */
  createDatabaseConnection() {
    return new Promise((ok, fail) => {
      try {
        const databaseConnection = this.sqlite.openDatabase(this.options.database);
        databaseConnection.transaction((tsx) => {
          tsx.executeSql(`PRAGMA foreign_keys = ON`, [], (t, result) => {
            ok(databaseConnection);
          }, (t, err) => {
            fail({
              transaction: t,
              error: err
            });
          });
        }, (err) => {
          fail(err);
        });
      } catch (error) {
        fail(error);
      }
    });
  }
};

// ../node_modules/typeorm/browser/driver/aurora-mysql/AuroraMysqlQueryRunner.js
var AuroraMysqlQueryRunner = class extends BaseQueryRunner {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(driver, client) {
    super();
    this.driver = driver;
    this.connection = driver.connection;
    this.client = client;
    this.broadcaster = new Broadcaster(this);
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates/uses database connection from the connection pool to perform further operations.
   * Returns obtained database connection.
   */
  connect() {
    return __async(this, null, function* () {
      return {};
    });
  }
  /**
   * Releases used database connection.
   * You cannot use query runner methods once its released.
   */
  release() {
    this.isReleased = true;
    if (this.databaseConnection) this.databaseConnection.release();
    return Promise.resolve();
  }
  /**
   * Starts transaction on the current connection.
   */
  startTransaction(isolationLevel) {
    return __async(this, null, function* () {
      this.isTransactionActive = true;
      try {
        yield this.broadcaster.broadcast("BeforeTransactionStart");
      } catch (err) {
        this.isTransactionActive = false;
        throw err;
      }
      if (this.transactionDepth === 0) {
        this.transactionDepth += 1;
        yield this.client.startTransaction();
      } else {
        this.transactionDepth += 1;
        yield this.query(`SAVEPOINT typeorm_${this.transactionDepth - 1}`);
      }
      yield this.broadcaster.broadcast("AfterTransactionStart");
    });
  }
  /**
   * Commits transaction.
   * Error will be thrown if transaction was not started.
   */
  commitTransaction() {
    return __async(this, null, function* () {
      if (!this.isTransactionActive) throw new TransactionNotStartedError();
      yield this.broadcaster.broadcast("BeforeTransactionCommit");
      if (this.transactionDepth > 1) {
        this.transactionDepth -= 1;
        yield this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth}`);
      } else {
        this.transactionDepth -= 1;
        yield this.client.commitTransaction();
        this.isTransactionActive = false;
      }
      yield this.broadcaster.broadcast("AfterTransactionCommit");
    });
  }
  /**
   * Rollbacks transaction.
   * Error will be thrown if transaction was not started.
   */
  rollbackTransaction() {
    return __async(this, null, function* () {
      if (!this.isTransactionActive) throw new TransactionNotStartedError();
      yield this.broadcaster.broadcast("BeforeTransactionRollback");
      if (this.transactionDepth > 1) {
        this.transactionDepth -= 1;
        yield this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth}`);
      } else {
        this.transactionDepth -= 1;
        yield this.client.rollbackTransaction();
        this.isTransactionActive = false;
      }
      yield this.broadcaster.broadcast("AfterTransactionRollback");
    });
  }
  /**
   * Executes a raw SQL query.
   */
  query(query, parameters, useStructuredResult = false) {
    return __async(this, null, function* () {
      if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();
      const raw = yield this.client.query(query, parameters);
      const result = new QueryResult();
      result.raw = raw;
      if (raw?.hasOwnProperty("records") && Array.isArray(raw.records)) {
        result.records = raw.records;
      }
      if (raw?.hasOwnProperty("numberOfRecordsUpdated")) {
        result.affected = raw.numberOfRecordsUpdated;
      }
      if (!useStructuredResult) {
        return result.raw;
      }
      return result;
    });
  }
  /**
   * Returns raw data stream.
   */
  stream(query, parameters, onEnd, onError) {
    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();
    return new Promise((ok, fail) => __async(this, null, function* () {
      try {
        const databaseConnection = yield this.connect();
        const stream = databaseConnection.query(query, parameters);
        if (onEnd) stream.on("end", onEnd);
        if (onError) stream.on("error", onError);
        ok(stream);
      } catch (err) {
        fail(err);
      }
    }));
  }
  /**
   * Returns all available database names including system databases.
   */
  getDatabases() {
    return __async(this, null, function* () {
      return Promise.resolve([]);
    });
  }
  /**
   * Returns all available schema names including system schemas.
   * If database parameter specified, returns schemas of that database.
   */
  getSchemas(database) {
    return __async(this, null, function* () {
      throw new TypeORMError(`MySql driver does not support table schemas`);
    });
  }
  /**
   * Checks if database with the given name exist.
   */
  hasDatabase(database) {
    return __async(this, null, function* () {
      const result = yield this.query(`SELECT * FROM \`INFORMATION_SCHEMA\`.\`SCHEMATA\` WHERE \`SCHEMA_NAME\` = '${database}'`);
      return result.length ? true : false;
    });
  }
  /**
   * Loads currently using database
   */
  getCurrentDatabase() {
    return __async(this, null, function* () {
      const query = yield this.query(`SELECT DATABASE() AS \`db_name\``);
      return query[0]["db_name"];
    });
  }
  /**
   * Checks if schema with the given name exist.
   */
  hasSchema(schema) {
    return __async(this, null, function* () {
      throw new TypeORMError(`MySql driver does not support table schemas`);
    });
  }
  /**
   * Loads currently using database schema
   */
  getCurrentSchema() {
    return __async(this, null, function* () {
      const query = yield this.query(`SELECT SCHEMA() AS \`schema_name\``);
      return query[0]["schema_name"];
    });
  }
  /**
   * Checks if table with the given name exist in the database.
   */
  hasTable(tableOrName) {
    return __async(this, null, function* () {
      const parsedTableName = this.driver.parseTableName(tableOrName);
      const sql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`COLUMNS\` WHERE \`TABLE_SCHEMA\` = '${parsedTableName.database}' AND \`TABLE_NAME\` = '${parsedTableName.tableName}'`;
      const result = yield this.query(sql);
      return result.length ? true : false;
    });
  }
  /**
   * Checks if column with the given name exist in the given table.
   */
  hasColumn(tableOrName, column) {
    return __async(this, null, function* () {
      const parsedTableName = this.driver.parseTableName(tableOrName);
      const columnName = InstanceChecker.isTableColumn(column) ? column.name : column;
      const sql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`COLUMNS\` WHERE \`TABLE_SCHEMA\` = '${parsedTableName.database}' AND \`TABLE_NAME\` = '${parsedTableName.tableName}' AND \`COLUMN_NAME\` = '${columnName}'`;
      const result = yield this.query(sql);
      return result.length ? true : false;
    });
  }
  /**
   * Creates a new database.
   */
  createDatabase(database, ifNotExist) {
    return __async(this, null, function* () {
      const up = ifNotExist ? `CREATE DATABASE IF NOT EXISTS \`${database}\`` : `CREATE DATABASE \`${database}\``;
      const down = `DROP DATABASE \`${database}\``;
      yield this.executeQueries(new Query(up), new Query(down));
    });
  }
  /**
   * Drops database.
   */
  dropDatabase(database, ifExist) {
    return __async(this, null, function* () {
      const up = ifExist ? `DROP DATABASE IF EXISTS \`${database}\`` : `DROP DATABASE \`${database}\``;
      const down = `CREATE DATABASE \`${database}\``;
      yield this.executeQueries(new Query(up), new Query(down));
    });
  }
  /**
   * Creates a new table schema.
   */
  createSchema(schemaPath, ifNotExist) {
    return __async(this, null, function* () {
      throw new TypeORMError(`Schema create queries are not supported by MySql driver.`);
    });
  }
  /**
   * Drops table schema.
   */
  dropSchema(schemaPath, ifExist) {
    return __async(this, null, function* () {
      throw new TypeORMError(`Schema drop queries are not supported by MySql driver.`);
    });
  }
  /**
   * Creates a new table.
   */
  createTable(table, ifNotExist = false, createForeignKeys = true) {
    return __async(this, null, function* () {
      if (ifNotExist) {
        const isTableExist = yield this.hasTable(table);
        if (isTableExist) return Promise.resolve();
      }
      const upQueries = [];
      const downQueries = [];
      upQueries.push(this.createTableSql(table, createForeignKeys));
      downQueries.push(this.dropTableSql(table));
      table.indices.forEach((index) => downQueries.push(this.dropIndexSql(table, index)));
      if (createForeignKeys) table.foreignKeys.forEach((foreignKey) => downQueries.push(this.dropForeignKeySql(table, foreignKey)));
      return this.executeQueries(upQueries, downQueries);
    });
  }
  /**
   * Drop the table.
   */
  dropTable(target, ifExist, dropForeignKeys = true) {
    return __async(this, null, function* () {
      if (ifExist) {
        const isTableExist = yield this.hasTable(target);
        if (!isTableExist) return Promise.resolve();
      }
      const createForeignKeys = dropForeignKeys;
      const tablePath = this.getTablePath(target);
      const table = yield this.getCachedTable(tablePath);
      const upQueries = [];
      const downQueries = [];
      if (dropForeignKeys) table.foreignKeys.forEach((foreignKey) => upQueries.push(this.dropForeignKeySql(table, foreignKey)));
      table.indices.forEach((index) => upQueries.push(this.dropIndexSql(table, index)));
      upQueries.push(this.dropTableSql(table));
      downQueries.push(this.createTableSql(table, createForeignKeys));
      yield this.executeQueries(upQueries, downQueries);
    });
  }
  /**
   * Creates a new view.
   */
  createView(view, syncWithMetadata = false) {
    return __async(this, null, function* () {
      const upQueries = [];
      const downQueries = [];
      upQueries.push(this.createViewSql(view));
      if (syncWithMetadata) upQueries.push(yield this.insertViewDefinitionSql(view));
      downQueries.push(this.dropViewSql(view));
      if (syncWithMetadata) downQueries.push(yield this.deleteViewDefinitionSql(view));
      yield this.executeQueries(upQueries, downQueries);
    });
  }
  /**
   * Drops the view.
   */
  dropView(target) {
    return __async(this, null, function* () {
      const viewName = InstanceChecker.isView(target) ? target.name : target;
      const view = yield this.getCachedView(viewName);
      const upQueries = [];
      const downQueries = [];
      upQueries.push(yield this.deleteViewDefinitionSql(view));
      upQueries.push(this.dropViewSql(view));
      downQueries.push(yield this.insertViewDefinitionSql(view));
      downQueries.push(this.createViewSql(view));
      yield this.executeQueries(upQueries, downQueries);
    });
  }
  /**
   * Renames a table.
   */
  renameTable(oldTableOrName, newTableName) {
    return __async(this, null, function* () {
      const upQueries = [];
      const downQueries = [];
      const oldTable = InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : yield this.getCachedTable(oldTableOrName);
      const newTable = oldTable.clone();
      const {
        database
      } = this.driver.parseTableName(oldTable);
      newTable.name = database ? `${database}.${newTableName}` : newTableName;
      upQueries.push(new Query(`RENAME TABLE ${this.escapePath(oldTable)} TO ${this.escapePath(newTable)}`));
      downQueries.push(new Query(`RENAME TABLE ${this.escapePath(newTable)} TO ${this.escapePath(oldTable)}`));
      newTable.indices.forEach((index) => {
        const columnNames = index.columnNames.map((column) => `\`${column}\``).join(", ");
        const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
        let indexType = "";
        if (index.isUnique) indexType += "UNIQUE ";
        if (index.isSpatial) indexType += "SPATIAL ";
        if (index.isFulltext) indexType += "FULLTEXT ";
        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} DROP INDEX \`${index.name}\`, ADD ${indexType}INDEX \`${newIndexName}\` (${columnNames})`));
        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} DROP INDEX \`${newIndexName}\`, ADD ${indexType}INDEX \`${index.name}\` (${columnNames})`));
        index.name = newIndexName;
      });
      newTable.foreignKeys.forEach((foreignKey) => {
        const columnNames = foreignKey.columnNames.map((column) => `\`${column}\``).join(", ");
        const referencedColumnNames = foreignKey.referencedColumnNames.map((column) => `\`${column}\``).join(",");
        const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames);
        let up = `ALTER TABLE ${this.escapePath(newTable)} DROP FOREIGN KEY \`${foreignKey.name}\`, ADD CONSTRAINT \`${newForeignKeyName}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
        if (foreignKey.onDelete) up += ` ON DELETE ${foreignKey.onDelete}`;
        if (foreignKey.onUpdate) up += ` ON UPDATE ${foreignKey.onUpdate}`;
        let down = `ALTER TABLE ${this.escapePath(newTable)} DROP FOREIGN KEY \`${newForeignKeyName}\`, ADD CONSTRAINT \`${foreignKey.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
        if (foreignKey.onDelete) down += ` ON DELETE ${foreignKey.onDelete}`;
        if (foreignKey.onUpdate) down += ` ON UPDATE ${foreignKey.onUpdate}`;
        upQueries.push(new Query(up));
        downQueries.push(new Query(down));
        foreignKey.name = newForeignKeyName;
      });
      yield this.executeQueries(upQueries, downQueries);
      oldTable.name = newTable.name;
      this.replaceCachedTable(oldTable, newTable);
    });
  }
  /**
   * Creates a new column from the column in the table.
   */
  addColumn(tableOrName, column) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const clonedTable = table.clone();
      const upQueries = [];
      const downQueries = [];
      const skipColumnLevelPrimary = clonedTable.primaryColumns.length > 0;
      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column, skipColumnLevelPrimary, false)}`));
      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \`${column.name}\``));
      if (column.isPrimary && skipColumnLevelPrimary) {
        const generatedColumn = clonedTable.columns.find((column2) => column2.isGenerated && column2.generationStrategy === "increment");
        if (generatedColumn) {
          const nonGeneratedColumn = generatedColumn.clone();
          nonGeneratedColumn.isGenerated = false;
          nonGeneratedColumn.generationStrategy = void 0;
          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${column.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(column, true)}`));
        }
        const primaryColumns = clonedTable.primaryColumns;
        let columnNames = primaryColumns.map((column2) => `\`${column2.name}\``).join(", ");
        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
        primaryColumns.push(column);
        columnNames = primaryColumns.map((column2) => `\`${column2.name}\``).join(", ");
        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
        if (generatedColumn) {
          const nonGeneratedColumn = generatedColumn.clone();
          nonGeneratedColumn.isGenerated = false;
          nonGeneratedColumn.generationStrategy = void 0;
          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(column, true)}`));
          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${column.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
        }
      }
      const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
      if (columnIndex) {
        upQueries.push(this.createIndexSql(table, columnIndex));
        downQueries.push(this.dropIndexSql(table, columnIndex));
      } else if (column.isUnique) {
        const uniqueIndex = new TableIndex({
          name: this.connection.namingStrategy.indexName(table, [column.name]),
          columnNames: [column.name],
          isUnique: true
        });
        clonedTable.indices.push(uniqueIndex);
        clonedTable.uniques.push(new TableUnique({
          name: uniqueIndex.name,
          columnNames: uniqueIndex.columnNames
        }));
        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \`${uniqueIndex.name}\` (\`${column.name}\`)`));
        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${uniqueIndex.name}\``));
      }
      yield this.executeQueries(upQueries, downQueries);
      clonedTable.addColumn(column);
      this.replaceCachedTable(table, clonedTable);
    });
  }
  /**
   * Creates a new columns from the column in the table.
   */
  addColumns(tableOrName, columns) {
    return __async(this, null, function* () {
      for (const column of columns) {
        yield this.addColumn(tableOrName, column);
      }
    });
  }
  /**
   * Renames column in the given table.
   */
  renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c) => c.name === oldTableColumnOrName);
      if (!oldColumn) throw new TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
      let newColumn = void 0;
      if (InstanceChecker.isTableColumn(newTableColumnOrName)) {
        newColumn = newTableColumnOrName;
      } else {
        newColumn = oldColumn.clone();
        newColumn.name = newTableColumnOrName;
      }
      yield this.changeColumn(table, oldColumn, newColumn);
    });
  }
  /**
   * Changes a column in the table.
   */
  changeColumn(tableOrName, oldColumnOrName, newColumn) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      let clonedTable = table.clone();
      const upQueries = [];
      const downQueries = [];
      const oldColumn = InstanceChecker.isTableColumn(oldColumnOrName) ? oldColumnOrName : table.columns.find((column) => column.name === oldColumnOrName);
      if (!oldColumn) throw new TypeORMError(`Column "${oldColumnOrName}" was not found in the "${table.name}" table.`);
      if (newColumn.isGenerated !== oldColumn.isGenerated && newColumn.generationStrategy !== "uuid" || oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || oldColumn.generatedType !== newColumn.generatedType) {
        yield this.dropColumn(table, oldColumn);
        yield this.addColumn(table, newColumn);
        clonedTable = table.clone();
      } else {
        if (newColumn.name !== oldColumn.name) {
          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${oldColumn.name}\` \`${newColumn.name}\` ${this.buildCreateColumnSql(oldColumn, true, true)}`));
          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${newColumn.name}\` \`${oldColumn.name}\` ${this.buildCreateColumnSql(oldColumn, true, true)}`));
          clonedTable.findColumnIndices(oldColumn).forEach((index) => {
            index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);
            index.columnNames.push(newColumn.name);
            const columnNames = index.columnNames.map((column) => `\`${column}\``).join(", ");
            const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
            let indexType = "";
            if (index.isUnique) indexType += "UNIQUE ";
            if (index.isSpatial) indexType += "SPATIAL ";
            if (index.isFulltext) indexType += "FULLTEXT ";
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${index.name}\`, ADD ${indexType}INDEX \`${newIndexName}\` (${columnNames})`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${newIndexName}\`, ADD ${indexType}INDEX \`${index.name}\` (${columnNames})`));
            index.name = newIndexName;
          });
          clonedTable.findColumnForeignKeys(oldColumn).forEach((foreignKey) => {
            foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);
            foreignKey.columnNames.push(newColumn.name);
            const columnNames = foreignKey.columnNames.map((column) => `\`${column}\``).join(", ");
            const referencedColumnNames = foreignKey.referencedColumnNames.map((column) => `\`${column}\``).join(",");
            const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames);
            let up = `ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \`${foreignKey.name}\`, ADD CONSTRAINT \`${newForeignKeyName}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
            if (foreignKey.onDelete) up += ` ON DELETE ${foreignKey.onDelete}`;
            if (foreignKey.onUpdate) up += ` ON UPDATE ${foreignKey.onUpdate}`;
            let down = `ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \`${newForeignKeyName}\`, ADD CONSTRAINT \`${foreignKey.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
            if (foreignKey.onDelete) down += ` ON DELETE ${foreignKey.onDelete}`;
            if (foreignKey.onUpdate) down += ` ON UPDATE ${foreignKey.onUpdate}`;
            upQueries.push(new Query(up));
            downQueries.push(new Query(down));
            foreignKey.name = newForeignKeyName;
          });
          const oldTableColumn = clonedTable.columns.find((column) => column.name === oldColumn.name);
          clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;
          oldColumn.name = newColumn.name;
        }
        if (this.isColumnChanged(oldColumn, newColumn, true)) {
          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${oldColumn.name}\` ${this.buildCreateColumnSql(newColumn, true)}`));
          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${newColumn.name}\` ${this.buildCreateColumnSql(oldColumn, true)}`));
        }
        if (newColumn.isPrimary !== oldColumn.isPrimary) {
          const generatedColumn = clonedTable.columns.find((column) => column.isGenerated && column.generationStrategy === "increment");
          if (generatedColumn) {
            const nonGeneratedColumn = generatedColumn.clone();
            nonGeneratedColumn.isGenerated = false;
            nonGeneratedColumn.generationStrategy = void 0;
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
          }
          const primaryColumns = clonedTable.primaryColumns;
          if (primaryColumns.length > 0) {
            const columnNames = primaryColumns.map((column) => `\`${column.name}\``).join(", ");
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
          }
          if (newColumn.isPrimary === true) {
            primaryColumns.push(newColumn);
            const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
            column.isPrimary = true;
            const columnNames = primaryColumns.map((column2) => `\`${column2.name}\``).join(", ");
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
          } else {
            const primaryColumn = primaryColumns.find((c) => c.name === newColumn.name);
            primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1);
            const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
            column.isPrimary = false;
            if (primaryColumns.length > 0) {
              const columnNames = primaryColumns.map((column2) => `\`${column2.name}\``).join(", ");
              upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
              downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
            }
          }
          if (generatedColumn) {
            const nonGeneratedColumn = generatedColumn.clone();
            nonGeneratedColumn.isGenerated = false;
            nonGeneratedColumn.generationStrategy = void 0;
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
          }
        }
        if (newColumn.isUnique !== oldColumn.isUnique) {
          if (newColumn.isUnique === true) {
            const uniqueIndex = new TableIndex({
              name: this.connection.namingStrategy.indexName(table, [newColumn.name]),
              columnNames: [newColumn.name],
              isUnique: true
            });
            clonedTable.indices.push(uniqueIndex);
            clonedTable.uniques.push(new TableUnique({
              name: uniqueIndex.name,
              columnNames: uniqueIndex.columnNames
            }));
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \`${uniqueIndex.name}\` (\`${newColumn.name}\`)`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${uniqueIndex.name}\``));
          } else {
            const uniqueIndex = clonedTable.indices.find((index) => {
              return index.columnNames.length === 1 && index.isUnique === true && !!index.columnNames.find((columnName) => columnName === newColumn.name);
            });
            clonedTable.indices.splice(clonedTable.indices.indexOf(uniqueIndex), 1);
            const tableUnique = clonedTable.uniques.find((unique) => unique.name === uniqueIndex.name);
            clonedTable.uniques.splice(clonedTable.uniques.indexOf(tableUnique), 1);
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${uniqueIndex.name}\``));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \`${uniqueIndex.name}\` (\`${newColumn.name}\`)`));
          }
        }
      }
      yield this.executeQueries(upQueries, downQueries);
      this.replaceCachedTable(table, clonedTable);
    });
  }
  /**
   * Changes a column in the table.
   */
  changeColumns(tableOrName, changedColumns) {
    return __async(this, null, function* () {
      for (const {
        oldColumn,
        newColumn
      } of changedColumns) {
        yield this.changeColumn(tableOrName, oldColumn, newColumn);
      }
    });
  }
  /**
   * Drops column in the table.
   */
  dropColumn(tableOrName, columnOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const column = InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);
      if (!column) throw new TypeORMError(`Column "${columnOrName}" was not found in table "${table.name}"`);
      const clonedTable = table.clone();
      const upQueries = [];
      const downQueries = [];
      if (column.isPrimary) {
        const generatedColumn = clonedTable.columns.find((column2) => column2.isGenerated && column2.generationStrategy === "increment");
        if (generatedColumn) {
          const nonGeneratedColumn = generatedColumn.clone();
          nonGeneratedColumn.isGenerated = false;
          nonGeneratedColumn.generationStrategy = void 0;
          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
        }
        const columnNames = clonedTable.primaryColumns.map((primaryColumn) => `\`${primaryColumn.name}\``).join(", ");
        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP PRIMARY KEY`));
        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD PRIMARY KEY (${columnNames})`));
        const tableColumn = clonedTable.findColumnByName(column.name);
        tableColumn.isPrimary = false;
        if (clonedTable.primaryColumns.length > 0) {
          const columnNames2 = clonedTable.primaryColumns.map((primaryColumn) => `\`${primaryColumn.name}\``).join(", ");
          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD PRIMARY KEY (${columnNames2})`));
          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP PRIMARY KEY`));
        }
        if (generatedColumn && generatedColumn.name !== column.name) {
          const nonGeneratedColumn = generatedColumn.clone();
          nonGeneratedColumn.isGenerated = false;
          nonGeneratedColumn.generationStrategy = void 0;
          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
        }
      }
      const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
      if (columnIndex) {
        clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);
        upQueries.push(this.dropIndexSql(table, columnIndex));
        downQueries.push(this.createIndexSql(table, columnIndex));
      } else if (column.isUnique) {
        const uniqueName = this.connection.namingStrategy.uniqueConstraintName(table, [column.name]);
        const foundUnique = clonedTable.uniques.find((unique) => unique.name === uniqueName);
        if (foundUnique) clonedTable.uniques.splice(clonedTable.uniques.indexOf(foundUnique), 1);
        const indexName = this.connection.namingStrategy.indexName(table, [column.name]);
        const foundIndex = clonedTable.indices.find((index) => index.name === indexName);
        if (foundIndex) clonedTable.indices.splice(clonedTable.indices.indexOf(foundIndex), 1);
        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${indexName}\``));
        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \`${indexName}\` (\`${column.name}\`)`));
      }
      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \`${column.name}\``));
      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column, true)}`));
      yield this.executeQueries(upQueries, downQueries);
      clonedTable.removeColumn(column);
      this.replaceCachedTable(table, clonedTable);
    });
  }
  /**
   * Drops the columns in the table.
   */
  dropColumns(tableOrName, columns) {
    return __async(this, null, function* () {
      for (const column of columns) {
        yield this.dropColumn(tableOrName, column);
      }
    });
  }
  /**
   * Creates a new primary key.
   */
  createPrimaryKey(tableOrName, columnNames) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const clonedTable = table.clone();
      const up = this.createPrimaryKeySql(table, columnNames);
      const down = this.dropPrimaryKeySql(table);
      yield this.executeQueries(up, down);
      clonedTable.columns.forEach((column) => {
        if (columnNames.find((columnName) => columnName === column.name)) column.isPrimary = true;
      });
      this.replaceCachedTable(table, clonedTable);
    });
  }
  /**
   * Updates composite primary keys.
   */
  updatePrimaryKeys(tableOrName, columns) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const clonedTable = table.clone();
      const columnNames = columns.map((column) => column.name);
      const upQueries = [];
      const downQueries = [];
      const generatedColumn = clonedTable.columns.find((column) => column.isGenerated && column.generationStrategy === "increment");
      if (generatedColumn) {
        const nonGeneratedColumn = generatedColumn.clone();
        nonGeneratedColumn.isGenerated = false;
        nonGeneratedColumn.generationStrategy = void 0;
        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
      }
      const primaryColumns = clonedTable.primaryColumns;
      if (primaryColumns.length > 0) {
        const columnNames2 = primaryColumns.map((column) => `\`${column.name}\``).join(", ");
        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames2})`));
      }
      clonedTable.columns.filter((column) => columnNames.indexOf(column.name) !== -1).forEach((column) => column.isPrimary = true);
      const columnNamesString = columnNames.map((columnName) => `\`${columnName}\``).join(", ");
      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNamesString})`));
      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
      const newOrExistGeneratedColumn = generatedColumn ? generatedColumn : columns.find((column) => column.isGenerated && column.generationStrategy === "increment");
      if (newOrExistGeneratedColumn) {
        const nonGeneratedColumn = newOrExistGeneratedColumn.clone();
        nonGeneratedColumn.isGenerated = false;
        nonGeneratedColumn.generationStrategy = void 0;
        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(newOrExistGeneratedColumn, true)}`));
        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${newOrExistGeneratedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
        const changedGeneratedColumn = clonedTable.columns.find((column) => column.name === newOrExistGeneratedColumn.name);
        changedGeneratedColumn.isGenerated = true;
        changedGeneratedColumn.generationStrategy = "increment";
      }
      yield this.executeQueries(upQueries, downQueries);
      this.replaceCachedTable(table, clonedTable);
    });
  }
  /**
   * Drops a primary key.
   */
  dropPrimaryKey(tableOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const up = this.dropPrimaryKeySql(table);
      const down = this.createPrimaryKeySql(table, table.primaryColumns.map((column) => column.name));
      yield this.executeQueries(up, down);
      table.primaryColumns.forEach((column) => {
        column.isPrimary = false;
      });
    });
  }
  /**
   * Creates a new unique constraint.
   */
  createUniqueConstraint(tableOrName, uniqueConstraint) {
    return __async(this, null, function* () {
      throw new TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);
    });
  }
  /**
   * Creates a new unique constraints.
   */
  createUniqueConstraints(tableOrName, uniqueConstraints) {
    return __async(this, null, function* () {
      throw new TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);
    });
  }
  /**
   * Drops an unique constraint.
   */
  dropUniqueConstraint(tableOrName, uniqueOrName) {
    return __async(this, null, function* () {
      throw new TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);
    });
  }
  /**
   * Drops an unique constraints.
   */
  dropUniqueConstraints(tableOrName, uniqueConstraints) {
    return __async(this, null, function* () {
      throw new TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);
    });
  }
  /**
   * Creates a new check constraint.
   */
  createCheckConstraint(tableOrName, checkConstraint) {
    return __async(this, null, function* () {
      throw new TypeORMError(`MySql does not support check constraints.`);
    });
  }
  /**
   * Creates a new check constraints.
   */
  createCheckConstraints(tableOrName, checkConstraints) {
    return __async(this, null, function* () {
      throw new TypeORMError(`MySql does not support check constraints.`);
    });
  }
  /**
   * Drops check constraint.
   */
  dropCheckConstraint(tableOrName, checkOrName) {
    return __async(this, null, function* () {
      throw new TypeORMError(`MySql does not support check constraints.`);
    });
  }
  /**
   * Drops check constraints.
   */
  dropCheckConstraints(tableOrName, checkConstraints) {
    return __async(this, null, function* () {
      throw new TypeORMError(`MySql does not support check constraints.`);
    });
  }
  /**
   * Creates a new exclusion constraint.
   */
  createExclusionConstraint(tableOrName, exclusionConstraint) {
    return __async(this, null, function* () {
      throw new TypeORMError(`MySql does not support exclusion constraints.`);
    });
  }
  /**
   * Creates a new exclusion constraints.
   */
  createExclusionConstraints(tableOrName, exclusionConstraints) {
    return __async(this, null, function* () {
      throw new TypeORMError(`MySql does not support exclusion constraints.`);
    });
  }
  /**
   * Drops exclusion constraint.
   */
  dropExclusionConstraint(tableOrName, exclusionOrName) {
    return __async(this, null, function* () {
      throw new TypeORMError(`MySql does not support exclusion constraints.`);
    });
  }
  /**
   * Drops exclusion constraints.
   */
  dropExclusionConstraints(tableOrName, exclusionConstraints) {
    return __async(this, null, function* () {
      throw new TypeORMError(`MySql does not support exclusion constraints.`);
    });
  }
  /**
   * Creates a new foreign key.
   */
  createForeignKey(tableOrName, foreignKey) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      if (!foreignKey.name) foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames);
      const up = this.createForeignKeySql(table, foreignKey);
      const down = this.dropForeignKeySql(table, foreignKey);
      yield this.executeQueries(up, down);
      table.addForeignKey(foreignKey);
    });
  }
  /**
   * Creates a new foreign keys.
   */
  createForeignKeys(tableOrName, foreignKeys) {
    return __async(this, null, function* () {
      const promises = foreignKeys.map((foreignKey) => this.createForeignKey(tableOrName, foreignKey));
      yield Promise.all(promises);
    });
  }
  /**
   * Drops a foreign key.
   */
  dropForeignKey(tableOrName, foreignKeyOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName);
      if (!foreignKey) throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
      const up = this.dropForeignKeySql(table, foreignKey);
      const down = this.createForeignKeySql(table, foreignKey);
      yield this.executeQueries(up, down);
      table.removeForeignKey(foreignKey);
    });
  }
  /**
   * Drops a foreign keys from the table.
   */
  dropForeignKeys(tableOrName, foreignKeys) {
    return __async(this, null, function* () {
      const promises = foreignKeys.map((foreignKey) => this.dropForeignKey(tableOrName, foreignKey));
      yield Promise.all(promises);
    });
  }
  /**
   * Creates a new index.
   */
  createIndex(tableOrName, index) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      if (!index.name) index.name = this.generateIndexName(table, index);
      const up = this.createIndexSql(table, index);
      const down = this.dropIndexSql(table, index);
      yield this.executeQueries(up, down);
      table.addIndex(index, true);
    });
  }
  /**
   * Creates a new indices
   */
  createIndices(tableOrName, indices) {
    return __async(this, null, function* () {
      const promises = indices.map((index) => this.createIndex(tableOrName, index));
      yield Promise.all(promises);
    });
  }
  /**
   * Drops an index.
   */
  dropIndex(tableOrName, indexOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const index = InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find((i) => i.name === indexOrName);
      if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);
      if (!index.name) index.name = this.generateIndexName(table, index);
      const up = this.dropIndexSql(table, index);
      const down = this.createIndexSql(table, index);
      yield this.executeQueries(up, down);
      table.removeIndex(index, true);
    });
  }
  /**
   * Drops an indices from the table.
   */
  dropIndices(tableOrName, indices) {
    return __async(this, null, function* () {
      const promises = indices.map((index) => this.dropIndex(tableOrName, index));
      yield Promise.all(promises);
    });
  }
  /**
   * Clears all table contents.
   * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
   */
  clearTable(tableOrName) {
    return __async(this, null, function* () {
      yield this.query(`TRUNCATE TABLE ${this.escapePath(tableOrName)}`);
    });
  }
  /**
   * Removes all tables from the currently connected database.
   * Be careful using this method and avoid using it in production or migrations
   * (because it can clear all your database).
   */
  clearDatabase(database) {
    return __async(this, null, function* () {
      const dbName = database ? database : this.driver.database;
      if (dbName) {
        const isDatabaseExist = yield this.hasDatabase(dbName);
        if (!isDatabaseExist) return Promise.resolve();
      } else {
        throw new TypeORMError(`Can not clear database. No database is specified`);
      }
      const isAnotherTransactionActive = this.isTransactionActive;
      if (!isAnotherTransactionActive) yield this.startTransaction();
      try {
        const selectViewDropsQuery = `SELECT concat('DROP VIEW IF EXISTS \`', table_schema, '\`.\`', table_name, '\`') AS \`query\` FROM \`INFORMATION_SCHEMA\`.\`VIEWS\` WHERE \`TABLE_SCHEMA\` = '${dbName}'`;
        const dropViewQueries = yield this.query(selectViewDropsQuery);
        yield Promise.all(dropViewQueries.map((q) => this.query(q["query"])));
        const disableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 0;`;
        const dropTablesQuery = `SELECT concat('DROP TABLE IF EXISTS \`', table_schema, '\`.\`', table_name, '\`') AS \`query\` FROM \`INFORMATION_SCHEMA\`.\`TABLES\` WHERE \`TABLE_SCHEMA\` = '${dbName}'`;
        const enableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 1;`;
        yield this.query(disableForeignKeysCheckQuery);
        const dropQueries = yield this.query(dropTablesQuery);
        yield Promise.all(dropQueries.map((query) => this.query(query["query"])));
        yield this.query(enableForeignKeysCheckQuery);
        if (!isAnotherTransactionActive) {
          yield this.commitTransaction();
        }
      } catch (error) {
        try {
          if (!isAnotherTransactionActive) {
            yield this.rollbackTransaction();
          }
        } catch (rollbackError) {
        }
        throw error;
      }
    });
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  loadViews(viewNames) {
    return __async(this, null, function* () {
      const hasTable = yield this.hasTable(this.getTypeormMetadataTableName());
      if (!hasTable) {
        return [];
      }
      if (!viewNames) {
        viewNames = [];
      }
      const currentDatabase = yield this.getCurrentDatabase();
      const viewsCondition = viewNames.map((tableName) => {
        let {
          database,
          tableName: name
        } = this.driver.parseTableName(tableName);
        if (!database) {
          database = currentDatabase;
        }
        return `(\`t\`.\`schema\` = '${database}' AND \`t\`.\`name\` = '${name}')`;
      }).join(" OR ");
      const query = `SELECT \`t\`.*, \`v\`.\`check_option\` FROM ${this.escapePath(this.getTypeormMetadataTableName())} \`t\` INNER JOIN \`information_schema\`.\`views\` \`v\` ON \`v\`.\`table_schema\` = \`t\`.\`schema\` AND \`v\`.\`table_name\` = \`t\`.\`name\` WHERE \`t\`.\`type\` = '${MetadataTableType.VIEW}' ${viewsCondition ? `AND (${viewsCondition})` : ""}`;
      const dbViews = yield this.query(query);
      return dbViews.map((dbView) => {
        const view = new View();
        const db = dbView["schema"] === currentDatabase ? void 0 : dbView["schema"];
        view.database = dbView["schema"];
        view.name = this.driver.buildTableName(dbView["name"], void 0, db);
        view.expression = dbView["value"];
        return view;
      });
    });
  }
  /**
   * Loads all tables (with given names) from the database and creates a Table from them.
   */
  loadTables(tableNames) {
    return __async(this, null, function* () {
      if (tableNames && tableNames.length === 0) {
        return [];
      }
      const dbTables = [];
      const currentDatabase = yield this.getCurrentDatabase();
      if (!tableNames) {
        const tablesSql = `SELECT TABLE_NAME, TABLE_SCHEMA FROM \`INFORMATION_SCHEMA\`.\`TABLES\``;
        dbTables.push(...yield this.query(tablesSql));
      } else {
        const tablesCondition = tableNames.map((tableName) => {
          let [database, name] = tableName.split(".");
          if (!name) {
            name = database;
            database = this.driver.database || currentDatabase;
          }
          return `(\`TABLE_SCHEMA\` = '${database}' AND \`TABLE_NAME\` = '${name}')`;
        }).join(" OR ");
        const tablesSql = `SELECT TABLE_NAME, TABLE_SCHEMA FROM \`INFORMATION_SCHEMA\`.\`TABLES\` WHERE ` + tablesCondition;
        dbTables.push(...yield this.query(tablesSql));
      }
      if (dbTables.length === 0) {
        return [];
      }
      const columnsCondition = dbTables.map(({
        TABLE_NAME,
        TABLE_SCHEMA
      }) => {
        return `(\`TABLE_SCHEMA\` = '${TABLE_SCHEMA}' AND \`TABLE_NAME\` = '${TABLE_NAME}')`;
      }).join(" OR ");
      const columnsSql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`COLUMNS\` WHERE ` + columnsCondition;
      const primaryKeySql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`KEY_COLUMN_USAGE\` WHERE \`CONSTRAINT_NAME\` = 'PRIMARY' AND (${columnsCondition})`;
      const collationsSql = `SELECT \`SCHEMA_NAME\`, \`DEFAULT_CHARACTER_SET_NAME\` as \`CHARSET\`, \`DEFAULT_COLLATION_NAME\` AS \`COLLATION\` FROM \`INFORMATION_SCHEMA\`.\`SCHEMATA\``;
      const indicesCondition = dbTables.map(({
        TABLE_NAME,
        TABLE_SCHEMA
      }) => {
        return `(\`s\`.\`TABLE_SCHEMA\` = '${TABLE_SCHEMA}' AND \`s\`.\`TABLE_NAME\` = '${TABLE_NAME}')`;
      }).join(" OR ");
      const indicesSql = `SELECT \`s\`.* FROM \`INFORMATION_SCHEMA\`.\`STATISTICS\` \`s\` LEFT JOIN \`INFORMATION_SCHEMA\`.\`REFERENTIAL_CONSTRAINTS\` \`rc\` ON \`s\`.\`INDEX_NAME\` = \`rc\`.\`CONSTRAINT_NAME\` WHERE (${indicesCondition}) AND \`s\`.\`INDEX_NAME\` != 'PRIMARY' AND \`rc\`.\`CONSTRAINT_NAME\` IS NULL`;
      const foreignKeysCondition = dbTables.map(({
        TABLE_NAME,
        TABLE_SCHEMA
      }) => {
        return `(\`kcu\`.\`TABLE_SCHEMA\` = '${TABLE_SCHEMA}' AND \`kcu\`.\`TABLE_NAME\` = '${TABLE_NAME}')`;
      }).join(" OR ");
      const foreignKeysSql = `SELECT \`kcu\`.\`TABLE_SCHEMA\`, \`kcu\`.\`TABLE_NAME\`, \`kcu\`.\`CONSTRAINT_NAME\`, \`kcu\`.\`COLUMN_NAME\`, \`kcu\`.\`REFERENCED_TABLE_SCHEMA\`, \`kcu\`.\`REFERENCED_TABLE_NAME\`, \`kcu\`.\`REFERENCED_COLUMN_NAME\`, \`rc\`.\`DELETE_RULE\` \`ON_DELETE\`, \`rc\`.\`UPDATE_RULE\` \`ON_UPDATE\` FROM \`INFORMATION_SCHEMA\`.\`KEY_COLUMN_USAGE\` \`kcu\` INNER JOIN \`INFORMATION_SCHEMA\`.\`REFERENTIAL_CONSTRAINTS\` \`rc\` ON \`rc\`.\`constraint_name\` = \`kcu\`.\`constraint_name\` WHERE ` + foreignKeysCondition;
      const [dbColumns, dbPrimaryKeys, dbCollations, dbIndices, dbForeignKeys] = yield Promise.all([this.query(columnsSql), this.query(primaryKeySql), this.query(collationsSql), this.query(indicesSql), this.query(foreignKeysSql)]);
      return Promise.all(dbTables.map((dbTable) => __async(this, null, function* () {
        const table = new Table();
        const dbCollation = dbCollations.find((coll) => coll["SCHEMA_NAME"] === dbTable["TABLE_SCHEMA"]);
        const defaultCollation = dbCollation["COLLATION"];
        const defaultCharset = dbCollation["CHARSET"];
        const db = dbTable["TABLE_SCHEMA"] === currentDatabase ? void 0 : dbTable["TABLE_SCHEMA"];
        table.database = dbTable["TABLE_SCHEMA"];
        table.name = this.driver.buildTableName(dbTable["TABLE_NAME"], void 0, db);
        table.columns = dbColumns.filter((dbColumn) => dbColumn["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbColumn["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"]).map((dbColumn) => {
          const columnUniqueIndices = dbIndices.filter((dbIndex) => {
            return dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbIndex["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"] && dbIndex["COLUMN_NAME"] === dbColumn["COLUMN_NAME"] && parseInt(dbIndex["NON_UNIQUE"], 10) === 0;
          });
          const tableMetadata = this.connection.entityMetadatas.find((metadata) => this.getTablePath(table) === this.getTablePath(metadata));
          const hasIgnoredIndex = columnUniqueIndices.length > 0 && tableMetadata && tableMetadata.indices.some((index) => {
            return columnUniqueIndices.some((uniqueIndex) => {
              return index.name === uniqueIndex["INDEX_NAME"] && index.synchronize === false;
            });
          });
          const isConstraintComposite = columnUniqueIndices.every((uniqueIndex) => {
            return dbIndices.some((dbIndex) => dbIndex["INDEX_NAME"] === uniqueIndex["INDEX_NAME"] && dbIndex["COLUMN_NAME"] !== dbColumn["COLUMN_NAME"]);
          });
          const tableColumn = new TableColumn();
          tableColumn.name = dbColumn["COLUMN_NAME"];
          tableColumn.type = dbColumn["DATA_TYPE"].toLowerCase();
          tableColumn.unsigned = tableColumn.zerofill ? true : dbColumn["COLUMN_TYPE"].indexOf("unsigned") !== -1;
          if (this.driver.withWidthColumnTypes.indexOf(tableColumn.type) !== -1) {
            const width = dbColumn["COLUMN_TYPE"].substring(dbColumn["COLUMN_TYPE"].indexOf("(") + 1, dbColumn["COLUMN_TYPE"].indexOf(")"));
            tableColumn.width = width && !this.isDefaultColumnWidth(table, tableColumn, parseInt(width)) ? parseInt(width) : void 0;
          }
          if (dbColumn["COLUMN_DEFAULT"] === null || dbColumn["COLUMN_DEFAULT"] === void 0) {
            tableColumn.default = void 0;
          } else {
            tableColumn.default = dbColumn["COLUMN_DEFAULT"] === "CURRENT_TIMESTAMP" ? dbColumn["COLUMN_DEFAULT"] : `'${dbColumn["COLUMN_DEFAULT"]}'`;
          }
          if (dbColumn["EXTRA"].indexOf("on update") !== -1) {
            tableColumn.onUpdate = dbColumn["EXTRA"].substring(dbColumn["EXTRA"].indexOf("on update") + 10);
          }
          if (dbColumn["GENERATION_EXPRESSION"]) {
            tableColumn.asExpression = dbColumn["GENERATION_EXPRESSION"];
            tableColumn.generatedType = dbColumn["EXTRA"].indexOf("VIRTUAL") !== -1 ? "VIRTUAL" : "STORED";
          }
          tableColumn.isUnique = columnUniqueIndices.length > 0 && !hasIgnoredIndex && !isConstraintComposite;
          tableColumn.isNullable = dbColumn["IS_NULLABLE"] === "YES";
          tableColumn.isPrimary = dbPrimaryKeys.some((dbPrimaryKey) => {
            return dbPrimaryKey["TABLE_NAME"] === dbColumn["TABLE_NAME"] && dbPrimaryKey["TABLE_SCHEMA"] === dbColumn["TABLE_SCHEMA"] && dbPrimaryKey["COLUMN_NAME"] === dbColumn["COLUMN_NAME"];
          });
          tableColumn.zerofill = dbColumn["COLUMN_TYPE"].indexOf("zerofill") !== -1;
          tableColumn.isGenerated = dbColumn["EXTRA"].indexOf("auto_increment") !== -1;
          if (tableColumn.isGenerated) tableColumn.generationStrategy = "increment";
          tableColumn.comment = typeof dbColumn["COLUMN_COMMENT"] === "string" && dbColumn["COLUMN_COMMENT"].length === 0 ? void 0 : dbColumn["COLUMN_COMMENT"];
          if (dbColumn["CHARACTER_SET_NAME"]) tableColumn.charset = dbColumn["CHARACTER_SET_NAME"] === defaultCharset ? void 0 : dbColumn["CHARACTER_SET_NAME"];
          if (dbColumn["COLLATION_NAME"]) tableColumn.collation = dbColumn["COLLATION_NAME"] === defaultCollation ? void 0 : dbColumn["COLLATION_NAME"];
          if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1 && dbColumn["CHARACTER_MAXIMUM_LENGTH"]) {
            const length = dbColumn["CHARACTER_MAXIMUM_LENGTH"].toString();
            tableColumn.length = !this.isDefaultColumnLength(table, tableColumn, length) ? length : "";
          }
          if (tableColumn.type === "decimal" || tableColumn.type === "double" || tableColumn.type === "float") {
            if (dbColumn["NUMERIC_PRECISION"] !== null && !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["NUMERIC_PRECISION"])) tableColumn.precision = parseInt(dbColumn["NUMERIC_PRECISION"]);
            if (dbColumn["NUMERIC_SCALE"] !== null && !this.isDefaultColumnScale(table, tableColumn, dbColumn["NUMERIC_SCALE"])) tableColumn.scale = parseInt(dbColumn["NUMERIC_SCALE"]);
          }
          if (tableColumn.type === "enum" || tableColumn.type === "simple-enum" || tableColumn.type === "set") {
            const colType = dbColumn["COLUMN_TYPE"];
            const items = colType.substring(colType.indexOf("(") + 1, colType.lastIndexOf(")")).split(",");
            tableColumn.enum = items.map((item) => {
              return item.substring(1, item.length - 1);
            });
            tableColumn.length = "";
          }
          if ((tableColumn.type === "datetime" || tableColumn.type === "time" || tableColumn.type === "timestamp") && dbColumn["DATETIME_PRECISION"] !== null && dbColumn["DATETIME_PRECISION"] !== void 0 && !this.isDefaultColumnPrecision(table, tableColumn, parseInt(dbColumn["DATETIME_PRECISION"]))) {
            tableColumn.precision = parseInt(dbColumn["DATETIME_PRECISION"]);
          }
          return tableColumn;
        });
        const tableForeignKeyConstraints = OrmUtils.uniq(dbForeignKeys.filter((dbForeignKey) => {
          return dbForeignKey["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbForeignKey["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"];
        }), (dbForeignKey) => dbForeignKey["CONSTRAINT_NAME"]);
        table.foreignKeys = tableForeignKeyConstraints.map((dbForeignKey) => {
          const foreignKeys = dbForeignKeys.filter((dbFk) => dbFk["CONSTRAINT_NAME"] === dbForeignKey["CONSTRAINT_NAME"]);
          const database = dbForeignKey["REFERENCED_TABLE_SCHEMA"] === currentDatabase ? void 0 : dbForeignKey["REFERENCED_TABLE_SCHEMA"];
          const referencedTableName = this.driver.buildTableName(dbForeignKey["REFERENCED_TABLE_NAME"], void 0, database);
          return new TableForeignKey({
            name: dbForeignKey["CONSTRAINT_NAME"],
            columnNames: foreignKeys.map((dbFk) => dbFk["COLUMN_NAME"]),
            referencedDatabase: dbForeignKey["REFERENCED_TABLE_SCHEMA"],
            referencedTableName,
            referencedColumnNames: foreignKeys.map((dbFk) => dbFk["REFERENCED_COLUMN_NAME"]),
            onDelete: dbForeignKey["ON_DELETE"],
            onUpdate: dbForeignKey["ON_UPDATE"]
          });
        });
        const tableIndexConstraints = OrmUtils.uniq(dbIndices.filter((dbIndex) => {
          return dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbIndex["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"];
        }), (dbIndex) => dbIndex["INDEX_NAME"]);
        table.indices = tableIndexConstraints.map((constraint) => {
          const indices = dbIndices.filter((index) => {
            return index["TABLE_SCHEMA"] === constraint["TABLE_SCHEMA"] && index["TABLE_NAME"] === constraint["TABLE_NAME"] && index["INDEX_NAME"] === constraint["INDEX_NAME"];
          });
          const nonUnique = parseInt(constraint["NON_UNIQUE"], 10);
          return new TableIndex({
            table,
            name: constraint["INDEX_NAME"],
            columnNames: indices.map((i) => i["COLUMN_NAME"]),
            isUnique: nonUnique === 0,
            isSpatial: constraint["INDEX_TYPE"] === "SPATIAL",
            isFulltext: constraint["INDEX_TYPE"] === "FULLTEXT"
          });
        });
        return table;
      })));
    });
  }
  /**
   * Builds create table sql
   */
  createTableSql(table, createForeignKeys) {
    const columnDefinitions = table.columns.map((column) => this.buildCreateColumnSql(column, true)).join(", ");
    let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;
    table.columns.filter((column) => column.isUnique).forEach((column) => {
      const isUniqueIndexExist = table.indices.some((index) => {
        return index.columnNames.length === 1 && !!index.isUnique && index.columnNames.indexOf(column.name) !== -1;
      });
      const isUniqueConstraintExist = table.uniques.some((unique) => {
        return unique.columnNames.length === 1 && unique.columnNames.indexOf(column.name) !== -1;
      });
      if (!isUniqueIndexExist && !isUniqueConstraintExist) table.indices.push(new TableIndex({
        name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
        columnNames: [column.name],
        isUnique: true
      }));
    });
    if (table.uniques.length > 0) {
      table.uniques.forEach((unique) => {
        const uniqueExist = table.indices.some((index) => index.name === unique.name);
        if (!uniqueExist) {
          table.indices.push(new TableIndex({
            name: unique.name,
            columnNames: unique.columnNames,
            isUnique: true
          }));
        }
      });
    }
    if (table.indices.length > 0) {
      const indicesSql = table.indices.map((index) => {
        const columnNames = index.columnNames.map((columnName) => `\`${columnName}\``).join(", ");
        if (!index.name) index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
        let indexType = "";
        if (index.isUnique) indexType += "UNIQUE ";
        if (index.isSpatial) indexType += "SPATIAL ";
        if (index.isFulltext) indexType += "FULLTEXT ";
        return `${indexType}INDEX \`${index.name}\` (${columnNames})`;
      }).join(", ");
      sql += `, ${indicesSql}`;
    }
    if (table.foreignKeys.length > 0 && createForeignKeys) {
      const foreignKeysSql = table.foreignKeys.map((fk) => {
        const columnNames = fk.columnNames.map((columnName) => `\`${columnName}\``).join(", ");
        if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames);
        const referencedColumnNames = fk.referencedColumnNames.map((columnName) => `\`${columnName}\``).join(", ");
        let constraint = `CONSTRAINT \`${fk.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;
        if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`;
        if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`;
        return constraint;
      }).join(", ");
      sql += `, ${foreignKeysSql}`;
    }
    if (table.primaryColumns.length > 0) {
      const columnNames = table.primaryColumns.map((column) => `\`${column.name}\``).join(", ");
      sql += `, PRIMARY KEY (${columnNames})`;
    }
    sql += `) ENGINE=${table.engine || "InnoDB"}`;
    return new Query(sql);
  }
  /**
   * Builds drop table sql
   */
  dropTableSql(tableOrName) {
    return new Query(`DROP TABLE ${this.escapePath(tableOrName)}`);
  }
  createViewSql(view) {
    if (typeof view.expression === "string") {
      return new Query(`CREATE VIEW ${this.escapePath(view)} AS ${view.expression}`);
    } else {
      return new Query(`CREATE VIEW ${this.escapePath(view)} AS ${view.expression(this.connection).getQuery()}`);
    }
  }
  insertViewDefinitionSql(view) {
    return __async(this, null, function* () {
      const currentDatabase = yield this.getCurrentDatabase();
      const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
      return this.insertTypeormMetadataSql({
        type: MetadataTableType.VIEW,
        schema: currentDatabase,
        name: view.name,
        value: expression
      });
    });
  }
  /**
   * Builds drop view sql.
   */
  dropViewSql(viewOrPath) {
    return new Query(`DROP VIEW ${this.escapePath(viewOrPath)}`);
  }
  /**
   * Builds remove view sql.
   */
  deleteViewDefinitionSql(viewOrPath) {
    return __async(this, null, function* () {
      const currentDatabase = yield this.getCurrentDatabase();
      const viewName = InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;
      return this.deleteTypeormMetadataSql({
        type: MetadataTableType.VIEW,
        schema: currentDatabase,
        name: viewName
      });
    });
  }
  /**
   * Builds create index sql.
   */
  createIndexSql(table, index) {
    const columns = index.columnNames.map((columnName) => `\`${columnName}\``).join(", ");
    let indexType = "";
    if (index.isUnique) indexType += "UNIQUE ";
    if (index.isSpatial) indexType += "SPATIAL ";
    if (index.isFulltext) indexType += "FULLTEXT ";
    return new Query(`CREATE ${indexType}INDEX \`${index.name}\` ON ${this.escapePath(table)} (${columns})`);
  }
  /**
   * Builds drop index sql.
   */
  dropIndexSql(table, indexOrName) {
    let indexName = InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;
    return new Query(`DROP INDEX \`${indexName}\` ON ${this.escapePath(table)}`);
  }
  /**
   * Builds create primary key sql.
   */
  createPrimaryKeySql(table, columnNames) {
    const columnNamesString = columnNames.map((columnName) => `\`${columnName}\``).join(", ");
    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNamesString})`);
  }
  /**
   * Builds drop primary key sql.
   */
  dropPrimaryKeySql(table) {
    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`);
  }
  /**
   * Builds create foreign key sql.
   */
  createForeignKeySql(table, foreignKey) {
    const columnNames = foreignKey.columnNames.map((column) => `\`${column}\``).join(", ");
    const referencedColumnNames = foreignKey.referencedColumnNames.map((column) => `\`${column}\``).join(",");
    let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \`${foreignKey.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
    if (foreignKey.onDelete) sql += ` ON DELETE ${foreignKey.onDelete}`;
    if (foreignKey.onUpdate) sql += ` ON UPDATE ${foreignKey.onUpdate}`;
    return new Query(sql);
  }
  /**
   * Builds drop foreign key sql.
   */
  dropForeignKeySql(table, foreignKeyOrName) {
    const foreignKeyName = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName.name : foreignKeyOrName;
    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \`${foreignKeyName}\``);
  }
  /**
   * Escapes a given comment so it's safe to include in a query.
   */
  escapeComment(comment) {
    if (!comment || comment.length === 0) {
      return `''`;
    }
    comment = comment.replace(/\\/g, "\\\\").replace(/'/g, "''").replace(/\u0000/g, "");
    return `'${comment}'`;
  }
  /**
   * Escapes given table or view path.
   */
  escapePath(target) {
    const {
      database,
      tableName
    } = this.driver.parseTableName(target);
    if (database && database !== this.driver.database) {
      return `\`${database}\`.\`${tableName}\``;
    }
    return `\`${tableName}\``;
  }
  /**
   * Builds a part of query to create/change a column.
   */
  buildCreateColumnSql(column, skipPrimary, skipName = false) {
    let c = "";
    if (skipName) {
      c = this.connection.driver.createFullType(column);
    } else {
      c = `\`${column.name}\` ${this.connection.driver.createFullType(column)}`;
    }
    if (column.asExpression) c += ` AS (${column.asExpression}) ${column.generatedType ? column.generatedType : "VIRTUAL"}`;
    if (column.zerofill) {
      c += " ZEROFILL";
    } else if (column.unsigned) {
      c += " UNSIGNED";
    }
    if (column.enum) c += ` (${column.enum.map((value) => "'" + value + "'").join(", ")})`;
    if (column.charset) c += ` CHARACTER SET "${column.charset}"`;
    if (column.collation) c += ` COLLATE "${column.collation}"`;
    if (!column.isNullable) c += " NOT NULL";
    if (column.isNullable) c += " NULL";
    if (column.isPrimary && !skipPrimary) c += " PRIMARY KEY";
    if (column.isGenerated && column.generationStrategy === "increment")
      c += " AUTO_INCREMENT";
    if (column.comment) c += ` COMMENT ${this.escapeComment(column.comment)}`;
    if (column.default !== void 0 && column.default !== null) c += ` DEFAULT ${column.default}`;
    if (column.onUpdate) c += ` ON UPDATE ${column.onUpdate}`;
    return c;
  }
  /**
   * Checks if column display width is by default.
   */
  isDefaultColumnWidth(table, column, width) {
    if (this.connection.hasMetadata(table.name)) {
      const metadata = this.connection.getMetadata(table.name);
      const columnMetadata = metadata.findColumnWithDatabaseName(column.name);
      if (columnMetadata && columnMetadata.width) return false;
    }
    const defaultWidthForType = this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].width;
    if (defaultWidthForType) {
      const typesWithReducedUnsignedDefault = ["int", "tinyint", "smallint", "mediumint"];
      const needsAdjustment = typesWithReducedUnsignedDefault.indexOf(column.type) !== -1;
      if (column.unsigned && needsAdjustment) {
        return defaultWidthForType - 1 === width;
      } else {
        return defaultWidthForType === width;
      }
    }
    return false;
  }
  /**
   * Change table comment.
   */
  changeTableComment(tableOrName, comment) {
    throw new TypeORMError(`aurora-mysql driver does not support change table comment.`);
  }
};

// ../node_modules/typeorm/browser/driver/aurora-mysql/AuroraMysqlDriver.js
var AuroraMysqlDriver2 = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    this.isReplicated = false;
    this.treeSupport = true;
    this.transactionSupport = "nested";
    this.supportedDataTypes = [
      // numeric types
      "bit",
      "int",
      "integer",
      // synonym for int
      "tinyint",
      "smallint",
      "mediumint",
      "bigint",
      "float",
      "double",
      "double precision",
      // synonym for double
      "real",
      // synonym for double
      "decimal",
      "dec",
      // synonym for decimal
      "numeric",
      // synonym for decimal
      "fixed",
      // synonym for decimal
      "bool",
      // synonym for tinyint
      "boolean",
      // synonym for tinyint
      // date and time types
      "date",
      "datetime",
      "timestamp",
      "time",
      "year",
      // string types
      "char",
      "nchar",
      // synonym for national char
      "national char",
      "varchar",
      "nvarchar",
      // synonym for national varchar
      "national varchar",
      "blob",
      "text",
      "tinyblob",
      "tinytext",
      "mediumblob",
      "mediumtext",
      "longblob",
      "longtext",
      "enum",
      "set",
      "binary",
      "varbinary",
      // json data type
      "json",
      // spatial data types
      "geometry",
      "point",
      "linestring",
      "polygon",
      "multipoint",
      "multilinestring",
      "multipolygon",
      "geometrycollection"
    ];
    this.supportedUpsertTypes = ["on-duplicate-key-update"];
    this.spatialTypes = ["geometry", "point", "linestring", "polygon", "multipoint", "multilinestring", "multipolygon", "geometrycollection"];
    this.withLengthColumnTypes = ["char", "varchar", "nvarchar", "binary", "varbinary"];
    this.withWidthColumnTypes = ["bit", "tinyint", "smallint", "mediumint", "int", "integer", "bigint"];
    this.withPrecisionColumnTypes = ["decimal", "dec", "numeric", "fixed", "float", "double", "double precision", "real", "time", "datetime", "timestamp"];
    this.withScaleColumnTypes = ["decimal", "dec", "numeric", "fixed", "float", "double", "double precision", "real"];
    this.unsignedAndZerofillTypes = ["int", "integer", "smallint", "tinyint", "mediumint", "bigint", "decimal", "dec", "numeric", "fixed", "float", "double", "double precision", "real"];
    this.mappedDataTypes = {
      createDate: "datetime",
      createDatePrecision: 6,
      createDateDefault: "CURRENT_TIMESTAMP(6)",
      updateDate: "datetime",
      updateDatePrecision: 6,
      updateDateDefault: "CURRENT_TIMESTAMP(6)",
      deleteDate: "datetime",
      deleteDatePrecision: 6,
      deleteDateNullable: true,
      version: "int",
      treeLevel: "int",
      migrationId: "int",
      migrationName: "varchar",
      migrationTimestamp: "bigint",
      cacheId: "int",
      cacheIdentifier: "varchar",
      cacheTime: "bigint",
      cacheDuration: "int",
      cacheQuery: "text",
      cacheResult: "text",
      metadataType: "varchar",
      metadataDatabase: "varchar",
      metadataSchema: "varchar",
      metadataTable: "varchar",
      metadataName: "varchar",
      metadataValue: "text"
    };
    this.dataTypeDefaults = {
      varchar: {
        length: 255
      },
      nvarchar: {
        length: 255
      },
      "national varchar": {
        length: 255
      },
      char: {
        length: 1
      },
      binary: {
        length: 1
      },
      varbinary: {
        length: 255
      },
      decimal: {
        precision: 10,
        scale: 0
      },
      dec: {
        precision: 10,
        scale: 0
      },
      numeric: {
        precision: 10,
        scale: 0
      },
      fixed: {
        precision: 10,
        scale: 0
      },
      float: {
        precision: 12
      },
      double: {
        precision: 22
      },
      time: {
        precision: 0
      },
      datetime: {
        precision: 0
      },
      timestamp: {
        precision: 0
      },
      bit: {
        width: 1
      },
      int: {
        width: 11
      },
      integer: {
        width: 11
      },
      tinyint: {
        width: 4
      },
      smallint: {
        width: 6
      },
      mediumint: {
        width: 9
      },
      bigint: {
        width: 20
      }
    };
    this.maxAliasLength = 63;
    this.cteCapabilities = {
      enabled: false
    };
    this.connection = connection;
    this.options = connection.options;
    this.loadDependencies();
    this.client = new this.DataApiDriver(this.options.region, this.options.secretArn, this.options.resourceArn, this.options.database, (query, parameters) => this.connection.logger.logQuery(query, parameters), this.options.serviceConfigOptions, this.options.formatOptions);
    this.database = DriverUtils.buildDriverOptions(this.options).database;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Performs connection to the database.
   */
  connect() {
    return __async(this, null, function* () {
      if (!this.database) {
        const queryRunner = yield this.createQueryRunner("master");
        this.database = yield queryRunner.getCurrentDatabase();
        yield queryRunner.release();
      }
    });
  }
  /**
   * Makes any action after connection (e.g. create extensions in Postgres driver).
   */
  afterConnect() {
    return Promise.resolve();
  }
  /**
   * Closes connection with the database.
   */
  disconnect() {
    return __async(this, null, function* () {
    });
  }
  /**
   * Creates a schema builder used to build and sync a schema.
   */
  createSchemaBuilder() {
    return new RdbmsSchemaBuilder(this.connection);
  }
  /**
   * Creates a query runner used to execute database queries.
   */
  createQueryRunner(mode) {
    return new AuroraMysqlQueryRunner(this, new this.DataApiDriver(this.options.region, this.options.secretArn, this.options.resourceArn, this.options.database, (query, parameters) => this.connection.logger.logQuery(query, parameters), this.options.serviceConfigOptions, this.options.formatOptions));
  }
  /**
   * Replaces parameters in the given sql with special escaping character
   * and an array of parameter names to be passed to a query.
   */
  escapeQueryWithParameters(sql, parameters, nativeParameters) {
    const escapedParameters = Object.keys(nativeParameters).map((key) => nativeParameters[key]);
    if (!parameters || !Object.keys(parameters).length) return [sql, escapedParameters];
    sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {
      if (!parameters.hasOwnProperty(key)) {
        return full;
      }
      let value = parameters[key];
      if (isArray) {
        return value.map((v) => {
          escapedParameters.push(v);
          return this.createParameter(key, escapedParameters.length - 1);
        }).join(", ");
      }
      if (typeof value === "function") {
        return value();
      }
      escapedParameters.push(value);
      return this.createParameter(key, escapedParameters.length - 1);
    });
    return [sql, escapedParameters];
  }
  /**
   * Escapes a column name.
   */
  escape(columnName) {
    return "`" + columnName + "`";
  }
  /**
   * Build full table name with database name, schema name and table name.
   * E.g. myDB.mySchema.myTable
   */
  buildTableName(tableName, schema, database) {
    let tablePath = [tableName];
    if (database) {
      tablePath.unshift(database);
    }
    return tablePath.join(".");
  }
  /**
   * Parse a target table name or other types and return a normalized table definition.
   */
  parseTableName(target) {
    const driverDatabase = this.database;
    const driverSchema = void 0;
    if (InstanceChecker.isTable(target) || InstanceChecker.isView(target)) {
      const parsed = this.parseTableName(target.name);
      return {
        database: target.database || parsed.database || driverDatabase,
        schema: target.schema || parsed.schema || driverSchema,
        tableName: parsed.tableName
      };
    }
    if (InstanceChecker.isTableForeignKey(target)) {
      const parsed = this.parseTableName(target.referencedTableName);
      return {
        database: target.referencedDatabase || parsed.database || driverDatabase,
        schema: target.referencedSchema || parsed.schema || driverSchema,
        tableName: parsed.tableName
      };
    }
    if (InstanceChecker.isEntityMetadata(target)) {
      return {
        database: target.database || driverDatabase,
        schema: target.schema || driverSchema,
        tableName: target.tableName
      };
    }
    const parts = target.split(".");
    return {
      database: (parts.length > 1 ? parts[0] : void 0) || driverDatabase,
      schema: driverSchema,
      tableName: parts.length > 1 ? parts[1] : parts[0]
    };
  }
  /**
   * Prepares given value to a value to be persisted, based on its column type and metadata.
   */
  preparePersistentValue(value, columnMetadata) {
    if (columnMetadata.transformer) value = ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
    if (!this.options.formatOptions || this.options.formatOptions.castParameters !== false) {
      return this.client.preparePersistentValue(value, columnMetadata);
    }
    if (value === null || value === void 0) return value;
    if (columnMetadata.type === Boolean) {
      return value === true ? 1 : 0;
    } else if (columnMetadata.type === "date") {
      return DateUtils.mixedDateToDateString(value);
    } else if (columnMetadata.type === "time") {
      return DateUtils.mixedDateToTimeString(value);
    } else if (columnMetadata.type === "json") {
      return JSON.stringify(value);
    } else if (columnMetadata.type === "timestamp" || columnMetadata.type === "datetime" || columnMetadata.type === Date) {
      return DateUtils.mixedDateToDate(value);
    } else if (columnMetadata.type === "simple-array" || columnMetadata.type === "set") {
      return DateUtils.simpleArrayToString(value);
    } else if (columnMetadata.type === "simple-json") {
      return DateUtils.simpleJsonToString(value);
    } else if (columnMetadata.type === "enum" || columnMetadata.type === "simple-enum") {
      return "" + value;
    }
    return value;
  }
  /**
   * Prepares given value to a value to be persisted, based on its column type or metadata.
   */
  prepareHydratedValue(value, columnMetadata) {
    if (value === null || value === void 0) return columnMetadata.transformer ? ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
    if (!this.options.formatOptions || this.options.formatOptions.castParameters !== false) {
      return this.client.prepareHydratedValue(value, columnMetadata);
    }
    if (columnMetadata.type === Boolean || columnMetadata.type === "bool" || columnMetadata.type === "boolean") {
      value = value ? true : false;
    } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
      value = DateUtils.normalizeHydratedDate(value);
    } else if (columnMetadata.type === "date") {
      value = DateUtils.mixedDateToDateString(value);
    } else if (columnMetadata.type === "json") {
      value = typeof value === "string" ? JSON.parse(value) : value;
    } else if (columnMetadata.type === "time") {
      value = DateUtils.mixedTimeToString(value);
    } else if (columnMetadata.type === "simple-array" || columnMetadata.type === "set") {
      value = DateUtils.stringToSimpleArray(value);
    } else if (columnMetadata.type === "simple-json") {
      value = DateUtils.stringToSimpleJson(value);
    } else if ((columnMetadata.type === "enum" || columnMetadata.type === "simple-enum") && columnMetadata.enum && !isNaN(value) && columnMetadata.enum.indexOf(parseInt(value)) >= 0) {
      value = parseInt(value);
    } else if (columnMetadata.type === Number) {
      value = !isNaN(+value) ? parseInt(value) : value;
    }
    if (columnMetadata.transformer) value = ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
    return value;
  }
  /**
   * Creates a database type from a given column metadata.
   */
  normalizeType(column) {
    if (column.type === Number || column.type === "integer") {
      return "int";
    } else if (column.type === String) {
      return "varchar";
    } else if (column.type === Date) {
      return "datetime";
    } else if (column.type === Buffer) {
      return "blob";
    } else if (column.type === Boolean) {
      return "tinyint";
    } else if (column.type === "uuid") {
      return "varchar";
    } else if (column.type === "simple-array" || column.type === "simple-json") {
      return "text";
    } else if (column.type === "simple-enum") {
      return "enum";
    } else if (column.type === "double precision" || column.type === "real") {
      return "double";
    } else if (column.type === "dec" || column.type === "numeric" || column.type === "fixed") {
      return "decimal";
    } else if (column.type === "bool" || column.type === "boolean") {
      return "tinyint";
    } else if (column.type === "nvarchar" || column.type === "national varchar") {
      return "varchar";
    } else if (column.type === "nchar" || column.type === "national char") {
      return "char";
    } else {
      return column.type || "";
    }
  }
  /**
   * Normalizes "default" value of the column.
   */
  normalizeDefault(columnMetadata) {
    const defaultValue = columnMetadata.default;
    if (defaultValue === null) {
      return void 0;
    }
    if ((columnMetadata.type === "enum" || columnMetadata.type === "simple-enum") && defaultValue !== void 0) {
      return `'${defaultValue}'`;
    }
    if (columnMetadata.type === "set" && defaultValue !== void 0) {
      return `'${DateUtils.simpleArrayToString(defaultValue)}'`;
    }
    if (typeof defaultValue === "number") {
      return `${defaultValue}`;
    }
    if (typeof defaultValue === "boolean") {
      return defaultValue ? "1" : "0";
    }
    if (typeof defaultValue === "function") {
      return defaultValue();
    }
    if (typeof defaultValue === "string") {
      return `'${defaultValue}'`;
    }
    if (defaultValue === void 0) {
      return void 0;
    }
    return `${defaultValue}`;
  }
  /**
   * Normalizes "isUnique" value of the column.
   */
  normalizeIsUnique(column) {
    return column.entityMetadata.indices.some((idx) => idx.isUnique && idx.columns.length === 1 && idx.columns[0] === column);
  }
  /**
   * Returns default column lengths, which is required on column creation.
   */
  getColumnLength(column) {
    if (column.length) return column.length.toString();
    if (column.generationStrategy === "uuid") return "36";
    switch (column.type) {
      case String:
      case "varchar":
      case "nvarchar":
      case "national varchar":
        return "255";
      case "varbinary":
        return "255";
      default:
        return "";
    }
  }
  /**
   * Creates column type definition including length, precision and scale
   */
  createFullType(column) {
    let type = column.type;
    if (this.getColumnLength(column)) {
      type += `(${this.getColumnLength(column)})`;
    } else if (column.width) {
      type += `(${column.width})`;
    } else if (column.precision !== null && column.precision !== void 0 && column.scale !== null && column.scale !== void 0) {
      type += `(${column.precision},${column.scale})`;
    } else if (column.precision !== null && column.precision !== void 0) {
      type += `(${column.precision})`;
    }
    if (column.isArray) type += " array";
    return type;
  }
  /**
   * Obtains a new database connection to a master server.
   * Used for replication.
   * If replication is not setup then returns default connection's database connection.
   */
  obtainMasterConnection() {
    return new Promise((ok, fail) => {
      if (this.poolCluster) {
        this.poolCluster.getConnection("MASTER", (err, dbConnection) => {
          err ? fail(err) : ok(this.prepareDbConnection(dbConnection));
        });
      } else if (this.pool) {
        this.pool.getConnection((err, dbConnection) => {
          err ? fail(err) : ok(this.prepareDbConnection(dbConnection));
        });
      } else {
        fail(new TypeORMError(`Connection is not established with mysql database`));
      }
    });
  }
  /**
   * Obtains a new database connection to a slave server.
   * Used for replication.
   * If replication is not setup then returns master (default) connection's database connection.
   */
  obtainSlaveConnection() {
    if (!this.poolCluster) return this.obtainMasterConnection();
    return new Promise((ok, fail) => {
      this.poolCluster.getConnection("SLAVE*", (err, dbConnection) => {
        err ? fail(err) : ok(this.prepareDbConnection(dbConnection));
      });
    });
  }
  /**
   * Creates generated map of values generated or returned by database after INSERT query.
   */
  createGeneratedMap(metadata, insertResult, entityIndex) {
    const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {
      let value;
      if (generatedColumn.generationStrategy === "increment" && insertResult.insertId) {
        value = insertResult.insertId + entityIndex;
      }
      return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
    }, {});
    return Object.keys(generatedMap).length > 0 ? generatedMap : void 0;
  }
  /**
   * Differentiate columns of this table and columns from the given column metadatas columns
   * and returns only changed.
   */
  findChangedColumns(tableColumns, columnMetadatas) {
    return columnMetadatas.filter((columnMetadata) => {
      const tableColumn = tableColumns.find((c) => c.name === columnMetadata.databaseName);
      if (!tableColumn) return false;
      let columnMetadataLength = columnMetadata.length;
      if (!columnMetadataLength && columnMetadata.generationStrategy === "uuid") {
        columnMetadataLength = this.getColumnLength(columnMetadata);
      }
      return tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadataLength || tableColumn.width !== columnMetadata.width || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale || tableColumn.zerofill !== columnMetadata.zerofill || tableColumn.unsigned !== columnMetadata.unsigned || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.comment !== this.escapeComment(columnMetadata.comment) || !this.compareDefaultValues(this.normalizeDefault(columnMetadata), tableColumn.default) || tableColumn.enum && columnMetadata.enum && !OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map((val) => val + "")) || tableColumn.onUpdate !== columnMetadata.onUpdate || tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || columnMetadata.generationStrategy !== "uuid" && tableColumn.isGenerated !== columnMetadata.isGenerated;
    });
  }
  /**
   * Returns true if driver supports RETURNING / OUTPUT statement.
   */
  isReturningSqlSupported() {
    return false;
  }
  /**
   * Returns true if driver supports uuid values generation on its own.
   */
  isUUIDGenerationSupported() {
    return false;
  }
  /**
   * Returns true if driver supports fulltext indices.
   */
  isFullTextColumnTypeSupported() {
    return true;
  }
  /**
   * Creates an escaped parameter.
   */
  createParameter(parameterName, index) {
    return "?";
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Loads all driver dependencies.
   */
  loadDependencies() {
    const DataApiDriver = this.options.driver || PlatformTools.load("typeorm-aurora-data-api-driver");
    this.DataApiDriver = DataApiDriver;
    this.DataApiDriver = this.DataApiDriver.default || this.DataApiDriver;
  }
  /**
   * Creates a new connection pool for a given database credentials.
   */
  createConnectionOptions(options, credentials) {
    credentials = Object.assign({}, credentials, DriverUtils.buildDriverOptions(credentials));
    return Object.assign({}, {
      resourceArn: options.resourceArn,
      secretArn: options.secretArn,
      database: options.database,
      region: options.region,
      type: options.type
    }, {
      host: credentials.host,
      user: credentials.username,
      password: credentials.password,
      database: credentials.database,
      port: credentials.port,
      ssl: options.ssl
    }, options.extra || {});
  }
  /**
   * Creates a new connection pool for a given database credentials.
   */
  createPool(connectionOptions) {
    return __async(this, null, function* () {
      return {};
    });
  }
  /**
   * Attaches all required base handlers to a database connection, such as the unhandled error handler.
   */
  prepareDbConnection(connection) {
    const {
      logger
    } = this.connection;
    if (connection.listeners("error").length === 0) {
      connection.on("error", (error) => logger.log("warn", `MySQL connection raised an error. ${error}`));
    }
    return connection;
  }
  /**
   * Checks if "DEFAULT" values in the column metadata and in the database are equal.
   */
  compareDefaultValues(columnMetadataValue, databaseValue) {
    if (typeof columnMetadataValue === "string" && typeof databaseValue === "string") {
      columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, "");
      databaseValue = databaseValue.replace(/^'+|'+$/g, "");
    }
    return columnMetadataValue === databaseValue;
  }
  /**
   * Escapes a given comment.
   */
  escapeComment(comment) {
    if (!comment) return comment;
    comment = comment.replace(/\u0000/g, "");
    return comment;
  }
};

// ../node_modules/typeorm/browser/driver/postgres/PostgresQueryRunner.js
var PostgresQueryRunner = class extends BaseQueryRunner {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(driver, mode) {
    super();
    this.driver = driver;
    this.connection = driver.connection;
    this.mode = mode;
    this.broadcaster = new Broadcaster(this);
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates/uses database connection from the connection pool to perform further operations.
   * Returns obtained database connection.
   */
  connect() {
    if (this.databaseConnection) return Promise.resolve(this.databaseConnection);
    if (this.databaseConnectionPromise) return this.databaseConnectionPromise;
    if (this.mode === "slave" && this.driver.isReplicated) {
      this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then(([connection, release]) => {
        this.driver.connectedQueryRunners.push(this);
        this.databaseConnection = connection;
        const onErrorCallback = (err) => this.releasePostgresConnection(err);
        this.releaseCallback = (err) => {
          this.databaseConnection.removeListener("error", onErrorCallback);
          release(err);
        };
        this.databaseConnection.on("error", onErrorCallback);
        return this.databaseConnection;
      });
    } else {
      this.databaseConnectionPromise = this.driver.obtainMasterConnection().then(([connection, release]) => {
        this.driver.connectedQueryRunners.push(this);
        this.databaseConnection = connection;
        const onErrorCallback = (err) => this.releasePostgresConnection(err);
        this.releaseCallback = (err) => {
          this.databaseConnection.removeListener("error", onErrorCallback);
          release(err);
        };
        this.databaseConnection.on("error", onErrorCallback);
        return this.databaseConnection;
      });
    }
    return this.databaseConnectionPromise;
  }
  /**
   * Release a connection back to the pool, optionally specifying an Error to release with.
   * Per pg-pool documentation this will prevent the pool from re-using the broken connection.
   */
  releasePostgresConnection(err) {
    return __async(this, null, function* () {
      if (this.isReleased) {
        return;
      }
      this.isReleased = true;
      if (this.releaseCallback) {
        this.releaseCallback(err);
        this.releaseCallback = void 0;
      }
      const index = this.driver.connectedQueryRunners.indexOf(this);
      if (index !== -1) {
        this.driver.connectedQueryRunners.splice(index, 1);
      }
    });
  }
  /**
   * Releases used database connection.
   * You cannot use query runner methods once its released.
   */
  release() {
    return this.releasePostgresConnection();
  }
  /**
   * Starts transaction.
   */
  startTransaction(isolationLevel) {
    return __async(this, null, function* () {
      this.isTransactionActive = true;
      try {
        yield this.broadcaster.broadcast("BeforeTransactionStart");
      } catch (err) {
        this.isTransactionActive = false;
        throw err;
      }
      if (this.transactionDepth === 0) {
        this.transactionDepth += 1;
        yield this.query("START TRANSACTION");
        if (isolationLevel) {
          yield this.query("SET TRANSACTION ISOLATION LEVEL " + isolationLevel);
        }
      } else {
        this.transactionDepth += 1;
        yield this.query(`SAVEPOINT typeorm_${this.transactionDepth - 1}`);
      }
      yield this.broadcaster.broadcast("AfterTransactionStart");
    });
  }
  /**
   * Commits transaction.
   * Error will be thrown if transaction was not started.
   */
  commitTransaction() {
    return __async(this, null, function* () {
      if (!this.isTransactionActive) throw new TransactionNotStartedError();
      yield this.broadcaster.broadcast("BeforeTransactionCommit");
      if (this.transactionDepth > 1) {
        this.transactionDepth -= 1;
        yield this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth}`);
      } else {
        this.transactionDepth -= 1;
        yield this.query("COMMIT");
        this.isTransactionActive = false;
      }
      yield this.broadcaster.broadcast("AfterTransactionCommit");
    });
  }
  /**
   * Rollbacks transaction.
   * Error will be thrown if transaction was not started.
   */
  rollbackTransaction() {
    return __async(this, null, function* () {
      if (!this.isTransactionActive) throw new TransactionNotStartedError();
      yield this.broadcaster.broadcast("BeforeTransactionRollback");
      if (this.transactionDepth > 1) {
        this.transactionDepth -= 1;
        yield this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth}`);
      } else {
        this.transactionDepth -= 1;
        yield this.query("ROLLBACK");
        this.isTransactionActive = false;
      }
      yield this.broadcaster.broadcast("AfterTransactionRollback");
    });
  }
  /**
   * Executes a given SQL query.
   */
  query(query, parameters, useStructuredResult = false) {
    return __async(this, null, function* () {
      if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();
      const databaseConnection = yield this.connect();
      const broadcasterResult = new BroadcasterResult();
      this.driver.connection.logger.logQuery(query, parameters, this);
      this.broadcaster.broadcastBeforeQueryEvent(broadcasterResult, query, parameters);
      try {
        const queryStartTime = +/* @__PURE__ */ new Date();
        const raw = yield databaseConnection.query(query, parameters);
        const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
        const queryEndTime = +/* @__PURE__ */ new Date();
        const queryExecutionTime = queryEndTime - queryStartTime;
        this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, void 0);
        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
        const result = new QueryResult();
        if (raw) {
          if (raw.hasOwnProperty("rows")) {
            result.records = raw.rows;
          }
          if (raw.hasOwnProperty("rowCount")) {
            result.affected = raw.rowCount;
          }
          switch (raw.command) {
            case "DELETE":
            case "UPDATE":
              result.raw = [raw.rows, raw.rowCount];
              break;
            default:
              result.raw = raw.rows;
          }
          if (!useStructuredResult) {
            return result.raw;
          }
        }
        return result;
      } catch (err) {
        this.driver.connection.logger.logQueryError(err, query, parameters, this);
        this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
        throw new QueryFailedError(query, parameters, err);
      } finally {
        yield broadcasterResult.wait();
      }
    });
  }
  /**
   * Returns raw data stream.
   */
  stream(query, parameters, onEnd, onError) {
    return __async(this, null, function* () {
      const QueryStream = this.driver.loadStreamDependency();
      if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();
      const databaseConnection = yield this.connect();
      this.driver.connection.logger.logQuery(query, parameters, this);
      const stream = databaseConnection.query(new QueryStream(query, parameters));
      if (onEnd) stream.on("end", onEnd);
      if (onError) stream.on("error", onError);
      return stream;
    });
  }
  /**
   * Returns all available database names including system databases.
   */
  getDatabases() {
    return __async(this, null, function* () {
      return Promise.resolve([]);
    });
  }
  /**
   * Returns all available schema names including system schemas.
   * If database parameter specified, returns schemas of that database.
   */
  getSchemas(database) {
    return __async(this, null, function* () {
      return Promise.resolve([]);
    });
  }
  /**
   * Checks if database with the given name exist.
   */
  hasDatabase(database) {
    return __async(this, null, function* () {
      const result = yield this.query(`SELECT * FROM pg_database WHERE datname='${database}';`);
      return result.length ? true : false;
    });
  }
  /**
   * Loads currently using database
   */
  getCurrentDatabase() {
    return __async(this, null, function* () {
      const query = yield this.query(`SELECT * FROM current_database()`);
      return query[0]["current_database"];
    });
  }
  /**
   * Checks if schema with the given name exist.
   */
  hasSchema(schema) {
    return __async(this, null, function* () {
      const result = yield this.query(`SELECT * FROM "information_schema"."schemata" WHERE "schema_name" = '${schema}'`);
      return result.length ? true : false;
    });
  }
  /**
   * Loads currently using database schema
   */
  getCurrentSchema() {
    return __async(this, null, function* () {
      const query = yield this.query(`SELECT * FROM current_schema()`);
      return query[0]["current_schema"];
    });
  }
  /**
   * Checks if table with the given name exist in the database.
   */
  hasTable(tableOrName) {
    return __async(this, null, function* () {
      const parsedTableName = this.driver.parseTableName(tableOrName);
      if (!parsedTableName.schema) {
        parsedTableName.schema = yield this.getCurrentSchema();
      }
      const sql = `SELECT * FROM "information_schema"."tables" WHERE "table_schema" = '${parsedTableName.schema}' AND "table_name" = '${parsedTableName.tableName}'`;
      const result = yield this.query(sql);
      return result.length ? true : false;
    });
  }
  /**
   * Checks if column with the given name exist in the given table.
   */
  hasColumn(tableOrName, columnName) {
    return __async(this, null, function* () {
      const parsedTableName = this.driver.parseTableName(tableOrName);
      if (!parsedTableName.schema) {
        parsedTableName.schema = yield this.getCurrentSchema();
      }
      const sql = `SELECT * FROM "information_schema"."columns" WHERE "table_schema" = '${parsedTableName.schema}' AND "table_name" = '${parsedTableName.tableName}' AND "column_name" = '${columnName}'`;
      const result = yield this.query(sql);
      return result.length ? true : false;
    });
  }
  /**
   * Creates a new database.
   * Note: Postgres does not support database creation inside a transaction block.
   */
  createDatabase(database, ifNotExist) {
    return __async(this, null, function* () {
      if (ifNotExist) {
        const databaseAlreadyExists = yield this.hasDatabase(database);
        if (databaseAlreadyExists) return Promise.resolve();
      }
      const up = `CREATE DATABASE "${database}"`;
      const down = `DROP DATABASE "${database}"`;
      yield this.executeQueries(new Query(up), new Query(down));
    });
  }
  /**
   * Drops database.
   * Note: Postgres does not support database dropping inside a transaction block.
   */
  dropDatabase(database, ifExist) {
    return __async(this, null, function* () {
      const up = ifExist ? `DROP DATABASE IF EXISTS "${database}"` : `DROP DATABASE "${database}"`;
      const down = `CREATE DATABASE "${database}"`;
      yield this.executeQueries(new Query(up), new Query(down));
    });
  }
  /**
   * Creates a new table schema.
   */
  createSchema(schemaPath, ifNotExist) {
    return __async(this, null, function* () {
      const schema = schemaPath.indexOf(".") === -1 ? schemaPath : schemaPath.split(".")[1];
      const up = ifNotExist ? `CREATE SCHEMA IF NOT EXISTS "${schema}"` : `CREATE SCHEMA "${schema}"`;
      const down = `DROP SCHEMA "${schema}" CASCADE`;
      yield this.executeQueries(new Query(up), new Query(down));
    });
  }
  /**
   * Drops table schema.
   */
  dropSchema(schemaPath, ifExist, isCascade) {
    return __async(this, null, function* () {
      const schema = schemaPath.indexOf(".") === -1 ? schemaPath : schemaPath.split(".")[1];
      const up = ifExist ? `DROP SCHEMA IF EXISTS "${schema}" ${isCascade ? "CASCADE" : ""}` : `DROP SCHEMA "${schema}" ${isCascade ? "CASCADE" : ""}`;
      const down = `CREATE SCHEMA "${schema}"`;
      yield this.executeQueries(new Query(up), new Query(down));
    });
  }
  /**
   * Creates a new table.
   */
  createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {
    return __async(this, null, function* () {
      if (ifNotExist) {
        const isTableExist = yield this.hasTable(table);
        if (isTableExist) return Promise.resolve();
      }
      const upQueries = [];
      const downQueries = [];
      const enumColumns = table.columns.filter((column) => column.type === "enum" || column.type === "simple-enum");
      const createdEnumTypes = [];
      for (const column of enumColumns) {
        const hasEnum = yield this.hasEnumType(table, column);
        const enumName = this.buildEnumName(table, column);
        if (!hasEnum && createdEnumTypes.indexOf(enumName) === -1) {
          createdEnumTypes.push(enumName);
          upQueries.push(this.createEnumTypeSql(table, column, enumName));
          downQueries.push(this.dropEnumTypeSql(table, column, enumName));
        }
      }
      const generatedColumns = table.columns.filter((column) => column.generatedType === "STORED" && column.asExpression);
      for (const column of generatedColumns) {
        const tableNameWithSchema = (yield this.getTableNameWithSchema(table.name)).split(".");
        const tableName = tableNameWithSchema[1];
        const schema = tableNameWithSchema[0];
        const insertQuery = this.insertTypeormMetadataSql({
          database: this.driver.database,
          schema,
          table: tableName,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name,
          value: column.asExpression
        });
        const deleteQuery = this.deleteTypeormMetadataSql({
          database: this.driver.database,
          schema,
          table: tableName,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name
        });
        upQueries.push(insertQuery);
        downQueries.push(deleteQuery);
      }
      upQueries.push(this.createTableSql(table, createForeignKeys));
      downQueries.push(this.dropTableSql(table));
      if (createForeignKeys) table.foreignKeys.forEach((foreignKey) => downQueries.push(this.dropForeignKeySql(table, foreignKey)));
      if (createIndices) {
        table.indices.forEach((index) => {
          if (!index.name) index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
          upQueries.push(this.createIndexSql(table, index));
          downQueries.push(this.dropIndexSql(table, index));
        });
      }
      if (table.comment) {
        upQueries.push(new Query("COMMENT ON TABLE " + this.escapePath(table) + " IS '" + table.comment + "'"));
        downQueries.push(new Query("COMMENT ON TABLE " + this.escapePath(table) + " IS NULL"));
      }
      yield this.executeQueries(upQueries, downQueries);
    });
  }
  /**
   * Drops the table.
   */
  dropTable(target, ifExist, dropForeignKeys = true, dropIndices = true) {
    return __async(this, null, function* () {
      if (ifExist) {
        const isTableExist = yield this.hasTable(target);
        if (!isTableExist) return Promise.resolve();
      }
      const createForeignKeys = dropForeignKeys;
      const tablePath = this.getTablePath(target);
      const table = yield this.getCachedTable(tablePath);
      const upQueries = [];
      const downQueries = [];
      if (dropIndices) {
        table.indices.forEach((index) => {
          upQueries.push(this.dropIndexSql(table, index));
          downQueries.push(this.createIndexSql(table, index));
        });
      }
      if (dropForeignKeys) table.foreignKeys.forEach((foreignKey) => upQueries.push(this.dropForeignKeySql(table, foreignKey)));
      upQueries.push(this.dropTableSql(table));
      downQueries.push(this.createTableSql(table, createForeignKeys));
      const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
      for (const column of generatedColumns) {
        const tableNameWithSchema = (yield this.getTableNameWithSchema(table.name)).split(".");
        const tableName = tableNameWithSchema[1];
        const schema = tableNameWithSchema[0];
        const deleteQuery = this.deleteTypeormMetadataSql({
          database: this.driver.database,
          schema,
          table: tableName,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name
        });
        const insertQuery = this.insertTypeormMetadataSql({
          database: this.driver.database,
          schema,
          table: tableName,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name,
          value: column.asExpression
        });
        upQueries.push(deleteQuery);
        downQueries.push(insertQuery);
      }
      yield this.executeQueries(upQueries, downQueries);
    });
  }
  /**
   * Creates a new view.
   */
  createView(view, syncWithMetadata = false) {
    return __async(this, null, function* () {
      const upQueries = [];
      const downQueries = [];
      upQueries.push(this.createViewSql(view));
      if (syncWithMetadata) upQueries.push(yield this.insertViewDefinitionSql(view));
      downQueries.push(this.dropViewSql(view));
      if (syncWithMetadata) downQueries.push(yield this.deleteViewDefinitionSql(view));
      yield this.executeQueries(upQueries, downQueries);
    });
  }
  /**
   * Drops the view.
   */
  dropView(target) {
    return __async(this, null, function* () {
      const viewName = InstanceChecker.isView(target) ? target.name : target;
      const view = yield this.getCachedView(viewName);
      const upQueries = [];
      const downQueries = [];
      upQueries.push(yield this.deleteViewDefinitionSql(view));
      upQueries.push(this.dropViewSql(view));
      downQueries.push(yield this.insertViewDefinitionSql(view));
      downQueries.push(this.createViewSql(view));
      yield this.executeQueries(upQueries, downQueries);
    });
  }
  /**
   * Renames the given table.
   */
  renameTable(oldTableOrName, newTableName) {
    return __async(this, null, function* () {
      const upQueries = [];
      const downQueries = [];
      const oldTable = InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : yield this.getCachedTable(oldTableOrName);
      const newTable = oldTable.clone();
      const {
        schema: schemaName,
        tableName: oldTableName
      } = this.driver.parseTableName(oldTable);
      newTable.name = schemaName ? `${schemaName}.${newTableName}` : newTableName;
      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(oldTable)} RENAME TO "${newTableName}"`));
      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME TO "${oldTableName}"`));
      if (newTable.primaryColumns.length > 0 && !newTable.primaryColumns[0].primaryKeyConstraintName) {
        const columnNames = newTable.primaryColumns.map((column) => column.name);
        const oldPkName = this.connection.namingStrategy.primaryKeyName(oldTable, columnNames);
        const newPkName = this.connection.namingStrategy.primaryKeyName(newTable, columnNames);
        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${oldPkName}" TO "${newPkName}"`));
        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newPkName}" TO "${oldPkName}"`));
      }
      newTable.columns.map((col) => {
        if (col.isGenerated && col.generationStrategy === "increment") {
          const sequencePath = this.buildSequencePath(oldTable, col.name);
          const sequenceName = this.buildSequenceName(oldTable, col.name);
          const newSequencePath = this.buildSequencePath(newTable, col.name);
          const newSequenceName = this.buildSequenceName(newTable, col.name);
          const up = `ALTER SEQUENCE ${this.escapePath(sequencePath)} RENAME TO "${newSequenceName}"`;
          const down = `ALTER SEQUENCE ${this.escapePath(newSequencePath)} RENAME TO "${sequenceName}"`;
          upQueries.push(new Query(up));
          downQueries.push(new Query(down));
        }
      });
      newTable.uniques.forEach((unique) => {
        const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames);
        if (unique.name !== oldUniqueName) return;
        const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);
        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${unique.name}" TO "${newUniqueName}"`));
        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newUniqueName}" TO "${unique.name}"`));
        unique.name = newUniqueName;
      });
      newTable.indices.forEach((index) => {
        const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where);
        if (index.name !== oldIndexName) return;
        const {
          schema
        } = this.driver.parseTableName(newTable);
        const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
        const up = schema ? `ALTER INDEX "${schema}"."${index.name}" RENAME TO "${newIndexName}"` : `ALTER INDEX "${index.name}" RENAME TO "${newIndexName}"`;
        const down = schema ? `ALTER INDEX "${schema}"."${newIndexName}" RENAME TO "${index.name}"` : `ALTER INDEX "${newIndexName}" RENAME TO "${index.name}"`;
        upQueries.push(new Query(up));
        downQueries.push(new Query(down));
        index.name = newIndexName;
      });
      newTable.foreignKeys.forEach((foreignKey) => {
        const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
        if (foreignKey.name !== oldForeignKeyName) return;
        const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${foreignKey.name}" TO "${newForeignKeyName}"`));
        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newForeignKeyName}" TO "${foreignKey.name}"`));
        foreignKey.name = newForeignKeyName;
      });
      const enumColumns = newTable.columns.filter((column) => column.type === "enum" || column.type === "simple-enum");
      for (let column of enumColumns) {
        if (column.enumName) continue;
        const oldEnumType = yield this.getUserDefinedTypeName(oldTable, column);
        upQueries.push(new Query(`ALTER TYPE "${oldEnumType.schema}"."${oldEnumType.name}" RENAME TO ${this.buildEnumName(newTable, column, false)}`));
        downQueries.push(new Query(`ALTER TYPE ${this.buildEnumName(newTable, column)} RENAME TO "${oldEnumType.name}"`));
      }
      yield this.executeQueries(upQueries, downQueries);
    });
  }
  /**
   * Creates a new column from the column in the table.
   */
  addColumn(tableOrName, column) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const clonedTable = table.clone();
      const upQueries = [];
      const downQueries = [];
      if (column.type === "enum" || column.type === "simple-enum") {
        const hasEnum = yield this.hasEnumType(table, column);
        if (!hasEnum) {
          upQueries.push(this.createEnumTypeSql(table, column));
          downQueries.push(this.dropEnumTypeSql(table, column));
        }
      }
      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column)}`));
      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${column.name}"`));
      if (column.isPrimary) {
        const primaryColumns = clonedTable.primaryColumns;
        if (primaryColumns.length > 0) {
          const pkName2 = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
          const columnNames2 = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName2}"`));
          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNames2})`));
        }
        primaryColumns.push(column);
        const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
        const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
      }
      const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
      if (columnIndex) {
        upQueries.push(this.createIndexSql(table, columnIndex));
        downQueries.push(this.dropIndexSql(table, columnIndex));
      }
      if (column.isUnique) {
        const uniqueConstraint = new TableUnique({
          name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
          columnNames: [column.name]
        });
        clonedTable.uniques.push(uniqueConstraint);
        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${column.name}")`));
        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
      }
      if (column.generatedType === "STORED" && column.asExpression) {
        const tableNameWithSchema = (yield this.getTableNameWithSchema(table.name)).split(".");
        const tableName = tableNameWithSchema[1];
        const schema = tableNameWithSchema[0];
        const insertQuery = this.insertTypeormMetadataSql({
          database: this.driver.database,
          schema,
          table: tableName,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name,
          value: column.asExpression
        });
        const deleteQuery = this.deleteTypeormMetadataSql({
          database: this.driver.database,
          schema,
          table: tableName,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name
        });
        upQueries.push(insertQuery);
        downQueries.push(deleteQuery);
      }
      if (column.comment) {
        upQueries.push(new Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${column.name}" IS ${this.escapeComment(column.comment)}`));
        downQueries.push(new Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${column.name}" IS ${this.escapeComment(column.comment)}`));
      }
      yield this.executeQueries(upQueries, downQueries);
      clonedTable.addColumn(column);
      this.replaceCachedTable(table, clonedTable);
    });
  }
  /**
   * Creates a new columns from the column in the table.
   */
  addColumns(tableOrName, columns) {
    return __async(this, null, function* () {
      for (const column of columns) {
        yield this.addColumn(tableOrName, column);
      }
    });
  }
  /**
   * Renames column in the given table.
   */
  renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c) => c.name === oldTableColumnOrName);
      if (!oldColumn) throw new TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
      let newColumn;
      if (InstanceChecker.isTableColumn(newTableColumnOrName)) {
        newColumn = newTableColumnOrName;
      } else {
        newColumn = oldColumn.clone();
        newColumn.name = newTableColumnOrName;
      }
      return this.changeColumn(table, oldColumn, newColumn);
    });
  }
  /**
   * Changes a column in the table.
   */
  changeColumn(tableOrName, oldTableColumnOrName, newColumn) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      let clonedTable = table.clone();
      const upQueries = [];
      const downQueries = [];
      let defaultValueChanged = false;
      const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((column) => column.name === oldTableColumnOrName);
      if (!oldColumn) throw new TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
      if (oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || newColumn.isArray !== oldColumn.isArray || !oldColumn.generatedType && newColumn.generatedType === "STORED" || oldColumn.asExpression !== newColumn.asExpression && newColumn.generatedType === "STORED") {
        yield this.dropColumn(table, oldColumn);
        yield this.addColumn(table, newColumn);
        clonedTable = table.clone();
      } else {
        if (oldColumn.name !== newColumn.name) {
          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN "${oldColumn.name}" TO "${newColumn.name}"`));
          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN "${newColumn.name}" TO "${oldColumn.name}"`));
          if (oldColumn.type === "enum" || oldColumn.type === "simple-enum") {
            const oldEnumType = yield this.getUserDefinedTypeName(table, oldColumn);
            upQueries.push(new Query(`ALTER TYPE "${oldEnumType.schema}"."${oldEnumType.name}" RENAME TO ${this.buildEnumName(table, newColumn, false)}`));
            downQueries.push(new Query(`ALTER TYPE ${this.buildEnumName(table, newColumn)} RENAME TO "${oldEnumType.name}"`));
          }
          if (oldColumn.isPrimary === true && !oldColumn.primaryKeyConstraintName) {
            const primaryColumns = clonedTable.primaryColumns;
            const columnNames = primaryColumns.map((column) => column.name);
            const oldPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
            columnNames.splice(columnNames.indexOf(oldColumn.name), 1);
            columnNames.push(newColumn.name);
            const newPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${oldPkName}" TO "${newPkName}"`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newPkName}" TO "${oldPkName}"`));
          }
          if (oldColumn.isGenerated === true && newColumn.generationStrategy === "increment") {
            const sequencePath = this.buildSequencePath(table, oldColumn.name);
            const sequenceName = this.buildSequenceName(table, oldColumn.name);
            const newSequencePath = this.buildSequencePath(table, newColumn.name);
            const newSequenceName = this.buildSequenceName(table, newColumn.name);
            const up = `ALTER SEQUENCE ${this.escapePath(sequencePath)} RENAME TO "${newSequenceName}"`;
            const down = `ALTER SEQUENCE ${this.escapePath(newSequencePath)} RENAME TO "${sequenceName}"`;
            upQueries.push(new Query(up));
            downQueries.push(new Query(down));
          }
          clonedTable.findColumnUniques(oldColumn).forEach((unique) => {
            const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);
            if (unique.name !== oldUniqueName) return;
            unique.columnNames.splice(unique.columnNames.indexOf(oldColumn.name), 1);
            unique.columnNames.push(newColumn.name);
            const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${unique.name}" TO "${newUniqueName}"`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newUniqueName}" TO "${unique.name}"`));
            unique.name = newUniqueName;
          });
          clonedTable.findColumnIndices(oldColumn).forEach((index) => {
            const oldIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
            if (index.name !== oldIndexName) return;
            index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);
            index.columnNames.push(newColumn.name);
            const {
              schema
            } = this.driver.parseTableName(table);
            const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
            const up = schema ? `ALTER INDEX "${schema}"."${index.name}" RENAME TO "${newIndexName}"` : `ALTER INDEX "${index.name}" RENAME TO "${newIndexName}"`;
            const down = schema ? `ALTER INDEX "${schema}"."${newIndexName}" RENAME TO "${index.name}"` : `ALTER INDEX "${newIndexName}" RENAME TO "${index.name}"`;
            upQueries.push(new Query(up));
            downQueries.push(new Query(down));
            index.name = newIndexName;
          });
          clonedTable.findColumnForeignKeys(oldColumn).forEach((foreignKey) => {
            const foreignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
            if (foreignKey.name !== foreignKeyName) return;
            foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);
            foreignKey.columnNames.push(newColumn.name);
            const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${foreignKey.name}" TO "${newForeignKeyName}"`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newForeignKeyName}" TO "${foreignKey.name}"`));
            foreignKey.name = newForeignKeyName;
          });
          const oldTableColumn = clonedTable.columns.find((column) => column.name === oldColumn.name);
          clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;
          oldColumn.name = newColumn.name;
        }
        if (newColumn.precision !== oldColumn.precision || newColumn.scale !== oldColumn.scale) {
          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(newColumn)}`));
          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(oldColumn)}`));
        }
        if ((newColumn.type === "enum" || newColumn.type === "simple-enum") && (oldColumn.type === "enum" || oldColumn.type === "simple-enum") && (!OrmUtils.isArraysEqual(newColumn.enum, oldColumn.enum) || newColumn.enumName !== oldColumn.enumName)) {
          const arraySuffix = newColumn.isArray ? "[]" : "";
          const newEnumName = this.buildEnumName(table, newColumn);
          const oldEnumName = this.buildEnumName(table, oldColumn);
          const oldEnumNameWithoutSchema = this.buildEnumName(table, oldColumn, false);
          const oldEnumNameWithSchema_old = this.buildEnumName(table, oldColumn, true, false, true);
          const oldEnumNameWithoutSchema_old = this.buildEnumName(table, oldColumn, false, false, true);
          upQueries.push(new Query(`ALTER TYPE ${oldEnumName} RENAME TO ${oldEnumNameWithoutSchema_old}`));
          downQueries.push(new Query(`ALTER TYPE ${oldEnumNameWithSchema_old} RENAME TO ${oldEnumNameWithoutSchema}`));
          upQueries.push(this.createEnumTypeSql(table, newColumn, newEnumName));
          downQueries.push(this.dropEnumTypeSql(table, newColumn, newEnumName));
          if (oldColumn.default !== null && oldColumn.default !== void 0) {
            defaultValueChanged = true;
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP DEFAULT`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET DEFAULT ${oldColumn.default}`));
          }
          const upType = `${newEnumName}${arraySuffix} USING "${newColumn.name}"::"text"::${newEnumName}${arraySuffix}`;
          const downType = `${oldEnumNameWithSchema_old}${arraySuffix} USING "${newColumn.name}"::"text"::${oldEnumNameWithSchema_old}${arraySuffix}`;
          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${upType}`));
          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${downType}`));
          if (newColumn.default !== null && newColumn.default !== void 0) {
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${newColumn.default}`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
          }
          upQueries.push(this.dropEnumTypeSql(table, oldColumn, oldEnumNameWithSchema_old));
          downQueries.push(this.createEnumTypeSql(table, oldColumn, oldEnumNameWithSchema_old));
        }
        if (oldColumn.isNullable !== newColumn.isNullable) {
          if (newColumn.isNullable) {
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP NOT NULL`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET NOT NULL`));
          } else {
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET NOT NULL`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP NOT NULL`));
          }
        }
        if (oldColumn.comment !== newColumn.comment) {
          upQueries.push(new Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${oldColumn.name}" IS ${this.escapeComment(newColumn.comment)}`));
          downQueries.push(new Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${newColumn.name}" IS ${this.escapeComment(oldColumn.comment)}`));
        }
        if (newColumn.isPrimary !== oldColumn.isPrimary) {
          const primaryColumns = clonedTable.primaryColumns;
          if (primaryColumns.length > 0) {
            const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
            const columnNames = primaryColumns.map((column) => `"${column.name}"`).join(", ");
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
          }
          if (newColumn.isPrimary === true) {
            primaryColumns.push(newColumn);
            const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
            column.isPrimary = true;
            const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
            const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
          } else {
            const primaryColumn = primaryColumns.find((c) => c.name === newColumn.name);
            primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1);
            const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
            column.isPrimary = false;
            if (primaryColumns.length > 0) {
              const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
              const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
              upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
              downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
            }
          }
        }
        if (newColumn.isUnique !== oldColumn.isUnique) {
          if (newColumn.isUnique === true) {
            const uniqueConstraint = new TableUnique({
              name: this.connection.namingStrategy.uniqueConstraintName(table, [newColumn.name]),
              columnNames: [newColumn.name]
            });
            clonedTable.uniques.push(uniqueConstraint);
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${newColumn.name}")`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
          } else {
            const uniqueConstraint = clonedTable.uniques.find((unique) => {
              return unique.columnNames.length === 1 && !!unique.columnNames.find((columnName) => columnName === newColumn.name);
            });
            clonedTable.uniques.splice(clonedTable.uniques.indexOf(uniqueConstraint), 1);
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${newColumn.name}")`));
          }
        }
        if (oldColumn.isGenerated !== newColumn.isGenerated) {
          if (oldColumn.isGenerated) {
            if (oldColumn.generationStrategy === "uuid") {
              upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP DEFAULT`));
              downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET DEFAULT ${this.driver.uuidGenerator}`));
            } else if (oldColumn.generationStrategy === "increment") {
              upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
              downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));
              upQueries.push(new Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));
              downQueries.push(new Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}."${newColumn.name}"`));
            }
          }
          if (newColumn.generationStrategy === "uuid") {
            if (newColumn.isGenerated === true) {
              upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${this.driver.uuidGenerator}`));
              downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
            } else {
              upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
              downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${this.driver.uuidGenerator}`));
            }
          } else if (newColumn.generationStrategy === "increment") {
            if (newColumn.isGenerated === true) {
              upQueries.push(new Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}."${newColumn.name}"`));
              downQueries.push(new Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));
              upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));
              downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
            } else {
              upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
              downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));
              upQueries.push(new Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));
              downQueries.push(new Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}."${newColumn.name}"`));
            }
          }
        }
        if (newColumn.default !== oldColumn.default && !defaultValueChanged) {
          if (newColumn.default !== null && newColumn.default !== void 0) {
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${newColumn.default}`));
            if (oldColumn.default !== null && oldColumn.default !== void 0) {
              downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${oldColumn.default}`));
            } else {
              downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
            }
          } else if (oldColumn.default !== null && oldColumn.default !== void 0) {
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${oldColumn.default}`));
          }
        }
        if ((newColumn.spatialFeatureType || "").toLowerCase() !== (oldColumn.spatialFeatureType || "").toLowerCase() || newColumn.srid !== oldColumn.srid) {
          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(newColumn)}`));
          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(oldColumn)}`));
        }
        if (newColumn.generatedType !== oldColumn.generatedType) {
          if (!newColumn.generatedType || newColumn.generatedType === "VIRTUAL") {
            const tableNameWithSchema = (yield this.getTableNameWithSchema(table.name)).split(".");
            const tableName = tableNameWithSchema[1];
            const schema = tableNameWithSchema[0];
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN "${oldColumn.name}" TO "TEMP_OLD_${oldColumn.name}"`));
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, newColumn)}`));
            upQueries.push(new Query(`UPDATE ${this.escapePath(table)} SET "${newColumn.name}" = "TEMP_OLD_${oldColumn.name}"`));
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "TEMP_OLD_${oldColumn.name}"`));
            upQueries.push(this.deleteTypeormMetadataSql({
              database: this.driver.database,
              schema,
              table: tableName,
              type: MetadataTableType.GENERATED_COLUMN,
              name: oldColumn.name
            }));
            downQueries.push(this.insertTypeormMetadataSql({
              database: this.driver.database,
              schema,
              table: tableName,
              type: MetadataTableType.GENERATED_COLUMN,
              name: oldColumn.name,
              value: oldColumn.asExpression
            }));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, oldColumn)}`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${newColumn.name}"`));
          }
        }
      }
      yield this.executeQueries(upQueries, downQueries);
      this.replaceCachedTable(table, clonedTable);
    });
  }
  /**
   * Changes a column in the table.
   */
  changeColumns(tableOrName, changedColumns) {
    return __async(this, null, function* () {
      for (const {
        oldColumn,
        newColumn
      } of changedColumns) {
        yield this.changeColumn(tableOrName, oldColumn, newColumn);
      }
    });
  }
  /**
   * Drops column in the table.
   */
  dropColumn(tableOrName, columnOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const column = InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);
      if (!column) throw new TypeORMError(`Column "${columnOrName}" was not found in table "${table.name}"`);
      const clonedTable = table.clone();
      const upQueries = [];
      const downQueries = [];
      if (column.isPrimary) {
        const pkName = column.primaryKeyConstraintName ? column.primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column2) => column2.name));
        const columnNames = clonedTable.primaryColumns.map((primaryColumn) => `"${primaryColumn.name}"`).join(", ");
        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName}"`));
        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
        const tableColumn = clonedTable.findColumnByName(column.name);
        tableColumn.isPrimary = false;
        if (clonedTable.primaryColumns.length > 0) {
          const pkName2 = clonedTable.primaryColumns[0].primaryKeyConstraintName ? clonedTable.primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column2) => column2.name));
          const columnNames2 = clonedTable.primaryColumns.map((primaryColumn) => `"${primaryColumn.name}"`).join(", ");
          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNames2})`));
          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName2}"`));
        }
      }
      const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
      if (columnIndex) {
        clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);
        upQueries.push(this.dropIndexSql(table, columnIndex));
        downQueries.push(this.createIndexSql(table, columnIndex));
      }
      const columnCheck = clonedTable.checks.find((check) => !!check.columnNames && check.columnNames.length === 1 && check.columnNames[0] === column.name);
      if (columnCheck) {
        clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);
        upQueries.push(this.dropCheckConstraintSql(table, columnCheck));
        downQueries.push(this.createCheckConstraintSql(table, columnCheck));
      }
      const columnUnique = clonedTable.uniques.find((unique) => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);
      if (columnUnique) {
        clonedTable.uniques.splice(clonedTable.uniques.indexOf(columnUnique), 1);
        upQueries.push(this.dropUniqueConstraintSql(table, columnUnique));
        downQueries.push(this.createUniqueConstraintSql(table, columnUnique));
      }
      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${column.name}"`));
      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column)}`));
      if (column.type === "enum" || column.type === "simple-enum") {
        const hasEnum = yield this.hasEnumType(table, column);
        if (hasEnum) {
          const enumType = yield this.getUserDefinedTypeName(table, column);
          const escapedEnumName = `"${enumType.schema}"."${enumType.name}"`;
          upQueries.push(this.dropEnumTypeSql(table, column, escapedEnumName));
          downQueries.push(this.createEnumTypeSql(table, column, escapedEnumName));
        }
      }
      if (column.generatedType === "STORED") {
        const tableNameWithSchema = (yield this.getTableNameWithSchema(table.name)).split(".");
        const tableName = tableNameWithSchema[1];
        const schema = tableNameWithSchema[0];
        const deleteQuery = this.deleteTypeormMetadataSql({
          database: this.driver.database,
          schema,
          table: tableName,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name
        });
        const insertQuery = this.insertTypeormMetadataSql({
          database: this.driver.database,
          schema,
          table: tableName,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name,
          value: column.asExpression
        });
        upQueries.push(deleteQuery);
        downQueries.push(insertQuery);
      }
      yield this.executeQueries(upQueries, downQueries);
      clonedTable.removeColumn(column);
      this.replaceCachedTable(table, clonedTable);
    });
  }
  /**
   * Drops the columns in the table.
   */
  dropColumns(tableOrName, columns) {
    return __async(this, null, function* () {
      for (const column of columns) {
        yield this.dropColumn(tableOrName, column);
      }
    });
  }
  /**
   * Creates a new primary key.
   */
  createPrimaryKey(tableOrName, columnNames, constraintName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const clonedTable = table.clone();
      const up = this.createPrimaryKeySql(table, columnNames, constraintName);
      clonedTable.columns.forEach((column) => {
        if (columnNames.find((columnName) => columnName === column.name)) column.isPrimary = true;
      });
      const down = this.dropPrimaryKeySql(clonedTable);
      yield this.executeQueries(up, down);
      this.replaceCachedTable(table, clonedTable);
    });
  }
  /**
   * Updates composite primary keys.
   */
  updatePrimaryKeys(tableOrName, columns) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const clonedTable = table.clone();
      const columnNames = columns.map((column) => column.name);
      const upQueries = [];
      const downQueries = [];
      const primaryColumns = clonedTable.primaryColumns;
      if (primaryColumns.length > 0) {
        const pkName2 = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
        const columnNamesString2 = primaryColumns.map((column) => `"${column.name}"`).join(", ");
        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName2}"`));
        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNamesString2})`));
      }
      clonedTable.columns.filter((column) => columnNames.indexOf(column.name) !== -1).forEach((column) => column.isPrimary = true);
      const pkName = primaryColumns[0]?.primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
      const columnNamesString = columnNames.map((columnName) => `"${columnName}"`).join(", ");
      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNamesString})`));
      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
      yield this.executeQueries(upQueries, downQueries);
      this.replaceCachedTable(table, clonedTable);
    });
  }
  /**
   * Drops a primary key.
   */
  dropPrimaryKey(tableOrName, constraintName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const up = this.dropPrimaryKeySql(table);
      const down = this.createPrimaryKeySql(table, table.primaryColumns.map((column) => column.name), constraintName);
      yield this.executeQueries(up, down);
      table.primaryColumns.forEach((column) => {
        column.isPrimary = false;
      });
    });
  }
  /**
   * Creates new unique constraint.
   */
  createUniqueConstraint(tableOrName, uniqueConstraint) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      if (!uniqueConstraint.name) uniqueConstraint.name = this.connection.namingStrategy.uniqueConstraintName(table, uniqueConstraint.columnNames);
      const up = this.createUniqueConstraintSql(table, uniqueConstraint);
      const down = this.dropUniqueConstraintSql(table, uniqueConstraint);
      yield this.executeQueries(up, down);
      table.addUniqueConstraint(uniqueConstraint);
    });
  }
  /**
   * Creates new unique constraints.
   */
  createUniqueConstraints(tableOrName, uniqueConstraints) {
    return __async(this, null, function* () {
      for (const uniqueConstraint of uniqueConstraints) {
        yield this.createUniqueConstraint(tableOrName, uniqueConstraint);
      }
    });
  }
  /**
   * Drops unique constraint.
   */
  dropUniqueConstraint(tableOrName, uniqueOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const uniqueConstraint = InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName : table.uniques.find((u) => u.name === uniqueOrName);
      if (!uniqueConstraint) throw new TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);
      const up = this.dropUniqueConstraintSql(table, uniqueConstraint);
      const down = this.createUniqueConstraintSql(table, uniqueConstraint);
      yield this.executeQueries(up, down);
      table.removeUniqueConstraint(uniqueConstraint);
    });
  }
  /**
   * Drops unique constraints.
   */
  dropUniqueConstraints(tableOrName, uniqueConstraints) {
    return __async(this, null, function* () {
      for (const uniqueConstraint of uniqueConstraints) {
        yield this.dropUniqueConstraint(tableOrName, uniqueConstraint);
      }
    });
  }
  /**
   * Creates new check constraint.
   */
  createCheckConstraint(tableOrName, checkConstraint) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      if (!checkConstraint.name) checkConstraint.name = this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);
      const up = this.createCheckConstraintSql(table, checkConstraint);
      const down = this.dropCheckConstraintSql(table, checkConstraint);
      yield this.executeQueries(up, down);
      table.addCheckConstraint(checkConstraint);
    });
  }
  /**
   * Creates new check constraints.
   */
  createCheckConstraints(tableOrName, checkConstraints) {
    return __async(this, null, function* () {
      const promises = checkConstraints.map((checkConstraint) => this.createCheckConstraint(tableOrName, checkConstraint));
      yield Promise.all(promises);
    });
  }
  /**
   * Drops check constraint.
   */
  dropCheckConstraint(tableOrName, checkOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const checkConstraint = InstanceChecker.isTableCheck(checkOrName) ? checkOrName : table.checks.find((c) => c.name === checkOrName);
      if (!checkConstraint) throw new TypeORMError(`Supplied check constraint was not found in table ${table.name}`);
      const up = this.dropCheckConstraintSql(table, checkConstraint);
      const down = this.createCheckConstraintSql(table, checkConstraint);
      yield this.executeQueries(up, down);
      table.removeCheckConstraint(checkConstraint);
    });
  }
  /**
   * Drops check constraints.
   */
  dropCheckConstraints(tableOrName, checkConstraints) {
    return __async(this, null, function* () {
      const promises = checkConstraints.map((checkConstraint) => this.dropCheckConstraint(tableOrName, checkConstraint));
      yield Promise.all(promises);
    });
  }
  /**
   * Creates new exclusion constraint.
   */
  createExclusionConstraint(tableOrName, exclusionConstraint) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      if (!exclusionConstraint.name) exclusionConstraint.name = this.connection.namingStrategy.exclusionConstraintName(table, exclusionConstraint.expression);
      const up = this.createExclusionConstraintSql(table, exclusionConstraint);
      const down = this.dropExclusionConstraintSql(table, exclusionConstraint);
      yield this.executeQueries(up, down);
      table.addExclusionConstraint(exclusionConstraint);
    });
  }
  /**
   * Creates new exclusion constraints.
   */
  createExclusionConstraints(tableOrName, exclusionConstraints) {
    return __async(this, null, function* () {
      const promises = exclusionConstraints.map((exclusionConstraint) => this.createExclusionConstraint(tableOrName, exclusionConstraint));
      yield Promise.all(promises);
    });
  }
  /**
   * Drops exclusion constraint.
   */
  dropExclusionConstraint(tableOrName, exclusionOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const exclusionConstraint = InstanceChecker.isTableExclusion(exclusionOrName) ? exclusionOrName : table.exclusions.find((c) => c.name === exclusionOrName);
      if (!exclusionConstraint) throw new TypeORMError(`Supplied exclusion constraint was not found in table ${table.name}`);
      const up = this.dropExclusionConstraintSql(table, exclusionConstraint);
      const down = this.createExclusionConstraintSql(table, exclusionConstraint);
      yield this.executeQueries(up, down);
      table.removeExclusionConstraint(exclusionConstraint);
    });
  }
  /**
   * Drops exclusion constraints.
   */
  dropExclusionConstraints(tableOrName, exclusionConstraints) {
    return __async(this, null, function* () {
      const promises = exclusionConstraints.map((exclusionConstraint) => this.dropExclusionConstraint(tableOrName, exclusionConstraint));
      yield Promise.all(promises);
    });
  }
  /**
   * Creates a new foreign key.
   */
  createForeignKey(tableOrName, foreignKey) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      if (!foreignKey.name) foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
      const up = this.createForeignKeySql(table, foreignKey);
      const down = this.dropForeignKeySql(table, foreignKey);
      yield this.executeQueries(up, down);
      table.addForeignKey(foreignKey);
    });
  }
  /**
   * Creates a new foreign keys.
   */
  createForeignKeys(tableOrName, foreignKeys) {
    return __async(this, null, function* () {
      for (const foreignKey of foreignKeys) {
        yield this.createForeignKey(tableOrName, foreignKey);
      }
    });
  }
  /**
   * Drops a foreign key from the table.
   */
  dropForeignKey(tableOrName, foreignKeyOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName);
      if (!foreignKey) throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
      if (!foreignKey.name) {
        foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
      }
      const up = this.dropForeignKeySql(table, foreignKey);
      const down = this.createForeignKeySql(table, foreignKey);
      yield this.executeQueries(up, down);
      table.removeForeignKey(foreignKey);
    });
  }
  /**
   * Drops a foreign keys from the table.
   */
  dropForeignKeys(tableOrName, foreignKeys) {
    return __async(this, null, function* () {
      for (const foreignKey of foreignKeys) {
        yield this.dropForeignKey(tableOrName, foreignKey);
      }
    });
  }
  /**
   * Creates a new index.
   */
  createIndex(tableOrName, index) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      if (!index.name) index.name = this.generateIndexName(table, index);
      const up = this.createIndexSql(table, index);
      const down = this.dropIndexSql(table, index);
      yield this.executeQueries(up, down);
      table.addIndex(index);
    });
  }
  /**
   * Create a new view index.
   */
  createViewIndex(viewOrName, index) {
    return __async(this, null, function* () {
      const view = InstanceChecker.isView(viewOrName) ? viewOrName : yield this.getCachedView(viewOrName);
      if (!index.name) index.name = this.generateIndexName(view, index);
      const up = this.createViewIndexSql(view, index);
      const down = this.dropIndexSql(view, index);
      yield this.executeQueries(up, down);
      view.addIndex(index);
    });
  }
  /**
   * Creates a new indices
   */
  createIndices(tableOrName, indices) {
    return __async(this, null, function* () {
      for (const index of indices) {
        yield this.createIndex(tableOrName, index);
      }
    });
  }
  /**
   * Creates new view indices
   */
  createViewIndices(viewOrName, indices) {
    return __async(this, null, function* () {
      for (const index of indices) {
        yield this.createViewIndex(viewOrName, index);
      }
    });
  }
  /**
   * Drops an index from the table.
   */
  dropIndex(tableOrName, indexOrName) {
    return __async(this, null, function* () {
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      const index = InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find((i) => i.name === indexOrName);
      if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);
      if (!index.name) index.name = this.generateIndexName(table, index);
      const up = this.dropIndexSql(table, index);
      const down = this.createIndexSql(table, index);
      yield this.executeQueries(up, down);
      table.removeIndex(index);
    });
  }
  /**
   * Drops an index from a view.
   */
  dropViewIndex(viewOrName, indexOrName) {
    return __async(this, null, function* () {
      const view = InstanceChecker.isView(viewOrName) ? viewOrName : yield this.getCachedView(viewOrName);
      const index = InstanceChecker.isTableIndex(indexOrName) ? indexOrName : view.indices.find((i) => i.name === indexOrName);
      if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in view ${view.name}`);
      if (!index.name) index.name = this.generateIndexName(view, index);
      const up = this.dropIndexSql(view, index);
      const down = this.createViewIndexSql(view, index);
      yield this.executeQueries(up, down);
      view.removeIndex(index);
    });
  }
  /**
   * Drops an indices from the table.
   */
  dropIndices(tableOrName, indices) {
    return __async(this, null, function* () {
      for (const index of indices) {
        yield this.dropIndex(tableOrName, index);
      }
    });
  }
  /**
   * Clears all table contents.
   * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
   */
  clearTable(tableName) {
    return __async(this, null, function* () {
      yield this.query(`TRUNCATE TABLE ${this.escapePath(tableName)}`);
    });
  }
  /**
   * Removes all tables from the currently connected database.
   */
  clearDatabase() {
    return __async(this, null, function* () {
      const schemas = [];
      this.connection.entityMetadatas.filter((metadata) => metadata.schema).forEach((metadata) => {
        const isSchemaExist = !!schemas.find((schema) => schema === metadata.schema);
        if (!isSchemaExist) schemas.push(metadata.schema);
      });
      schemas.push(this.driver.options.schema || "current_schema()");
      const schemaNamesString = schemas.map((name) => {
        return name === "current_schema()" ? name : "'" + name + "'";
      }).join(", ");
      const isAnotherTransactionActive = this.isTransactionActive;
      if (!isAnotherTransactionActive) yield this.startTransaction();
      try {
        const version = yield this.getVersion();
        const selectViewDropsQuery = `SELECT 'DROP VIEW IF EXISTS "' || schemaname || '"."' || viewname || '" CASCADE;' as "query" FROM "pg_views" WHERE "schemaname" IN (${schemaNamesString}) AND "viewname" NOT IN ('geography_columns', 'geometry_columns', 'raster_columns', 'raster_overviews')`;
        const dropViewQueries = yield this.query(selectViewDropsQuery);
        yield Promise.all(dropViewQueries.map((q) => this.query(q["query"])));
        if (VersionUtils.isGreaterOrEqual(version, "9.3")) {
          const selectMatViewDropsQuery = `SELECT 'DROP MATERIALIZED VIEW IF EXISTS "' || schemaname || '"."' || matviewname || '" CASCADE;' as "query" FROM "pg_matviews" WHERE "schemaname" IN (${schemaNamesString})`;
          const dropMatViewQueries = yield this.query(selectMatViewDropsQuery);
          yield Promise.all(dropMatViewQueries.map((q) => this.query(q["query"])));
        }
        const selectTableDropsQuery = `SELECT 'DROP TABLE IF EXISTS "' || schemaname || '"."' || tablename || '" CASCADE;' as "query" FROM "pg_tables" WHERE "schemaname" IN (${schemaNamesString}) AND "tablename" NOT IN ('spatial_ref_sys')`;
        const dropTableQueries = yield this.query(selectTableDropsQuery);
        yield Promise.all(dropTableQueries.map((q) => this.query(q["query"])));
        yield this.dropEnumTypes(schemaNamesString);
        if (!isAnotherTransactionActive) {
          yield this.commitTransaction();
        }
      } catch (error) {
        try {
          if (!isAnotherTransactionActive) {
            yield this.rollbackTransaction();
          }
        } catch (rollbackError) {
        }
        throw error;
      }
    });
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  loadViews(viewNames) {
    return __async(this, null, function* () {
      const hasTable = yield this.hasTable(this.getTypeormMetadataTableName());
      if (!hasTable) return [];
      if (!viewNames) {
        viewNames = [];
      }
      const currentDatabase = yield this.getCurrentDatabase();
      const currentSchema = yield this.getCurrentSchema();
      const viewsCondition = viewNames.length === 0 ? "1=1" : viewNames.map((tableName) => this.driver.parseTableName(tableName)).map(({
        schema,
        tableName
      }) => {
        if (!schema) {
          schema = this.driver.options.schema || currentSchema;
        }
        return `("t"."schema" = '${schema}' AND "t"."name" = '${tableName}')`;
      }).join(" OR ");
      const constraintsCondition = viewNames.length === 0 ? "1=1" : viewNames.map((tableName) => this.driver.parseTableName(tableName)).map(({
        schema,
        tableName
      }) => {
        if (!schema) {
          schema = this.driver.options.schema || currentSchema;
        }
        return `("ns"."nspname" = '${schema}' AND "t"."relname" = '${tableName}')`;
      }).join(" OR ");
      const indicesSql = `SELECT "ns"."nspname" AS "table_schema", "t"."relname" AS "table_name", "i"."relname" AS "constraint_name", "a"."attname" AS "column_name", CASE "ix"."indisunique" WHEN 't' THEN 'TRUE' ELSE'FALSE' END AS "is_unique", pg_get_expr("ix"."indpred", "ix"."indrelid") AS "condition", "types"."typname" AS "type_name" FROM "pg_class" "t" INNER JOIN "pg_index" "ix" ON "ix"."indrelid" = "t"."oid" INNER JOIN "pg_attribute" "a" ON "a"."attrelid" = "t"."oid"  AND "a"."attnum" = ANY ("ix"."indkey") INNER JOIN "pg_namespace" "ns" ON "ns"."oid" = "t"."relnamespace" INNER JOIN "pg_class" "i" ON "i"."oid" = "ix"."indexrelid" INNER JOIN "pg_type" "types" ON "types"."oid" = "a"."atttypid" LEFT JOIN "pg_constraint" "cnst" ON "cnst"."conname" = "i"."relname" WHERE "t"."relkind" IN ('m') AND "cnst"."contype" IS NULL AND (${constraintsCondition})`;
      const query = `SELECT "t".* FROM ${this.escapePath(this.getTypeormMetadataTableName())} "t" INNER JOIN "pg_catalog"."pg_class" "c" ON "c"."relname" = "t"."name" INNER JOIN "pg_namespace" "n" ON "n"."oid" = "c"."relnamespace" AND "n"."nspname" = "t"."schema" WHERE "t"."type" IN ('${MetadataTableType.VIEW}', '${MetadataTableType.MATERIALIZED_VIEW}') ${viewsCondition ? `AND (${viewsCondition})` : ""}`;
      const dbViews = yield this.query(query);
      const dbIndices = yield this.query(indicesSql);
      return dbViews.map((dbView) => {
        const tableIndexConstraints = OrmUtils.uniq(dbIndices.filter((dbIndex) => {
          return dbIndex["table_name"] === dbView["name"] && dbIndex["table_schema"] === dbView["schema"];
        }), (dbIndex) => dbIndex["constraint_name"]);
        const view = new View();
        const schema = dbView["schema"] === currentSchema && !this.driver.options.schema ? void 0 : dbView["schema"];
        view.database = currentDatabase;
        view.schema = dbView["schema"];
        view.name = this.driver.buildTableName(dbView["name"], schema);
        view.expression = dbView["value"];
        view.materialized = dbView["type"] === MetadataTableType.MATERIALIZED_VIEW;
        view.indices = tableIndexConstraints.map((constraint) => {
          const indices = dbIndices.filter((index) => {
            return index["table_schema"] === constraint["table_schema"] && index["table_name"] === constraint["table_name"] && index["constraint_name"] === constraint["constraint_name"];
          });
          return new TableIndex({
            view,
            name: constraint["constraint_name"],
            columnNames: indices.map((i) => i["column_name"]),
            isUnique: constraint["is_unique"] === "TRUE",
            where: constraint["condition"],
            isFulltext: false
          });
        });
        return view;
      });
    });
  }
  /**
   * Loads all tables (with given names) from the database and creates a Table from them.
   */
  loadTables(tableNames) {
    return __async(this, null, function* () {
      if (tableNames && tableNames.length === 0) {
        return [];
      }
      const currentSchema = yield this.getCurrentSchema();
      const currentDatabase = yield this.getCurrentDatabase();
      const dbTables = [];
      if (!tableNames) {
        const tablesSql = `SELECT "table_schema", "table_name", obj_description(('"' || "table_schema" || '"."' || "table_name" || '"')::regclass, 'pg_class') AS table_comment FROM "information_schema"."tables"`;
        dbTables.push(...yield this.query(tablesSql));
      } else {
        const tablesCondition = tableNames.map((tableName) => this.driver.parseTableName(tableName)).map(({
          schema,
          tableName
        }) => {
          return `("table_schema" = '${schema || currentSchema}' AND "table_name" = '${tableName}')`;
        }).join(" OR ");
        const tablesSql = `SELECT "table_schema", "table_name", obj_description(('"' || "table_schema" || '"."' || "table_name" || '"')::regclass, 'pg_class') AS table_comment FROM "information_schema"."tables" WHERE ` + tablesCondition;
        dbTables.push(...yield this.query(tablesSql));
      }
      if (dbTables.length === 0) {
        return [];
      }
      const columnsCondition = dbTables.map(({
        table_schema,
        table_name
      }) => {
        return `("table_schema" = '${table_schema}' AND "table_name" = '${table_name}')`;
      }).join(" OR ");
      const columnsSql = `SELECT columns.*, pg_catalog.col_description(('"' || table_catalog || '"."' || table_schema || '"."' || table_name || '"')::regclass::oid, ordinal_position) AS description, ('"' || "udt_schema" || '"."' || "udt_name" || '"')::"regtype" AS "regtype", pg_catalog.format_type("col_attr"."atttypid", "col_attr"."atttypmod") AS "format_type" FROM "information_schema"."columns" LEFT JOIN "pg_catalog"."pg_attribute" AS "col_attr" ON "col_attr"."attname" = "columns"."column_name" AND "col_attr"."attrelid" = ( SELECT "cls"."oid" FROM "pg_catalog"."pg_class" AS "cls" LEFT JOIN "pg_catalog"."pg_namespace" AS "ns" ON "ns"."oid" = "cls"."relnamespace" WHERE "cls"."relname" = "columns"."table_name" AND "ns"."nspname" = "columns"."table_schema" ) WHERE ` + columnsCondition;
      const constraintsCondition = dbTables.map(({
        table_schema,
        table_name
      }) => {
        return `("ns"."nspname" = '${table_schema}' AND "t"."relname" = '${table_name}')`;
      }).join(" OR ");
      const constraintsSql = `SELECT "ns"."nspname" AS "table_schema", "t"."relname" AS "table_name", "cnst"."conname" AS "constraint_name", pg_get_constraintdef("cnst"."oid") AS "expression", CASE "cnst"."contype" WHEN 'p' THEN 'PRIMARY' WHEN 'u' THEN 'UNIQUE' WHEN 'c' THEN 'CHECK' WHEN 'x' THEN 'EXCLUDE' END AS "constraint_type", "a"."attname" AS "column_name" FROM "pg_constraint" "cnst" INNER JOIN "pg_class" "t" ON "t"."oid" = "cnst"."conrelid" INNER JOIN "pg_namespace" "ns" ON "ns"."oid" = "cnst"."connamespace" LEFT JOIN "pg_attribute" "a" ON "a"."attrelid" = "cnst"."conrelid" AND "a"."attnum" = ANY ("cnst"."conkey") WHERE "t"."relkind" IN ('r', 'p') AND (${constraintsCondition})`;
      const indicesSql = `SELECT "ns"."nspname" AS "table_schema", "t"."relname" AS "table_name", "i"."relname" AS "constraint_name", "a"."attname" AS "column_name", CASE "ix"."indisunique" WHEN 't' THEN 'TRUE' ELSE'FALSE' END AS "is_unique", pg_get_expr("ix"."indpred", "ix"."indrelid") AS "condition", "types"."typname" AS "type_name", "am"."amname" AS "index_type" FROM "pg_class" "t" INNER JOIN "pg_index" "ix" ON "ix"."indrelid" = "t"."oid" INNER JOIN "pg_attribute" "a" ON "a"."attrelid" = "t"."oid"  AND "a"."attnum" = ANY ("ix"."indkey") INNER JOIN "pg_namespace" "ns" ON "ns"."oid" = "t"."relnamespace" INNER JOIN "pg_class" "i" ON "i"."oid" = "ix"."indexrelid" INNER JOIN "pg_type" "types" ON "types"."oid" = "a"."atttypid" INNER JOIN "pg_am" "am" ON "i"."relam" = "am"."oid" LEFT JOIN "pg_constraint" "cnst" ON "cnst"."conname" = "i"."relname" WHERE "t"."relkind" IN ('r', 'p') AND "cnst"."contype" IS NULL AND (${constraintsCondition})`;
      const foreignKeysCondition = dbTables.map(({
        table_schema,
        table_name
      }) => {
        return `("ns"."nspname" = '${table_schema}' AND "cl"."relname" = '${table_name}')`;
      }).join(" OR ");
      const hasRelispartitionColumn = yield this.hasSupportForPartitionedTables();
      const isPartitionCondition = hasRelispartitionColumn ? ` AND "cl"."relispartition" = 'f'` : "";
      const foreignKeysSql = `SELECT "con"."conname" AS "constraint_name", "con"."nspname" AS "table_schema", "con"."relname" AS "table_name", "att2"."attname" AS "column_name", "ns"."nspname" AS "referenced_table_schema", "cl"."relname" AS "referenced_table_name", "att"."attname" AS "referenced_column_name", "con"."confdeltype" AS "on_delete", "con"."confupdtype" AS "on_update", "con"."condeferrable" AS "deferrable", "con"."condeferred" AS "deferred" FROM ( SELECT UNNEST ("con1"."conkey") AS "parent", UNNEST ("con1"."confkey") AS "child", "con1"."confrelid", "con1"."conrelid", "con1"."conname", "con1"."contype", "ns"."nspname", "cl"."relname", "con1"."condeferrable", CASE WHEN "con1"."condeferred" THEN 'INITIALLY DEFERRED' ELSE 'INITIALLY IMMEDIATE' END as condeferred, CASE "con1"."confdeltype" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as "confdeltype", CASE "con1"."confupdtype" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as "confupdtype" FROM "pg_class" "cl" INNER JOIN "pg_namespace" "ns" ON "cl"."relnamespace" = "ns"."oid" INNER JOIN "pg_constraint" "con1" ON "con1"."conrelid" = "cl"."oid" WHERE "con1"."contype" = 'f' AND (${foreignKeysCondition}) ) "con" INNER JOIN "pg_attribute" "att" ON "att"."attrelid" = "con"."confrelid" AND "att"."attnum" = "con"."child" INNER JOIN "pg_class" "cl" ON "cl"."oid" = "con"."confrelid" ${isPartitionCondition}INNER JOIN "pg_namespace" "ns" ON "cl"."relnamespace" = "ns"."oid" INNER JOIN "pg_attribute" "att2" ON "att2"."attrelid" = "con"."conrelid" AND "att2"."attnum" = "con"."parent"`;
      const [dbColumns, dbConstraints, dbIndices, dbForeignKeys] = yield Promise.all([this.query(columnsSql), this.query(constraintsSql), this.query(indicesSql), this.query(foreignKeysSql)]);
      return Promise.all(dbTables.map((dbTable) => __async(this, null, function* () {
        const table = new Table();
        const getSchemaFromKey = (dbObject, key) => {
          return dbObject[key] === currentSchema && (!this.driver.options.schema || this.driver.options.schema === currentSchema) ? void 0 : dbObject[key];
        };
        const schema = getSchemaFromKey(dbTable, "table_schema");
        table.database = currentDatabase;
        table.schema = dbTable["table_schema"];
        table.comment = dbTable["table_comment"];
        table.name = this.driver.buildTableName(dbTable["table_name"], schema);
        table.columns = yield Promise.all(dbColumns.filter((dbColumn) => dbColumn["table_name"] === dbTable["table_name"] && dbColumn["table_schema"] === dbTable["table_schema"]).map((dbColumn) => __async(this, null, function* () {
          const columnConstraints = dbConstraints.filter((dbConstraint) => {
            return dbConstraint["table_name"] === dbColumn["table_name"] && dbConstraint["table_schema"] === dbColumn["table_schema"] && dbConstraint["column_name"] === dbColumn["column_name"];
          });
          const tableColumn = new TableColumn();
          tableColumn.name = dbColumn["column_name"];
          tableColumn.type = dbColumn["regtype"].toLowerCase();
          if (tableColumn.type === "numeric" || tableColumn.type === "numeric[]" || tableColumn.type === "decimal" || tableColumn.type === "float") {
            let numericPrecision = dbColumn["numeric_precision"];
            let numericScale = dbColumn["numeric_scale"];
            if (dbColumn["data_type"] === "ARRAY") {
              const numericSize = dbColumn["format_type"].match(/^numeric\(([0-9]+),([0-9]+)\)\[\]$/);
              if (numericSize) {
                numericPrecision = +numericSize[1];
                numericScale = +numericSize[2];
              }
            }
            if (numericPrecision !== null && !this.isDefaultColumnPrecision(table, tableColumn, numericPrecision)) {
              tableColumn.precision = numericPrecision;
            } else if (numericScale !== null && !this.isDefaultColumnScale(table, tableColumn, numericScale)) {
              tableColumn.precision = void 0;
            }
            if (numericScale !== null && !this.isDefaultColumnScale(table, tableColumn, numericScale)) {
              tableColumn.scale = numericScale;
            } else if (numericPrecision !== null && !this.isDefaultColumnPrecision(table, tableColumn, numericPrecision)) {
              tableColumn.scale = void 0;
            }
          }
          if (tableColumn.type === "interval" || tableColumn.type === "time without time zone" || tableColumn.type === "time with time zone" || tableColumn.type === "timestamp without time zone" || tableColumn.type === "timestamp with time zone") {
            tableColumn.precision = !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["datetime_precision"]) ? dbColumn["datetime_precision"] : void 0;
          }
          if (dbColumn["data_type"] === "USER-DEFINED" || dbColumn["data_type"] === "ARRAY") {
            const {
              name
            } = yield this.getUserDefinedTypeName(table, tableColumn);
            const builtEnumName = this.buildEnumName(table, tableColumn, false, true);
            const enumName = builtEnumName !== name ? name : void 0;
            const sql = `SELECT "e"."enumlabel" AS "value" FROM "pg_enum" "e" INNER JOIN "pg_type" "t" ON "t"."oid" = "e"."enumtypid" INNER JOIN "pg_namespace" "n" ON "n"."oid" = "t"."typnamespace" WHERE "n"."nspname" = '${dbTable["table_schema"]}' AND "t"."typname" = '${enumName || name}'`;
            const results = yield this.query(sql);
            if (results.length) {
              tableColumn.type = "enum";
              tableColumn.enum = results.map((result) => result["value"]);
              tableColumn.enumName = enumName;
            }
            if (dbColumn["data_type"] === "ARRAY") {
              tableColumn.isArray = true;
              const type = tableColumn.type.replace("[]", "");
              tableColumn.type = this.connection.driver.normalizeType({
                type
              });
            }
          }
          if (tableColumn.type === "geometry" || tableColumn.type === "geography") {
            const sql = `SELECT * FROM (SELECT "f_table_schema" "table_schema", "f_table_name" "table_name", "f_${tableColumn.type}_column" "column_name", "srid", "type" FROM "${tableColumn.type}_columns") AS _ WHERE "column_name" = '${dbColumn["column_name"]}' AND "table_schema" = '${dbColumn["table_schema"]}' AND "table_name" = '${dbColumn["table_name"]}'`;
            const results = yield this.query(sql);
            if (results.length > 0) {
              tableColumn.spatialFeatureType = results[0].type;
              tableColumn.srid = results[0].srid;
            }
          }
          if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1) {
            let length;
            if (tableColumn.isArray) {
              const match = /\((\d+)\)/.exec(dbColumn["format_type"]);
              length = match ? match[1] : void 0;
            } else if (dbColumn["character_maximum_length"]) {
              length = dbColumn["character_maximum_length"].toString();
            }
            if (length) {
              tableColumn.length = !this.isDefaultColumnLength(table, tableColumn, length) ? length : "";
            }
          }
          tableColumn.isNullable = dbColumn["is_nullable"] === "YES";
          const primaryConstraint = columnConstraints.find((constraint) => constraint["constraint_type"] === "PRIMARY");
          if (primaryConstraint) {
            tableColumn.isPrimary = true;
            const anotherPrimaryConstraints = dbConstraints.filter((constraint) => constraint["table_name"] === dbColumn["table_name"] && constraint["table_schema"] === dbColumn["table_schema"] && constraint["column_name"] !== dbColumn["column_name"] && constraint["constraint_type"] === "PRIMARY");
            const columnNames = anotherPrimaryConstraints.map((constraint) => constraint["column_name"]);
            columnNames.push(dbColumn["column_name"]);
            const pkName = this.connection.namingStrategy.primaryKeyName(table, columnNames);
            if (primaryConstraint["constraint_name"] !== pkName) {
              tableColumn.primaryKeyConstraintName = primaryConstraint["constraint_name"];
            }
          }
          const uniqueConstraints = columnConstraints.filter((constraint) => constraint["constraint_type"] === "UNIQUE");
          const isConstraintComposite = uniqueConstraints.every((uniqueConstraint) => {
            return dbConstraints.some((dbConstraint) => dbConstraint["constraint_type"] === "UNIQUE" && dbConstraint["constraint_name"] === uniqueConstraint["constraint_name"] && dbConstraint["column_name"] !== dbColumn["column_name"]);
          });
          tableColumn.isUnique = uniqueConstraints.length > 0 && !isConstraintComposite;
          if (dbColumn.is_identity === "YES") {
            tableColumn.isGenerated = true;
            tableColumn.generationStrategy = "identity";
            tableColumn.generatedIdentity = dbColumn.identity_generation;
          } else if (dbColumn["column_default"] !== null && dbColumn["column_default"] !== void 0) {
            const serialDefaultName = `nextval('${this.buildSequenceName(table, dbColumn["column_name"])}'::regclass)`;
            const serialDefaultPath = `nextval('${this.buildSequencePath(table, dbColumn["column_name"])}'::regclass)`;
            const defaultWithoutQuotes = dbColumn["column_default"].replace(/"/g, "");
            if (defaultWithoutQuotes === serialDefaultName || defaultWithoutQuotes === serialDefaultPath) {
              tableColumn.isGenerated = true;
              tableColumn.generationStrategy = "increment";
            } else if (dbColumn["column_default"] === "gen_random_uuid()" || /^uuid_generate_v\d\(\)/.test(dbColumn["column_default"])) {
              if (tableColumn.type === "uuid") {
                tableColumn.isGenerated = true;
                tableColumn.generationStrategy = "uuid";
              } else {
                tableColumn.default = dbColumn["column_default"];
              }
            } else if (dbColumn["column_default"] === "now()" || dbColumn["column_default"].indexOf("'now'::text") !== -1) {
              tableColumn.default = dbColumn["column_default"];
            } else {
              tableColumn.default = dbColumn["column_default"].replace(/::[\w\s.[\]\-"]+/g, "");
              tableColumn.default = tableColumn.default.replace(/^(-?\d+)$/, "'$1'");
            }
          }
          if (dbColumn["is_generated"] === "ALWAYS" && dbColumn["generation_expression"]) {
            tableColumn.generatedType = "STORED";
            const asExpressionQuery = this.selectTypeormMetadataSql({
              database: currentDatabase,
              schema: dbTable["table_schema"],
              table: dbTable["table_name"],
              type: MetadataTableType.GENERATED_COLUMN,
              name: tableColumn.name
            });
            const results = yield this.query(asExpressionQuery.query, asExpressionQuery.parameters);
            if (results[0] && results[0].value) {
              tableColumn.asExpression = results[0].value;
            } else {
              tableColumn.asExpression = "";
            }
          }
          tableColumn.comment = dbColumn["description"] ? dbColumn["description"] : void 0;
          if (dbColumn["character_set_name"]) tableColumn.charset = dbColumn["character_set_name"];
          if (dbColumn["collation_name"]) tableColumn.collation = dbColumn["collation_name"];
          return tableColumn;
        })));
        const tableUniqueConstraints = OrmUtils.uniq(dbConstraints.filter((dbConstraint) => {
          return dbConstraint["table_name"] === dbTable["table_name"] && dbConstraint["table_schema"] === dbTable["table_schema"] && dbConstraint["constraint_type"] === "UNIQUE";
        }), (dbConstraint) => dbConstraint["constraint_name"]);
        table.uniques = tableUniqueConstraints.map((constraint) => {
          const uniques = dbConstraints.filter((dbC) => dbC["constraint_name"] === constraint["constraint_name"]);
          return new TableUnique({
            name: constraint["constraint_name"],
            columnNames: uniques.map((u) => u["column_name"]),
            deferrable: constraint["deferrable"] ? constraint["deferred"] : void 0
          });
        });
        const tableCheckConstraints = OrmUtils.uniq(dbConstraints.filter((dbConstraint) => {
          return dbConstraint["table_name"] === dbTable["table_name"] && dbConstraint["table_schema"] === dbTable["table_schema"] && dbConstraint["constraint_type"] === "CHECK";
        }), (dbConstraint) => dbConstraint["constraint_name"]);
        table.checks = tableCheckConstraints.map((constraint) => {
          const checks = dbConstraints.filter((dbC) => dbC["constraint_name"] === constraint["constraint_name"]);
          return new TableCheck({
            name: constraint["constraint_name"],
            columnNames: checks.map((c) => c["column_name"]),
            expression: constraint["expression"].replace(/^\s*CHECK\s*\((.*)\)\s*$/i, "$1")
          });
        });
        const tableExclusionConstraints = OrmUtils.uniq(dbConstraints.filter((dbConstraint) => {
          return dbConstraint["table_name"] === dbTable["table_name"] && dbConstraint["table_schema"] === dbTable["table_schema"] && dbConstraint["constraint_type"] === "EXCLUDE";
        }), (dbConstraint) => dbConstraint["constraint_name"]);
        table.exclusions = tableExclusionConstraints.map((constraint) => {
          return new TableExclusion({
            name: constraint["constraint_name"],
            expression: constraint["expression"].substring(8)
            // trim EXCLUDE from start of expression
          });
        });
        const tableForeignKeyConstraints = OrmUtils.uniq(dbForeignKeys.filter((dbForeignKey) => {
          return dbForeignKey["table_name"] === dbTable["table_name"] && dbForeignKey["table_schema"] === dbTable["table_schema"];
        }), (dbForeignKey) => dbForeignKey["constraint_name"]);
        table.foreignKeys = tableForeignKeyConstraints.map((dbForeignKey) => {
          const foreignKeys = dbForeignKeys.filter((dbFk) => dbFk["constraint_name"] === dbForeignKey["constraint_name"]);
          const schema2 = getSchemaFromKey(dbForeignKey, "referenced_table_schema");
          const referencedTableName = this.driver.buildTableName(dbForeignKey["referenced_table_name"], schema2);
          return new TableForeignKey({
            name: dbForeignKey["constraint_name"],
            columnNames: foreignKeys.map((dbFk) => dbFk["column_name"]),
            referencedSchema: dbForeignKey["referenced_table_schema"],
            referencedTableName,
            referencedColumnNames: foreignKeys.map((dbFk) => dbFk["referenced_column_name"]),
            onDelete: dbForeignKey["on_delete"],
            onUpdate: dbForeignKey["on_update"],
            deferrable: dbForeignKey["deferrable"] ? dbForeignKey["deferred"] : void 0
          });
        });
        const tableIndexConstraints = OrmUtils.uniq(dbIndices.filter((dbIndex) => {
          return dbIndex["table_name"] === dbTable["table_name"] && dbIndex["table_schema"] === dbTable["table_schema"];
        }), (dbIndex) => dbIndex["constraint_name"]);
        table.indices = tableIndexConstraints.map((constraint) => {
          const indices = dbIndices.filter((index) => {
            return index["table_schema"] === constraint["table_schema"] && index["table_name"] === constraint["table_name"] && index["constraint_name"] === constraint["constraint_name"];
          });
          return new TableIndex({
            table,
            name: constraint["constraint_name"],
            columnNames: indices.map((i) => i["column_name"]),
            isUnique: constraint["is_unique"] === "TRUE",
            where: constraint["condition"],
            isSpatial: constraint["index_type"] === "gist",
            isFulltext: false
          });
        });
        return table;
      })));
    });
  }
  /**
   * Builds create table sql.
   */
  createTableSql(table, createForeignKeys) {
    const columnDefinitions = table.columns.map((column) => this.buildCreateColumnSql(table, column)).join(", ");
    let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;
    table.columns.filter((column) => column.isUnique).forEach((column) => {
      const isUniqueExist = table.uniques.some((unique) => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);
      if (!isUniqueExist) table.uniques.push(new TableUnique({
        name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
        columnNames: [column.name]
      }));
    });
    if (table.uniques.length > 0) {
      const uniquesSql = table.uniques.map((unique) => {
        const uniqueName = unique.name ? unique.name : this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);
        const columnNames = unique.columnNames.map((columnName) => `"${columnName}"`).join(", ");
        let constraint = `CONSTRAINT "${uniqueName}" UNIQUE (${columnNames})`;
        if (unique.deferrable) constraint += ` DEFERRABLE ${unique.deferrable}`;
        return constraint;
      }).join(", ");
      sql += `, ${uniquesSql}`;
    }
    if (table.checks.length > 0) {
      const checksSql = table.checks.map((check) => {
        const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table, check.expression);
        return `CONSTRAINT "${checkName}" CHECK (${check.expression})`;
      }).join(", ");
      sql += `, ${checksSql}`;
    }
    if (table.exclusions.length > 0) {
      const exclusionsSql = table.exclusions.map((exclusion) => {
        const exclusionName = exclusion.name ? exclusion.name : this.connection.namingStrategy.exclusionConstraintName(table, exclusion.expression);
        return `CONSTRAINT "${exclusionName}" EXCLUDE ${exclusion.expression}`;
      }).join(", ");
      sql += `, ${exclusionsSql}`;
    }
    if (table.foreignKeys.length > 0 && createForeignKeys) {
      const foreignKeysSql = table.foreignKeys.map((fk) => {
        const columnNames = fk.columnNames.map((columnName) => `"${columnName}"`).join(", ");
        if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);
        const referencedColumnNames = fk.referencedColumnNames.map((columnName) => `"${columnName}"`).join(", ");
        let constraint = `CONSTRAINT "${fk.name}" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;
        if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`;
        if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`;
        if (fk.deferrable) constraint += ` DEFERRABLE ${fk.deferrable}`;
        return constraint;
      }).join(", ");
      sql += `, ${foreignKeysSql}`;
    }
    const primaryColumns = table.columns.filter((column) => column.isPrimary);
    if (primaryColumns.length > 0) {
      const primaryKeyName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(table, primaryColumns.map((column) => column.name));
      const columnNames = primaryColumns.map((column) => `"${column.name}"`).join(", ");
      sql += `, CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNames})`;
    }
    sql += `)`;
    table.columns.filter((it) => it.comment).forEach((it) => sql += `; COMMENT ON COLUMN ${this.escapePath(table)}."${it.name}" IS ${this.escapeComment(it.comment)}`);
    return new Query(sql);
  }
  /**
   * Loads Postgres version.
   */
  getVersion() {
    return __async(this, null, function* () {
      const result = yield this.query(`SELECT version()`);
      return result[0]["version"].replace(/^PostgreSQL ([\d.]+) .*$/, "$1");
    });
  }
  /**
   * Builds drop table sql.
   */
  dropTableSql(tableOrPath) {
    return new Query(`DROP TABLE ${this.escapePath(tableOrPath)}`);
  }
  createViewSql(view) {
    const materializedClause = view.materialized ? "MATERIALIZED " : "";
    const viewName = this.escapePath(view);
    if (typeof view.expression === "string") {
      return new Query(`CREATE ${materializedClause}VIEW ${viewName} AS ${view.expression}`);
    } else {
      return new Query(`CREATE ${materializedClause}VIEW ${viewName} AS ${view.expression(this.connection).getQuery()}`);
    }
  }
  insertViewDefinitionSql(view) {
    return __async(this, null, function* () {
      const currentSchema = yield this.getCurrentSchema();
      let {
        schema,
        tableName: name
      } = this.driver.parseTableName(view);
      if (!schema) {
        schema = currentSchema;
      }
      const type = view.materialized ? MetadataTableType.MATERIALIZED_VIEW : MetadataTableType.VIEW;
      const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
      return this.insertTypeormMetadataSql({
        type,
        schema,
        name,
        value: expression
      });
    });
  }
  /**
   * Builds drop view sql.
   */
  dropViewSql(view) {
    const materializedClause = view.materialized ? "MATERIALIZED " : "";
    return new Query(`DROP ${materializedClause}VIEW ${this.escapePath(view)}`);
  }
  /**
   * Builds remove view sql.
   */
  deleteViewDefinitionSql(view) {
    return __async(this, null, function* () {
      const currentSchema = yield this.getCurrentSchema();
      let {
        schema,
        tableName: name
      } = this.driver.parseTableName(view);
      if (!schema) {
        schema = currentSchema;
      }
      const type = view.materialized ? MetadataTableType.MATERIALIZED_VIEW : MetadataTableType.VIEW;
      return this.deleteTypeormMetadataSql({
        type,
        schema,
        name
      });
    });
  }
  /**
   * Drops ENUM type from given schemas.
   */
  dropEnumTypes(schemaNames) {
    return __async(this, null, function* () {
      const selectDropsQuery = `SELECT 'DROP TYPE IF EXISTS "' || n.nspname || '"."' || t.typname || '" CASCADE;' as "query" FROM "pg_type" "t" INNER JOIN "pg_enum" "e" ON "e"."enumtypid" = "t"."oid" INNER JOIN "pg_namespace" "n" ON "n"."oid" = "t"."typnamespace" WHERE "n"."nspname" IN (${schemaNames}) GROUP BY "n"."nspname", "t"."typname"`;
      const dropQueries = yield this.query(selectDropsQuery);
      yield Promise.all(dropQueries.map((q) => this.query(q["query"])));
    });
  }
  /**
   * Checks if enum with the given name exist in the database.
   */
  hasEnumType(table, column) {
    return __async(this, null, function* () {
      let {
        schema
      } = this.driver.parseTableName(table);
      if (!schema) {
        schema = yield this.getCurrentSchema();
      }
      const enumName = this.buildEnumName(table, column, false, true);
      const sql = `SELECT "n"."nspname", "t"."typname" FROM "pg_type" "t" INNER JOIN "pg_namespace" "n" ON "n"."oid" = "t"."typnamespace" WHERE "n"."nspname" = '${schema}' AND "t"."typname" = '${enumName}'`;
      const result = yield this.query(sql);
      return result.length ? true : false;
    });
  }
  /**
   * Builds create ENUM type sql.
   */
  createEnumTypeSql(table, column, enumName) {
    if (!enumName) enumName = this.buildEnumName(table, column);
    const enumValues = column.enum.map((value) => `'${value.replace("'", "''")}'`).join(", ");
    return new Query(`CREATE TYPE ${enumName} AS ENUM(${enumValues})`);
  }
  /**
   * Builds create ENUM type sql.
   */
  dropEnumTypeSql(table, column, enumName) {
    if (!enumName) enumName = this.buildEnumName(table, column);
    return new Query(`DROP TYPE ${enumName}`);
  }
  /**
   * Builds create index sql.
   */
  createIndexSql(table, index) {
    const columns = index.columnNames.map((columnName) => `"${columnName}"`).join(", ");
    return new Query(`CREATE ${index.isUnique ? "UNIQUE " : ""}INDEX${index.isConcurrent ? " CONCURRENTLY" : ""} "${index.name}" ON ${this.escapePath(table)} ${index.isSpatial ? "USING GiST " : ""}(${columns}) ${index.where ? "WHERE " + index.where : ""}`);
  }
  /**
   * Builds create view index sql.
   */
  createViewIndexSql(view, index) {
    const columns = index.columnNames.map((columnName) => `"${columnName}"`).join(", ");
    return new Query(`CREATE ${index.isUnique ? "UNIQUE " : ""}INDEX "${index.name}" ON ${this.escapePath(view)} (${columns}) ${index.where ? "WHERE " + index.where : ""}`);
  }
  /**
   * Builds drop index sql.
   */
  dropIndexSql(table, indexOrName) {
    const indexName = InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;
    const concurrent = InstanceChecker.isTableIndex(indexOrName) ? indexOrName.isConcurrent : false;
    const {
      schema
    } = this.driver.parseTableName(table);
    return schema ? new Query(`DROP INDEX ${concurrent ? "CONCURRENTLY " : ""}"${schema}"."${indexName}"`) : new Query(`DROP INDEX ${concurrent ? "CONCURRENTLY " : ""}"${indexName}"`);
  }
  /**
   * Builds create primary key sql.
   */
  createPrimaryKeySql(table, columnNames, constraintName) {
    const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);
    const columnNamesString = columnNames.map((columnName) => `"${columnName}"`).join(", ");
    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNamesString})`);
  }
  /**
   * Builds drop primary key sql.
   */
  dropPrimaryKeySql(table) {
    if (!table.primaryColumns.length) throw new TypeORMError(`Table ${table} has no primary keys.`);
    const columnNames = table.primaryColumns.map((column) => column.name);
    const constraintName = table.primaryColumns[0].primaryKeyConstraintName;
    const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);
    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${primaryKeyName}"`);
  }
  /**
   * Builds create unique constraint sql.
   */
  createUniqueConstraintSql(table, uniqueConstraint) {
    const columnNames = uniqueConstraint.columnNames.map((column) => `"` + column + `"`).join(", ");
    let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE (${columnNames})`;
    if (uniqueConstraint.deferrable) sql += ` DEFERRABLE ${uniqueConstraint.deferrable}`;
    return new Query(sql);
  }
  /**
   * Builds drop unique constraint sql.
   */
  dropUniqueConstraintSql(table, uniqueOrName) {
    const uniqueName = InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName.name : uniqueOrName;
    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueName}"`);
  }
  /**
   * Builds create check constraint sql.
   */
  createCheckConstraintSql(table, checkConstraint) {
    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${checkConstraint.name}" CHECK (${checkConstraint.expression})`);
  }
  /**
   * Builds drop check constraint sql.
   */
  dropCheckConstraintSql(table, checkOrName) {
    const checkName = InstanceChecker.isTableCheck(checkOrName) ? checkOrName.name : checkOrName;
    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${checkName}"`);
  }
  /**
   * Builds create exclusion constraint sql.
   */
  createExclusionConstraintSql(table, exclusionConstraint) {
    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${exclusionConstraint.name}" EXCLUDE ${exclusionConstraint.expression}`);
  }
  /**
   * Builds drop exclusion constraint sql.
   */
  dropExclusionConstraintSql(table, exclusionOrName) {
    const exclusionName = InstanceChecker.isTableExclusion(exclusionOrName) ? exclusionOrName.name : exclusionOrName;
    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${exclusionName}"`);
  }
  /**
   * Builds create foreign key sql.
   */
  createForeignKeySql(table, foreignKey) {
    const columnNames = foreignKey.columnNames.map((column) => `"` + column + `"`).join(", ");
    const referencedColumnNames = foreignKey.referencedColumnNames.map((column) => `"` + column + `"`).join(",");
    let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${foreignKey.name}" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
    if (foreignKey.onDelete) sql += ` ON DELETE ${foreignKey.onDelete}`;
    if (foreignKey.onUpdate) sql += ` ON UPDATE ${foreignKey.onUpdate}`;
    if (foreignKey.deferrable) sql += ` DEFERRABLE ${foreignKey.deferrable}`;
    return new Query(sql);
  }
  /**
   * Builds drop foreign key sql.
   */
  dropForeignKeySql(table, foreignKeyOrName) {
    const foreignKeyName = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName.name : foreignKeyOrName;
    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${foreignKeyName}"`);
  }
  /**
   * Builds sequence name from given table and column.
   */
  buildSequenceName(table, columnOrName) {
    const {
      tableName
    } = this.driver.parseTableName(table);
    const columnName = InstanceChecker.isTableColumn(columnOrName) ? columnOrName.name : columnOrName;
    let seqName = `${tableName}_${columnName}_seq`;
    if (seqName.length > this.connection.driver.maxAliasLength) {
      seqName = `${tableName.substring(0, 29)}_${columnName.substring(0, Math.max(29, 63 - table.name.length - 5))}_seq`;
    }
    return seqName;
  }
  buildSequencePath(table, columnOrName) {
    const {
      schema
    } = this.driver.parseTableName(table);
    return schema ? `${schema}.${this.buildSequenceName(table, columnOrName)}` : this.buildSequenceName(table, columnOrName);
  }
  /**
   * Builds ENUM type name from given table and column.
   */
  buildEnumName(table, column, withSchema = true, disableEscape, toOld) {
    const {
      schema,
      tableName
    } = this.driver.parseTableName(table);
    let enumName = column.enumName ? column.enumName : `${tableName}_${column.name.toLowerCase()}_enum`;
    if (schema && withSchema) enumName = `${schema}.${enumName}`;
    if (toOld) enumName = enumName + "_old";
    return enumName.split(".").map((i) => {
      return disableEscape ? i : `"${i}"`;
    }).join(".");
  }
  getUserDefinedTypeName(table, column) {
    return __async(this, null, function* () {
      let {
        schema,
        tableName: name
      } = this.driver.parseTableName(table);
      if (!schema) {
        schema = yield this.getCurrentSchema();
      }
      const result = yield this.query(`SELECT "udt_schema", "udt_name" FROM "information_schema"."columns" WHERE "table_schema" = '${schema}' AND "table_name" = '${name}' AND "column_name"='${column.name}'`);
      let udtName = result[0]["udt_name"];
      if (udtName.indexOf("_") === 0) {
        udtName = udtName.substr(1, udtName.length);
      }
      return {
        schema: result[0]["udt_schema"],
        name: udtName
      };
    });
  }
  /**
   * Escapes a given comment so it's safe to include in a query.
   */
  escapeComment(comment) {
    if (!comment || comment.length === 0) {
      return "NULL";
    }
    comment = comment.replace(/'/g, "''").replace(/\u0000/g, "");
    return `'${comment}'`;
  }
  /**
   * Escapes given table or view path.
   */
  escapePath(target) {
    const {
      schema,
      tableName
    } = this.driver.parseTableName(target);
    if (schema && schema !== this.driver.searchSchema) {
      return `"${schema}"."${tableName}"`;
    }
    return `"${tableName}"`;
  }
  /**
   * Get the table name with table schema
   * Note: Without ' or "
   */
  getTableNameWithSchema(target) {
    return __async(this, null, function* () {
      const tableName = InstanceChecker.isTable(target) ? target.name : target;
      if (tableName.indexOf(".") === -1) {
        const schemaResult = yield this.query(`SELECT current_schema()`);
        const schema = schemaResult[0]["current_schema"];
        return `${schema}.${tableName}`;
      } else {
        return `${tableName.split(".")[0]}.${tableName.split(".")[1]}`;
      }
    });
  }
  /**
   * Builds a query for create column.
   */
  buildCreateColumnSql(table, column) {
    let c = '"' + column.name + '"';
    if (column.isGenerated === true && column.generationStrategy !== "uuid") {
      if (column.generationStrategy === "identity") {
        const generatedIdentityOrDefault = column.generatedIdentity || "BY DEFAULT";
        c += ` ${column.type} GENERATED ${generatedIdentityOrDefault} AS IDENTITY`;
      } else {
        if (column.type === "integer" || column.type === "int" || column.type === "int4") c += " SERIAL";
        if (column.type === "smallint" || column.type === "int2") c += " SMALLSERIAL";
        if (column.type === "bigint" || column.type === "int8") c += " BIGSERIAL";
      }
    }
    if (column.type === "enum" || column.type === "simple-enum") {
      c += " " + this.buildEnumName(table, column);
      if (column.isArray) c += " array";
    } else if (!column.isGenerated || column.type === "uuid") {
      c += " " + this.connection.driver.createFullType(column);
    }
    if (column.generatedType === "STORED" && column.asExpression) {
      c += ` GENERATED ALWAYS AS (${column.asExpression}) STORED`;
    }
    if (column.charset) c += ' CHARACTER SET "' + column.charset + '"';
    if (column.collation) c += ' COLLATE "' + column.collation + '"';
    if (column.isNullable !== true) c += " NOT NULL";
    if (column.default !== void 0 && column.default !== null) c += " DEFAULT " + column.default;
    if (column.isGenerated && column.generationStrategy === "uuid" && !column.default) c += ` DEFAULT ${this.driver.uuidGenerator}`;
    return c;
  }
  /**
   * Checks if the PostgreSQL server has support for partitioned tables
   */
  hasSupportForPartitionedTables() {
    return __async(this, null, function* () {
      const result = yield this.query(`SELECT TRUE FROM information_schema.columns WHERE table_name = 'pg_class' and column_name = 'relispartition'`);
      return result.length ? true : false;
    });
  }
  /**
   * Change table comment.
   */
  changeTableComment(tableOrName, newComment) {
    return __async(this, null, function* () {
      const upQueries = [];
      const downQueries = [];
      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield this.getCachedTable(tableOrName);
      newComment = this.escapeComment(newComment);
      const comment = this.escapeComment(table.comment);
      if (newComment === comment) {
        return;
      }
      const newTable = table.clone();
      upQueries.push(new Query(`COMMENT ON TABLE ${this.escapePath(newTable)} IS ${newComment}`));
      downQueries.push(new Query(`COMMENT ON TABLE ${this.escapePath(table)} IS ${comment}`));
      yield this.executeQueries(upQueries, downQueries);
      table.comment = newTable.comment;
      this.replaceCachedTable(table, newTable);
    });
  }
};

// ../node_modules/typeorm/browser/driver/aurora-postgres/AuroraPostgresQueryRunner.js
var PostgresQueryRunnerWrapper = class extends PostgresQueryRunner {
  constructor(driver, mode) {
    super(driver, mode);
  }
};
var AuroraPostgresQueryRunner = class extends PostgresQueryRunnerWrapper {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(driver, client, mode) {
    super(driver, mode);
    this.client = client;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates/uses database connection from the connection pool to perform further operations.
   * Returns obtained database connection.
   */
  connect() {
    if (this.databaseConnection) return Promise.resolve(this.databaseConnection);
    if (this.databaseConnectionPromise) return this.databaseConnectionPromise;
    if (this.mode === "slave" && this.driver.isReplicated) {
      this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then(([connection, release]) => {
        this.driver.connectedQueryRunners.push(this);
        this.databaseConnection = connection;
        this.releaseCallback = release;
        return this.databaseConnection;
      });
    } else {
      this.databaseConnectionPromise = this.driver.obtainMasterConnection().then(([connection, release]) => {
        this.driver.connectedQueryRunners.push(this);
        this.databaseConnection = connection;
        this.releaseCallback = release;
        return this.databaseConnection;
      });
    }
    return this.databaseConnectionPromise;
  }
  /**
   * Starts transaction on the current connection.
   */
  startTransaction(isolationLevel) {
    return __async(this, null, function* () {
      this.isTransactionActive = true;
      try {
        yield this.broadcaster.broadcast("BeforeTransactionStart");
      } catch (err) {
        this.isTransactionActive = false;
        throw err;
      }
      if (this.transactionDepth === 0) {
        this.transactionDepth += 1;
        yield this.client.startTransaction();
      } else {
        this.transactionDepth += 1;
        yield this.query(`SAVEPOINT typeorm_${this.transactionDepth} - 1`);
      }
      yield this.broadcaster.broadcast("AfterTransactionStart");
    });
  }
  /**
   * Commits transaction.
   * Error will be thrown if transaction was not started.
   */
  commitTransaction() {
    return __async(this, null, function* () {
      if (!this.isTransactionActive) throw new TransactionNotStartedError();
      yield this.broadcaster.broadcast("BeforeTransactionCommit");
      if (this.transactionDepth > 1) {
        this.transactionDepth -= 1;
        yield this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth}`);
      } else {
        this.transactionDepth -= 1;
        yield this.client.commitTransaction();
        this.isTransactionActive = false;
      }
      yield this.broadcaster.broadcast("AfterTransactionCommit");
    });
  }
  /**
   * Rollbacks transaction.
   * Error will be thrown if transaction was not started.
   */
  rollbackTransaction() {
    return __async(this, null, function* () {
      if (!this.isTransactionActive) throw new TransactionNotStartedError();
      yield this.broadcaster.broadcast("BeforeTransactionRollback");
      if (this.transactionDepth > 1) {
        this.transactionDepth -= 1;
        yield this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth}`);
      } else {
        this.transactionDepth -= 1;
        yield this.client.rollbackTransaction();
        this.isTransactionActive = false;
      }
      yield this.broadcaster.broadcast("AfterTransactionRollback");
    });
  }
  /**
   * Executes a given SQL query.
   */
  query(query, parameters, useStructuredResult = false) {
    return __async(this, null, function* () {
      if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();
      const raw = yield this.client.query(query, parameters);
      const result = new QueryResult();
      result.raw = raw;
      if (raw?.hasOwnProperty("records") && Array.isArray(raw.records)) {
        result.records = raw.records;
      }
      if (raw?.hasOwnProperty("numberOfRecordsUpdated")) {
        result.affected = raw.numberOfRecordsUpdated;
      }
      if (!useStructuredResult) {
        return result.raw;
      }
      return result;
    });
  }
  /**
   * Change table comment.
   */
  changeTableComment(tableOrName, comment) {
    throw new TypeORMError(`aurora-postgres driver does not support change comment.`);
  }
};

// ../node_modules/typeorm/browser/driver/aurora-postgres/AuroraPostgresDriver.js
var PostgresWrapper = class extends PostgresDriver {
};
var AuroraPostgresDriver2 = class extends PostgresWrapper {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    super();
    this.transactionSupport = "nested";
    this.connection = connection;
    this.options = connection.options;
    this.isReplicated = false;
    this.loadDependencies();
    this.client = new this.DataApiDriver(this.options.region, this.options.secretArn, this.options.resourceArn, this.options.database, (query, parameters) => this.connection.logger.logQuery(query, parameters), this.options.serviceConfigOptions, this.options.formatOptions);
    this.database = DriverUtils.buildDriverOptions(this.options).database;
  }
  // -------------------------------------------------------------------------
  // Public Implemented Methods
  // -------------------------------------------------------------------------
  /**
   * Performs connection to the database.
   * Based on pooling options, it can either create connection immediately,
   * either create a pool and create connection when needed.
   */
  connect() {
    return __async(this, null, function* () {
    });
  }
  /**
   * Closes connection with database.
   */
  disconnect() {
    return __async(this, null, function* () {
    });
  }
  /**
   * Creates a query runner used to execute database queries.
   */
  createQueryRunner(mode) {
    return new AuroraPostgresQueryRunner(this, new this.DataApiDriver(this.options.region, this.options.secretArn, this.options.resourceArn, this.options.database, (query, parameters) => this.connection.logger.logQuery(query, parameters), this.options.serviceConfigOptions, this.options.formatOptions), mode);
  }
  /**
   * Prepares given value to a value to be persisted, based on its column type and metadata.
   */
  preparePersistentValue(value, columnMetadata) {
    if (this.options.formatOptions && this.options.formatOptions.castParameters === false) {
      return super.preparePersistentValue(value, columnMetadata);
    }
    if (columnMetadata.transformer) value = ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
    return this.client.preparePersistentValue(value, columnMetadata);
  }
  /**
   * Prepares given value to a value to be persisted, based on its column type and metadata.
   */
  prepareHydratedValue(value, columnMetadata) {
    if (this.options.formatOptions && this.options.formatOptions.castParameters === false) {
      return super.prepareHydratedValue(value, columnMetadata);
    }
    if (columnMetadata.transformer) value = ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
    return this.client.prepareHydratedValue(value, columnMetadata);
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * If driver dependency is not given explicitly, then try to load it via "require".
   */
  loadDependencies() {
    const driver = this.options.driver || PlatformTools.load("typeorm-aurora-data-api-driver");
    const {
      pg
    } = driver;
    this.DataApiDriver = pg;
  }
  /**
   * Executes given query.
   */
  executeQuery(connection, query) {
    return this.connection.query(query);
  }
  /**
   * Makes any action after connection (e.g. create extensions in Postgres driver).
   */
  afterConnect() {
    return __async(this, null, function* () {
      const extensionsMetadata = yield this.checkMetadataForExtensions();
      if (extensionsMetadata.hasExtensions) {
        yield this.enableExtensions(extensionsMetadata, this.connection);
      }
      return Promise.resolve();
    });
  }
};

// ../node_modules/typeorm/browser/driver/capacitor/CapacitorQueryRunner.js
var CapacitorQueryRunner = class extends AbstractSqliteQueryRunner {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(driver) {
    super();
    this.driver = driver;
    this.connection = driver.connection;
    this.broadcaster = new Broadcaster(this);
  }
  /**
   * Called before migrations are run.
   */
  beforeMigration() {
    return __async(this, null, function* () {
      yield this.query(`PRAGMA foreign_keys = OFF`);
    });
  }
  /**
   * Called after migrations are run.
   */
  afterMigration() {
    return __async(this, null, function* () {
      yield this.query(`PRAGMA foreign_keys = ON`);
    });
  }
  executeSet(set) {
    return __async(this, null, function* () {
      if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();
      const databaseConnection = yield this.connect();
      return databaseConnection.executeSet(set, false);
    });
  }
  /**
   * Executes a given SQL query.
   */
  query(query, parameters, useStructuredResult = false) {
    return __async(this, null, function* () {
      if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();
      const databaseConnection = yield this.connect();
      this.driver.connection.logger.logQuery(query, parameters, this);
      const command = query.substring(0, query.indexOf(" ") !== -1 ? query.indexOf(" ") : void 0);
      try {
        let raw;
        if (["BEGIN", "ROLLBACK", "COMMIT", "CREATE", "ALTER", "DROP"].indexOf(command) !== -1) {
          raw = yield databaseConnection.execute(query, false);
        } else if (["INSERT", "UPDATE", "DELETE", "PRAGMA"].indexOf(command) !== -1) {
          raw = yield databaseConnection.run(query, parameters, false);
        } else {
          raw = yield databaseConnection.query(query, parameters || []);
        }
        const result = new QueryResult();
        if (raw?.hasOwnProperty("values")) {
          result.raw = raw.values;
          result.records = raw.values;
        }
        if (raw?.hasOwnProperty("changes")) {
          result.affected = raw.changes.changes;
          result.raw = raw.changes.lastId || raw.changes.changes;
        }
        if (!useStructuredResult) {
          return result.raw;
        }
        return result;
      } catch (err) {
        this.driver.connection.logger.logQueryError(err, query, parameters, this);
        throw new QueryFailedError(query, parameters, err);
      }
    });
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Parametrizes given object of values. Used to create column=value queries.
   */
  parametrize(objectLiteral) {
    return Object.keys(objectLiteral).map((key) => `"${key}"=?`);
  }
};

// ../node_modules/typeorm/browser/driver/capacitor/CapacitorDriver.js
var CapacitorDriver = class extends AbstractSqliteDriver {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    super(connection);
    this.database = this.options.database;
    this.driver = this.options.driver;
    this.sqlite = this.options.driver;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Performs connection to the database.
   */
  connect() {
    return __async(this, null, function* () {
      this.databaseConnection = this.createDatabaseConnection();
      yield this.databaseConnection;
    });
  }
  /**
   * Closes connection with database.
   */
  disconnect() {
    return __async(this, null, function* () {
      this.queryRunner = void 0;
      const databaseConnection = yield this.databaseConnection;
      return databaseConnection.close().then(() => {
        this.databaseConnection = void 0;
      });
    });
  }
  /**
   * Creates a query runner used to execute database queries.
   */
  createQueryRunner(mode) {
    if (!this.queryRunner) this.queryRunner = new CapacitorQueryRunner(this);
    return this.queryRunner;
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Creates connection with the database.
   */
  createDatabaseConnection() {
    return __async(this, null, function* () {
      const databaseMode = this.options.mode || "no-encryption";
      const isDatabaseEncryted = databaseMode !== "no-encryption";
      const databaseVersion = typeof this.options.version === "undefined" ? 1 : this.options.version;
      const connection = yield this.sqlite.createConnection(this.options.database, isDatabaseEncryted, databaseMode, databaseVersion);
      yield connection.open();
      yield connection.run(`PRAGMA foreign_keys = ON`);
      if (this.options.journalMode && ["DELETE", "TRUNCATE", "PERSIST", "MEMORY", "WAL", "OFF"].indexOf(this.options.journalMode) !== -1) {
        yield connection.run(`PRAGMA journal_mode = ${this.options.journalMode}`);
      }
      return connection;
    });
  }
  loadDependencies() {
    this.sqlite = this.driver;
    if (!this.driver) {
      throw new DriverPackageNotInstalledError("Capacitor", "@capacitor-community/sqlite");
    }
  }
};

// ../node_modules/typeorm/browser/driver/spanner/SpannerQueryRunner.js
var SpannerQueryRunner = class extends BaseQueryRunner {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(driver, mode) {
    super();
    this.driver = driver;
    this.connection = driver.connection;
    this.mode = mode;
    this.broadcaster = new Broadcaster(this);
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates/uses database connection from the connection pool to perform further operations.
   * Returns obtained database connection.
   */
  connect() {
    return __async(this, null, function* () {
      if (this.session) {
        return Promise.resolve(this.session);
      }
      const [session] = yield this.driver.instanceDatabase.createSession({});
      this.session = session;
      this.sessionTransaction = yield session.transaction();
      return this.session;
    });
  }
  /**
   * Releases used database connection.
   * You cannot use query runner methods once its released.
   */
  release() {
    return __async(this, null, function* () {
      this.isReleased = true;
      if (this.session) {
        yield this.session.delete();
      }
      this.session = void 0;
      return Promise.resolve();
    });
  }
  /**
   * Starts transaction.
   */
  startTransaction(isolationLevel) {
    return __async(this, null, function* () {
      this.isTransactionActive = true;
      try {
        yield this.broadcaster.broadcast("BeforeTransactionStart");
      } catch (err) {
        this.isTransactionActive = false;
        throw err;
      }
      yield this.connect();
      yield this.sessionTransaction.begin();
      this.connection.logger.logQuery("START TRANSACTION");
      yield this.broadcaster.broadcast("AfterTransactionStart");
    });
  }
  /**
   * Commits transaction.
   * Error will be thrown if transaction was not started.
   */
  commitTransaction() {
    return __async(this, null, function* () {
      if (!this.isTransactionActive || !this.sessionTransaction) throw new TransactionNotStartedError();
      yield this.broadcaster.broadcast("BeforeTransactionCommit");
      yield this.sessionTransaction.commit();
      this.connection.logger.logQuery("COMMIT");
      this.isTransactionActive = false;
      yield this.broadcaster.broadcast("AfterTransactionCommit");
    });
  }
  /**
   * Rollbacks transaction.
   * Error will be thrown if transaction was not started.
   */
  rollbackTransaction() {
    return __async(this, null, function* () {
      if (!this.isTransactionActive || !this.sessionTransaction) throw new TransactionNotStartedError();
      yield this.broadcaster.broadcast("BeforeTransactionRollback");
      yield this.sessionTransaction.rollback();
      this.connection.logger.logQuery("ROLLBACK");
      this.isTransactionActive = false;
      yield this.broadcaster.broadcast("AfterTransactionRollback");
    });
  }
  /**
   * Executes a given SQL query.
   */
  query(query, parameters, useStructuredResult = false) {
    return __async(this, null, function* () {
      if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();
      const broadcasterResult = new BroadcasterResult();
      try {
        const queryStartTime = +/* @__PURE__ */ new Date();
        yield this.connect();
        let rawResult = void 0;
        const isSelect = query.startsWith("SELECT");
        const executor = isSelect && !this.isTransactionActive ? this.driver.instanceDatabase : this.sessionTransaction;
        if (!this.isTransactionActive && !isSelect) {
          yield this.sessionTransaction.begin();
        }
        try {
          this.driver.connection.logger.logQuery(query, parameters, this);
          this.broadcaster.broadcastBeforeQueryEvent(broadcasterResult, query, parameters);
          rawResult = yield executor.run({
            sql: query,
            params: parameters ? parameters.reduce((params, value, index) => {
              params["param" + index] = value;
              return params;
            }, {}) : void 0,
            json: true
          });
          if (!this.isTransactionActive && !isSelect) {
            yield this.sessionTransaction.commit();
          }
        } catch (error) {
          try {
            if (!this.isTransactionActive && !isSelect) yield this.sessionTransaction.rollback();
          } catch (rollbackError) {
          }
          throw error;
        }
        const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
        const queryEndTime = +/* @__PURE__ */ new Date();
        const queryExecutionTime = queryEndTime - queryStartTime;
        this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, rawResult, void 0);
        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
        const result = new QueryResult();
        result.raw = rawResult;
        result.records = rawResult ? rawResult[0] : [];
        if (rawResult && rawResult[1] && rawResult[1].rowCountExact) {
          result.affected = parseInt(rawResult[1].rowCountExact);
        }
        if (!useStructuredResult) {
          return result.records;
        }
        return result;
      } catch (err) {
        this.driver.connection.logger.logQueryError(err, query, parameters, this);
        this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
        throw new QueryFailedError(query, parameters, err);
      } finally {
        yield broadcasterResult.wait();
      }
    });
  }
  /**
   * Update database schema.
   * Used for creating/altering/dropping tables, columns, indexes, etc.
   *
   * DDL changing queries should be executed by `updateSchema()` method.
   */
  updateDDL(query, parameters) {
    return __async(this, null, function* () {
      if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();
      this.driver.connection.logger.logQuery(query, parameters, this);
      try {
        const queryStartTime = +/* @__PURE__ */ new Date();
        const [operation] = yield this.driver.instanceDatabase.updateSchema(query);
        yield operation.promise();
        const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
        const queryEndTime = +/* @__PURE__ */ new Date();
        const queryExecutionTime = queryEndTime - queryStartTime;
        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
      } catch (err) {
        this.driver.connection.logger.logQueryError(err, query, parameters, this);
        throw new QueryFailedError(query, parameters, err);
      }
    });
  }
  /**
   * Returns raw data stream.
   */
  stream(query, parameters, onEnd, onError) {
    return __async(this, null, function* () {
      if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();
      try {
        this.driver.connection.logger.logQuery(query, parameters, this);
        const request = {
          sql: query,
          params: parameters ? parameters.reduce((params, value, index) => {
            params["param" + index] = value;
            return params;
          }, {}) : void 0,
          json: true
        };
        const stream = this.driver.instanceDatabase.runStream(request);
        if (onEnd) {
          stream.on("end", onEnd);
        }
        if (onError) {
          stream.on("error", onError);
        }
        return stream;
      } catch (err) {
        this.driver.connection.logger.logQueryError(err, query, parameters, this);
        throw new QueryFailedError(query, parameters, err);
      }
    });
  }
  /**
   * Returns all available database names including system databases.
   */
  getDatabases() {
    return __async(this, null, function* () {
      return Promise.resolve([]);
    });
  }
  /**
   * Returns all available schema names including system schemas.
   * If database parameter specified, returns schemas of that database.
   */
  getSchemas(database) {
    return __async(this, null, function* () {
      return Promise.resolve([]);
    });
  }
  /**
   * Checks if database with the given name exist.
   */
  hasDatabase(database) {
    return __async(this, null, function* () {
      throw new TypeORMError(`Check database queries are not supported by Spanner driver.`);
    });
  }
  /**
   * Loads currently using database
   */
  getCurrentDatabase() {
    return __async(this, null, function* () {
      throw new TypeORMError(`Check database queries are not supported by Spanner driver.`);
    });
  }
  /**
   * Checks if schema with the given name exist.
   */
  hasSchema(schema) {
    return __async(this, null, function* () {
      const result = yield this.query(`SELECT * FROM "information_schema"."schemata" WHERE "schema_name" = '${schema}'`);
      return result.length ? true : false;
    });
  }
  /**
   * Loads currently using database schema
   */
  getCurrentSchema() {
    return __async(this, null, function* () {
      throw new TypeORMError(`Check schema queries are not supported by Spanner driver.`);
    });
  }
  /**
   * Checks if table with the given name exist in the database.
   */
  hasTable(tableOrName) {
    return __async(this, null, function* () {
      const tableName = tableOrName instanceof Table ? tableOrName.name : tableOrName;
      const sql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`TABLES\` WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`TABLE_TYPE\` = 'BASE TABLE' AND \`TABLE_NAME\` = '${tableName}'`;
      const result = yield this.query(sql);
      return result.length ? true : false;
    });
  }
  /**
   * Checks if column with the given name exist in the given table.
   */
  hasColumn(tableOrName, columnName) {
    return __async(this, null, function* () {
      const tableName = tableOrName instanceof Table ? tableOrName.name : tableOrName;
      const sql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`COLUMNS\` WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`TABLE_NAME\` = '${tableName}' AND \`COLUMN_NAME\` = '${columnName}'`;
      const result = yield this.query(sql);
      return result.length ? true : false;
    });
  }
  /**
   * Creates a new database.
   * Note: Spanner does not support database creation inside a transaction block.
   */
  createDatabase(database, ifNotExist) {
    return __async(this, null, function* () {
      if (ifNotExist) {
        const databaseAlreadyExists = yield this.hasDatabase(database);
        if (databaseAlreadyExists) return Promise.resolve();
      }
      const up = `CREATE DATABASE "${database}"`;
      const down = `DROP DATABASE "${database}"`;
      yield this.executeQueries(new Query(up), new Query(down));
    });
  }
  /**
   * Drops database.
   * Note: Spanner does not support database dropping inside a transaction block.
   */
  dropDatabase(database, ifExist) {
    return __async(this, null, function* () {
      const up = ifExist ? `DROP DATABASE IF EXISTS "${database}"` : `DROP DATABASE "${database}"`;
      const down = `CREATE DATABASE "${database}"`;
      yield this.executeQueries(new Query(up), new Query(down));
    });
  }
  /**
   * Creates a new table schema.
   */
  createSchema(schemaPath, ifNotExist) {
    return __async(this, null, function* () {
      return Promise.resolve();
    });
  }
  /**
   * Drops table schema.
   */
  dropSchema(schemaPath, ifExist, isCascade) {
    return __async(this, null, function* () {
      return Promise.resolve();
    });
  }
  /**
   * Creates a new table.
   */
  createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {
    return __async(this, null, function* () {
      if (ifNotExist) {
        const isTableExist = yield this.hasTable(table);
        if (isTableExist) return Promise.resolve();
      }
      const upQueries = [];
      const downQueries = [];
      upQueries.push(this.createTableSql(table, createForeignKeys));
      downQueries.push(this.dropTableSql(table));
      if (createForeignKeys) table.foreignKeys.forEach((foreignKey) => downQueries.push(this.dropForeignKeySql(table, foreignKey)));
      if (createIndices) {
        table.indices.forEach((index) => {
          if (!index.name) index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
          upQueries.push(this.createIndexSql(table, index));
          downQueries.push(this.dropIndexSql(table, index));
        });
      }
      const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
      for (const column of generatedColumns) {
        const insertQuery = this.insertTypeormMetadataSql({
          table: table.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name,
          value: column.asExpression
        });
        const deleteQuery = this.deleteTypeormMetadataSql({
          table: table.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name
        });
        upQueries.push(insertQuery);
        downQueries.push(deleteQuery);
      }
      yield this.executeQueries(upQueries, downQueries);
    });
  }
  /**
   * Drops the table.
   */
  dropTable(target, ifExist, dropForeignKeys = true, dropIndices = true) {
    return __async(this, null, function* () {
      if (ifExist) {
        const isTableExist = yield this.hasTable(target);
        if (!isTableExist) return Promise.resolve();
      }
      const createForeignKeys = dropForeignKeys;
      const tablePath = this.getTablePath(target);
      const table = yield this.getCachedTable(tablePath);
      const upQueries = [];
      const downQueries = [];
      if (dropIndices) {
        table.indices.forEach((index) => {
          upQueries.push(this.dropIndexSql(table, index));
          downQueries.push(this.createIndexSql(table, index));
        });
      }
      if (dropForeignKeys) table.foreignKeys.forEach((foreignKey) => upQueries.push(this.dropForeignKeySql(table, foreignKey)));
      upQueries.push(this.dropTableSql(table));
      downQueries.push(this.createTableSql(table, createForeignKeys));
      const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
      for (const column of generatedColumns) {
        const deleteQuery = this.deleteTypeormMetadataSql({
          table: table.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name
        });
        const insertQuery = this.insertTypeormMetadataSql({
          table: table.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name,
          value: column.asExpression
        });
        upQueries.push(deleteQuery);
        downQueries.push(insertQuery);
      }
      yield this.executeQueries(upQueries, downQueries);
    });
  }
  /**
   * Creates a new view.
   */
  createView(view) {
    return __async(this, null, function* () {
      const upQueries = [];
      const downQueries = [];
      upQueries.push(this.createViewSql(view));
      upQueries.push(yield this.insertViewDefinitionSql(view));
      downQueries.push(this.dropViewSql(view));
      downQueries.push(yield this.deleteViewDefinitionSql(view));
      yield this.executeQueries(upQueries, downQueries);
    });
  }
  /**
   * Drops the view.
   */
  dropView(target) {
    return __async(this, null, function* () {
      const viewName = target instanceof View ? target.name : target;
      const view = yield this.getCachedView(viewName);
      const upQueries = [];
      const downQueries = [];
      upQueries.push(yield this.deleteViewDefinitionSql(view));
      upQueries.push(this.dropViewSql(view));
      downQueries.push(yield this.insertViewDefinitionSql(view));
      downQueries.push(this.createViewSql(view));
      yield this.executeQueries(upQueries, downQueries);
    });
  }
  /**
   * Renames the given table.
   */
  renameTable(oldTableOrName, newTableName) {
    return __async(this, null, function* () {
      throw new TypeORMError(`Rename table queries are not supported by Spanner driver.`);
    });
  }
  /**
   * Creates a new column from the column in the table.
   */
  addColumn(tableOrName, column) {
    return __async(this, null, function* () {
      const table = tableOrName instanceof Table ? tableOrName : yield this.getCachedTable(tableOrName);
      const clonedTable = table.clone();
      const upQueries = [];
      const downQueries = [];
      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column)}`));
      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN ${this.driver.escape(column.name)}`));
      const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
      if (columnIndex) {
        upQueries.push(this.createIndexSql(table, columnIndex));
        downQueries.push(this.dropIndexSql(table, columnIndex));
      } else if (column.isUnique) {
        const uniqueIndex = new TableIndex({
          name: this.connection.namingStrategy.indexName(table, [column.name]),
          columnNames: [column.name],
          isUnique: true
        });
        clonedTable.indices.push(uniqueIndex);
        clonedTable.uniques.push(new TableUnique({
          name: uniqueIndex.name,
          columnNames: uniqueIndex.columnNames
        }));
        upQueries.push(this.createIndexSql(table, uniqueIndex));
        downQueries.push(this.dropIndexSql(table, uniqueIndex));
      }
      if (column.generatedType && column.asExpression) {
        const insertQuery = this.insertTypeormMetadataSql({
          table: table.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name,
          value: column.asExpression
        });
        const deleteQuery = this.deleteTypeormMetadataSql({
          table: table.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name
        });
        upQueries.push(insertQuery);
        downQueries.push(deleteQuery);
      }
      yield this.executeQueries(upQueries, downQueries);
      clonedTable.addColumn(column);
      this.replaceCachedTable(table, clonedTable);
    });
  }
  /**
   * Creates a new columns from the column in the table.
   */
  addColumns(tableOrName, columns) {
    return __async(this, null, function* () {
      for (const column of columns) {
        yield this.addColumn(tableOrName, column);
      }
    });
  }
  /**
   * Renames column in the given table.
   */
  renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
    return __async(this, null, function* () {
      const table = tableOrName instanceof Table ? tableOrName : yield this.getCachedTable(tableOrName);
      const oldColumn = oldTableColumnOrName instanceof TableColumn ? oldTableColumnOrName : table.columns.find((c) => c.name === oldTableColumnOrName);
      if (!oldColumn) throw new TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
      let newColumn;
      if (newTableColumnOrName instanceof TableColumn) {
        newColumn = newTableColumnOrName;
      } else {
        newColumn = oldColumn.clone();
        newColumn.name = newTableColumnOrName;
      }
      return this.changeColumn(table, oldColumn, newColumn);
    });
  }
  /**
   * Changes a column in the table.
   */
  changeColumn(tableOrName, oldTableColumnOrName, newColumn) {
    return __async(this, null, function* () {
      const table = tableOrName instanceof Table ? tableOrName : yield this.getCachedTable(tableOrName);
      let clonedTable = table.clone();
      const upQueries = [];
      const downQueries = [];
      const oldColumn = oldTableColumnOrName instanceof TableColumn ? oldTableColumnOrName : table.columns.find((column) => column.name === oldTableColumnOrName);
      if (!oldColumn) throw new TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
      if (oldColumn.name !== newColumn.name || oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || oldColumn.isArray !== newColumn.isArray || oldColumn.generatedType !== newColumn.generatedType || oldColumn.asExpression !== newColumn.asExpression) {
        yield this.dropColumn(table, oldColumn);
        yield this.addColumn(table, newColumn);
        clonedTable = table.clone();
      } else {
        if (newColumn.precision !== oldColumn.precision || newColumn.scale !== oldColumn.scale) {
          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(newColumn)}`));
          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(oldColumn)}`));
        }
        if (oldColumn.isNullable !== newColumn.isNullable) {
          if (newColumn.isNullable) {
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP NOT NULL`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET NOT NULL`));
          } else {
            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET NOT NULL`));
            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP NOT NULL`));
          }
        }
        if (newColumn.isUnique !== oldColumn.isUnique) {
          if (newColumn.isUnique === true) {
            const uniqueIndex = new TableIndex({
              name: this.connection.namingStrategy.indexName(table, [newColumn.name]),
              columnNames: [newColumn.name],
              isUnique: true
            });
            clonedTable.indices.push(uniqueIndex);
            clonedTable.uniques.push(new TableUnique({
              name: uniqueIndex.name,
              columnNames: uniqueIndex.columnNames
            }));
            upQueries.push(this.createIndexSql(table, uniqueIndex));
            downQueries.push(this.dropIndexSql(table, uniqueIndex));
          } else {
            const uniqueIndex = clonedTable.indices.find((index) => {
              return index.columnNames.length === 1 && index.isUnique === true && !!index.columnNames.find((columnName) => columnName === newColumn.name);
            });
            clonedTable.indices.splice(clonedTable.indices.indexOf(uniqueIndex), 1);
            const tableUnique = clonedTable.uniques.find((unique) => unique.name === uniqueIndex.name);
            clonedTable.uniques.splice(clonedTable.uniques.indexOf(tableUnique), 1);
            upQueries.push(this.dropIndexSql(table, uniqueIndex));
            downQueries.push(this.createIndexSql(table, uniqueIndex));
          }
        }
      }
      yield this.executeQueries(upQueries, downQueries);
      this.replaceCachedTable(table, clonedTable);
    });
  }
  /**
   * Changes a column in the table.
   */
  changeColumns(tableOrName, changedColumns) {
    return __async(this, null, function* () {
      for (const {
        oldColumn,
        newColumn
      } of changedColumns) {
        yield this.changeColumn(tableOrName, oldColumn, newColumn);
      }
    });
  }
  /**
   * Drops column in the table.
   */
  dropColumn(tableOrName, columnOrName) {
    return __async(this, null, function* () {
      const table = tableOrName instanceof Table ? tableOrName : yield this.getCachedTable(tableOrName);
      const column = columnOrName instanceof TableColumn ? columnOrName : table.findColumnByName(columnOrName);
      if (!column) throw new TypeORMError(`Column "${columnOrName}" was not found in table "${table.name}"`);
      const clonedTable = table.clone();
      const upQueries = [];
      const downQueries = [];
      const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
      if (columnIndex) {
        clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);
        upQueries.push(this.dropIndexSql(table, columnIndex));
        downQueries.push(this.createIndexSql(table, columnIndex));
      }
      const columnCheck = clonedTable.checks.find((check) => !!check.columnNames && check.columnNames.length === 1 && check.columnNames[0] === column.name);
      if (columnCheck) {
        clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);
        upQueries.push(this.dropCheckConstraintSql(table, columnCheck));
        downQueries.push(this.createCheckConstraintSql(table, columnCheck));
      }
      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN ${this.driver.escape(column.name)}`));
      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column)}`));
      if (column.generatedType && column.asExpression) {
        const deleteQuery = this.deleteTypeormMetadataSql({
          table: table.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name
        });
        const insertQuery = this.insertTypeormMetadataSql({
          table: table.name,
          type: MetadataTableType.GENERATED_COLUMN,
          name: column.name,
          value: column.asExpression
        });
        upQueries.push(deleteQuery);
        downQueries.push(insertQuery);
      }
      yield this.executeQueries(upQueries, downQueries);
      clonedTable.removeColumn(column);
      this.replaceCachedTable(table, clonedTable);
    });
  }
  /**
   * Drops the columns in the table.
   */
  dropColumns(tableOrName, columns) {
    return __async(this, null, function* () {
      for (const column of columns) {
        yield this.dropColumn(tableOrName, column);
      }
    });
  }
  /**
   * Creates a new primary key.
   *
   * Not supported in Spanner.
   * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns
   */
  createPrimaryKey(tableOrName, columnNames) {
    return __async(this, null, function* () {
      throw new Error("The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.");
    });
  }
  /**
   * Updates composite primary keys.
   */
  updatePrimaryKeys(tableOrName, columns) {
    return __async(this, null, function* () {
      throw new Error("The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.");
    });
  }
  /**
   * Creates a new primary key.
   *
   * Not supported in Spanner.
   * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns
   */
  dropPrimaryKey(tableOrName) {
    return __async(this, null, function* () {
      throw new Error("The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.");
    });
  }
  /**
   * Creates new unique constraint.
   */
  createUniqueConstraint(tableOrName, uniqueConstraint) {
    return __async(this, null, function* () {
      throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);
    });
  }
  /**
   * Creates new unique constraints.
   */
  createUniqueConstraints(tableOrName, uniqueConstraints) {
    return __async(this, null, function* () {
      throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);
    });
  }
  /**
   * Drops unique constraint.
   */
  dropUniqueConstraint(tableOrName, uniqueOrName) {
    return __async(this, null, function* () {
      throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);
    });
  }
  /**
   * Drops unique constraints.
   */
  dropUniqueConstraints(tableOrName, uniqueConstraints) {
    return __async(this, null, function* () {
      throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);
    });
  }
  /**
   * Creates new check constraint.
   */
  createCheckConstraint(tableOrName, checkConstraint) {
    return __async(this, null, function* () {
      const table = tableOrName instanceof Table ? tableOrName : yield this.getCachedTable(tableOrName);
      if (!checkConstraint.name) checkConstraint.name = this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);
      const up = this.createCheckConstraintSql(table, checkConstraint);
      const down = this.dropCheckConstraintSql(table, checkConstraint);
      yield this.executeQueries(up, down);
      table.addCheckConstraint(checkConstraint);
    });
  }
  /**
   * Creates new check constraints.
   */
  createCheckConstraints(tableOrName, checkConstraints) {
    return __async(this, null, function* () {
      const promises = checkConstraints.map((checkConstraint) => this.createCheckConstraint(tableOrName, checkConstraint));
      yield Promise.all(promises);
    });
  }
  /**
   * Drops check constraint.
   */
  dropCheckConstraint(tableOrName, checkOrName) {
    return __async(this, null, function* () {
      const table = tableOrName instanceof Table ? tableOrName : yield this.getCachedTable(tableOrName);
      const checkConstraint = checkOrName instanceof TableCheck ? checkOrName : table.checks.find((c) => c.name === checkOrName);
      if (!checkConstraint) throw new TypeORMError(`Supplied check constraint was not found in table ${table.name}`);
      const up = this.dropCheckConstraintSql(table, checkConstraint);
      const down = this.createCheckConstraintSql(table, checkConstraint);
      yield this.executeQueries(up, down);
      table.removeCheckConstraint(checkConstraint);
    });
  }
  /**
   * Drops check constraints.
   */
  dropCheckConstraints(tableOrName, checkConstraints) {
    return __async(this, null, function* () {
      const promises = checkConstraints.map((checkConstraint) => this.dropCheckConstraint(tableOrName, checkConstraint));
      yield Promise.all(promises);
    });
  }
  /**
   * Creates new exclusion constraint.
   */
  createExclusionConstraint(tableOrName, exclusionConstraint) {
    return __async(this, null, function* () {
      throw new TypeORMError(`Spanner does not support exclusion constraints.`);
    });
  }
  /**
   * Creates new exclusion constraints.
   */
  createExclusionConstraints(tableOrName, exclusionConstraints) {
    return __async(this, null, function* () {
      throw new TypeORMError(`Spanner does not support exclusion constraints.`);
    });
  }
  /**
   * Drops exclusion constraint.
   */
  dropExclusionConstraint(tableOrName, exclusionOrName) {
    return __async(this, null, function* () {
      throw new TypeORMError(`Spanner does not support exclusion constraints.`);
    });
  }
  /**
   * Drops exclusion constraints.
   */
  dropExclusionConstraints(tableOrName, exclusionConstraints) {
    return __async(this, null, function* () {
      throw new TypeORMError(`Spanner does not support exclusion constraints.`);
    });
  }
  /**
   * Creates a new foreign key.
   */
  createForeignKey(tableOrName, foreignKey) {
    return __async(this, null, function* () {
      const table = tableOrName instanceof Table ? tableOrName : yield this.getCachedTable(tableOrName);
      if (!foreignKey.name) foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
      const up = this.createForeignKeySql(table, foreignKey);
      const down = this.dropForeignKeySql(table, foreignKey);
      yield this.executeQueries(up, down);
      table.addForeignKey(foreignKey);
    });
  }
  /**
   * Creates a new foreign keys.
   */
  createForeignKeys(tableOrName, foreignKeys) {
    return __async(this, null, function* () {
      for (const foreignKey of foreignKeys) {
        yield this.createForeignKey(tableOrName, foreignKey);
      }
    });
  }
  /**
   * Drops a foreign key from the table.
   */
  dropForeignKey(tableOrName, foreignKeyOrName) {
    return __async(this, null, function* () {
      const table = tableOrName instanceof Table ? tableOrName : yield this.getCachedTable(tableOrName);
      const foreignKey = foreignKeyOrName instanceof TableForeignKey ? foreignKeyOrName : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName);
      if (!foreignKey) throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
      const up = this.dropForeignKeySql(table, foreignKey);
      const down = this.createForeignKeySql(table, foreignKey);
      yield this.executeQueries(up, down);
      table.removeForeignKey(foreignKey);
    });
  }
  /**
   * Drops a foreign keys from the table.
   */
  dropForeignKeys(tableOrName, foreignKeys) {
    return __async(this, null, function* () {
      for (const foreignKey of foreignKeys) {
        yield this.dropForeignKey(tableOrName, foreignKey);
      }
    });
  }
  /**
   * Creates a new index.
   */
  createIndex(tableOrName, index) {
    return __async(this, null, function* () {
      const table = tableOrName instanceof Table ? tableOrName : yield this.getCachedTable(tableOrName);
      if (!index.name) index.name = this.generateIndexName(table, index);
      const up = this.createIndexSql(table, index);
      const down = this.dropIndexSql(table, index);
      yield this.executeQueries(up, down);
      table.addIndex(index);
    });
  }
  /**
   * Creates a new indices
   */
  createIndices(tableOrName, indices) {
    return __async(this, null, function* () {
      for (const index of indices) {
        yield this.createIndex(tableOrName, index);
      }
    });
  }
  /**
   * Drops an index from the table.
   */
  dropIndex(tableOrName, indexOrName) {
    return __async(this, null, function* () {
      const table = tableOrName instanceof Table ? tableOrName : yield this.getCachedTable(tableOrName);
      const index = indexOrName instanceof TableIndex ? indexOrName : table.indices.find((i) => i.name === indexOrName);
      if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);
      if (!index.name) index.name = this.generateIndexName(table, index);
      const up = this.dropIndexSql(table, index);
      const down = this.createIndexSql(table, index);
      yield this.executeQueries(up, down);
      table.removeIndex(index);
    });
  }
  /**
   * Drops an indices from the table.
   */
  dropIndices(tableOrName, indices) {
    return __async(this, null, function* () {
      for (const index of indices) {
        yield this.dropIndex(tableOrName, index);
      }
    });
  }
  /**
   * Clears all table contents.
   * Spanner does not support TRUNCATE TABLE statement, so we use DELETE FROM.
   */
  clearTable(tableName) {
    return __async(this, null, function* () {
      yield this.query(`DELETE FROM ${this.escapePath(tableName)} WHERE true`);
    });
  }
  /**
   * Removes all tables from the currently connected database.
   */
  clearDatabase() {
    return __async(this, null, function* () {
      const selectIndexDropsQuery = `SELECT concat('DROP INDEX \`', INDEX_NAME, '\`') AS \`query\` FROM \`INFORMATION_SCHEMA\`.\`INDEXES\` WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`INDEX_TYPE\` = 'INDEX' AND \`SPANNER_IS_MANAGED\` = false`;
      const dropIndexQueries = yield this.query(selectIndexDropsQuery);
      const selectFKDropsQuery = `SELECT concat('ALTER TABLE \`', TABLE_NAME, '\`', ' DROP CONSTRAINT \`', CONSTRAINT_NAME, '\`') AS \`query\` FROM \`INFORMATION_SCHEMA\`.\`TABLE_CONSTRAINTS\` WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`CONSTRAINT_TYPE\` = 'FOREIGN KEY'`;
      const dropFKQueries = yield this.query(selectFKDropsQuery);
      const dropTablesQuery = `SELECT concat('DROP TABLE \`', TABLE_NAME, '\`') AS \`query\` FROM \`INFORMATION_SCHEMA\`.\`TABLES\` WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`TABLE_TYPE\` = 'BASE TABLE'`;
      const dropTableQueries = yield this.query(dropTablesQuery);
      if (!dropIndexQueries.length && !dropFKQueries.length && // !dropViewQueries.length &&
      !dropTableQueries.length) return;
      const isAnotherTransactionActive = this.isTransactionActive;
      if (!isAnotherTransactionActive) yield this.startTransaction();
      try {
        for (let query of dropIndexQueries) {
          yield this.updateDDL(query["query"]);
        }
        for (let query of dropFKQueries) {
          yield this.updateDDL(query["query"]);
        }
        for (let query of dropTableQueries) {
          yield this.updateDDL(query["query"]);
        }
        yield this.commitTransaction();
      } catch (error) {
        try {
          if (!isAnotherTransactionActive) yield this.rollbackTransaction();
        } catch (rollbackError) {
        }
        throw error;
      }
    });
  }
  // -------------------------------------------------------------------------
  // Override Methods
  // -------------------------------------------------------------------------
  /**
   * Executes up sql queries.
   */
  executeMemoryUpSql() {
    return __async(this, null, function* () {
      for (const {
        query,
        parameters
      } of this.sqlInMemory.upQueries) {
        if (this.isDMLQuery(query)) {
          yield this.query(query, parameters);
        } else {
          yield this.updateDDL(query, parameters);
        }
      }
    });
  }
  /**
   * Executes down sql queries.
   */
  executeMemoryDownSql() {
    return __async(this, null, function* () {
      for (const {
        query,
        parameters
      } of this.sqlInMemory.downQueries.reverse()) {
        if (this.isDMLQuery(query)) {
          yield this.query(query, parameters);
        } else {
          yield this.updateDDL(query, parameters);
        }
      }
    });
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  loadViews(viewNames) {
    return __async(this, null, function* () {
      return Promise.resolve([]);
    });
  }
  /**
   * Loads all tables (with given names) from the database and creates a Table from them.
   */
  loadTables(tableNames) {
    return __async(this, null, function* () {
      if (tableNames && tableNames.length === 0) {
        return [];
      }
      const dbTables = [];
      if (!tableNames || !tableNames.length) {
        const tablesSql = `SELECT \`TABLE_NAME\` FROM \`INFORMATION_SCHEMA\`.\`TABLES\` WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`TABLE_TYPE\` = 'BASE TABLE'`;
        dbTables.push(...yield this.query(tablesSql));
      } else {
        const tablesSql = `SELECT \`TABLE_NAME\` FROM \`INFORMATION_SCHEMA\`.\`TABLES\` WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`TABLE_TYPE\` = 'BASE TABLE' AND \`TABLE_NAME\` IN (${tableNames.map((tableName) => `'${tableName}'`).join(", ")})`;
        dbTables.push(...yield this.query(tablesSql));
      }
      if (!dbTables.length) return [];
      const loadedTableNames = dbTables.map((dbTable) => `'${dbTable.TABLE_NAME}'`).join(", ");
      const columnsSql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`COLUMNS\` WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`TABLE_NAME\` IN (${loadedTableNames})`;
      const primaryKeySql = `SELECT \`KCU\`.\`TABLE_NAME\`, \`KCU\`.\`COLUMN_NAME\` FROM \`INFORMATION_SCHEMA\`.\`TABLE_CONSTRAINTS\` \`TC\` INNER JOIN \`INFORMATION_SCHEMA\`.\`KEY_COLUMN_USAGE\` \`KCU\` ON \`KCU\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` WHERE \`TC\`.\`TABLE_CATALOG\` = '' AND \`TC\`.\`TABLE_SCHEMA\` = '' AND \`TC\`.\`CONSTRAINT_TYPE\` = 'PRIMARY KEY' AND \`TC\`.\`TABLE_NAME\` IN (${loadedTableNames})`;
      const indicesSql = `SELECT \`I\`.\`TABLE_NAME\`, \`I\`.\`INDEX_NAME\`, \`I\`.\`IS_UNIQUE\`, \`I\`.\`IS_NULL_FILTERED\`, \`IC\`.\`COLUMN_NAME\` FROM \`INFORMATION_SCHEMA\`.\`INDEXES\` \`I\` INNER JOIN \`INFORMATION_SCHEMA\`.\`INDEX_COLUMNS\` \`IC\` ON \`IC\`.\`INDEX_NAME\` = \`I\`.\`INDEX_NAME\` AND \`IC\`.\`TABLE_NAME\` = \`I\`.\`TABLE_NAME\` WHERE \`I\`.\`TABLE_CATALOG\` = '' AND \`I\`.\`TABLE_SCHEMA\` = '' AND \`I\`.\`TABLE_NAME\` IN (${loadedTableNames}) AND \`I\`.\`INDEX_TYPE\` = 'INDEX' AND \`I\`.\`SPANNER_IS_MANAGED\` = false`;
      const checksSql = `SELECT \`TC\`.\`TABLE_NAME\`, \`TC\`.\`CONSTRAINT_NAME\`, \`CC\`.\`CHECK_CLAUSE\`, \`CCU\`.\`COLUMN_NAME\`FROM \`INFORMATION_SCHEMA\`.\`TABLE_CONSTRAINTS\` \`TC\` INNER JOIN \`INFORMATION_SCHEMA\`.\`CONSTRAINT_COLUMN_USAGE\` \`CCU\` ON \`CCU\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` INNER JOIN \`INFORMATION_SCHEMA\`.\`CHECK_CONSTRAINTS\` \`CC\` ON \`CC\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` WHERE \`TC\`.\`TABLE_CATALOG\` = '' AND \`TC\`.\`TABLE_SCHEMA\` = '' AND \`TC\`.\`CONSTRAINT_TYPE\` = 'CHECK' AND \`TC\`.\`TABLE_NAME\` IN (${loadedTableNames}) AND \`TC\`.\`CONSTRAINT_NAME\` NOT LIKE 'CK_IS_NOT_NULL%'`;
      const foreignKeysSql = `SELECT \`TC\`.\`TABLE_NAME\`, \`TC\`.\`CONSTRAINT_NAME\`, \`KCU\`.\`COLUMN_NAME\`, \`CTU\`.\`TABLE_NAME\` AS \`REFERENCED_TABLE_NAME\`, \`CCU\`.\`COLUMN_NAME\` AS \`REFERENCED_COLUMN_NAME\`, \`RC\`.\`UPDATE_RULE\`, \`RC\`.\`DELETE_RULE\` FROM \`INFORMATION_SCHEMA\`.\`TABLE_CONSTRAINTS\` \`TC\` INNER JOIN \`INFORMATION_SCHEMA\`.\`KEY_COLUMN_USAGE\` \`KCU\` ON \`KCU\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` INNER JOIN \`INFORMATION_SCHEMA\`.\`CONSTRAINT_TABLE_USAGE\` \`CTU\` ON \`CTU\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` INNER JOIN \`INFORMATION_SCHEMA\`.\`REFERENTIAL_CONSTRAINTS\` \`RC\` ON \`RC\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` INNER JOIN \`INFORMATION_SCHEMA\`.\`CONSTRAINT_COLUMN_USAGE\` \`CCU\` ON \`CCU\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` WHERE \`TC\`.\`TABLE_CATALOG\` = '' AND \`TC\`.\`TABLE_SCHEMA\` = '' AND \`TC\`.\`CONSTRAINT_TYPE\` = 'FOREIGN KEY' AND \`TC\`.\`TABLE_NAME\` IN (${loadedTableNames})`;
      const [dbColumns, dbPrimaryKeys, dbIndices, dbChecks, dbForeignKeys] = yield Promise.all([this.query(columnsSql), this.query(primaryKeySql), this.query(indicesSql), this.query(checksSql), this.query(foreignKeysSql)]);
      return Promise.all(dbTables.map((dbTable) => __async(this, null, function* () {
        const table = new Table();
        table.name = this.driver.buildTableName(dbTable["TABLE_NAME"]);
        table.columns = yield Promise.all(dbColumns.filter((dbColumn) => dbColumn["TABLE_NAME"] === dbTable["TABLE_NAME"]).map((dbColumn) => __async(this, null, function* () {
          const columnUniqueIndices = dbIndices.filter((dbIndex) => {
            return dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbIndex["COLUMN_NAME"] === dbColumn["COLUMN_NAME"] && dbIndex["IS_UNIQUE"] === true;
          });
          const tableMetadata = this.connection.entityMetadatas.find((metadata) => this.getTablePath(table) === this.getTablePath(metadata));
          const hasIgnoredIndex = columnUniqueIndices.length > 0 && tableMetadata && tableMetadata.indices.some((index) => {
            return columnUniqueIndices.some((uniqueIndex) => {
              return index.name === uniqueIndex["INDEX_NAME"] && index.synchronize === false;
            });
          });
          const isConstraintComposite = columnUniqueIndices.every((uniqueIndex) => {
            return dbIndices.some((dbIndex) => dbIndex["INDEX_NAME"] === uniqueIndex["INDEX_NAME"] && dbIndex["COLUMN_NAME"] !== dbColumn["COLUMN_NAME"]);
          });
          const tableColumn = new TableColumn();
          tableColumn.name = dbColumn["COLUMN_NAME"];
          let fullType = dbColumn["SPANNER_TYPE"].toLowerCase();
          if (fullType.indexOf("array") !== -1) {
            tableColumn.isArray = true;
            fullType = fullType.substring(fullType.indexOf("<") + 1, fullType.indexOf(">"));
          }
          if (fullType.indexOf("(") !== -1) {
            tableColumn.type = fullType.substring(0, fullType.indexOf("("));
          } else {
            tableColumn.type = fullType;
          }
          if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1) {
            tableColumn.length = fullType.substring(fullType.indexOf("(") + 1, fullType.indexOf(")"));
          }
          if (dbColumn["IS_GENERATED"] === "ALWAYS") {
            tableColumn.asExpression = dbColumn["GENERATION_EXPRESSION"];
            tableColumn.generatedType = "STORED";
            const asExpressionQuery = this.selectTypeormMetadataSql({
              table: dbTable["TABLE_NAME"],
              type: MetadataTableType.GENERATED_COLUMN,
              name: tableColumn.name
            });
            const results = yield this.query(asExpressionQuery.query, asExpressionQuery.parameters);
            if (results[0] && results[0].value) {
              tableColumn.asExpression = results[0].value;
            } else {
              tableColumn.asExpression = "";
            }
          }
          tableColumn.isUnique = columnUniqueIndices.length > 0 && !hasIgnoredIndex && !isConstraintComposite;
          tableColumn.isNullable = dbColumn["IS_NULLABLE"] === "YES";
          tableColumn.isPrimary = dbPrimaryKeys.some((dbPrimaryKey) => {
            return dbPrimaryKey["TABLE_NAME"] === dbColumn["TABLE_NAME"] && dbPrimaryKey["COLUMN_NAME"] === dbColumn["COLUMN_NAME"];
          });
          return tableColumn;
        })));
        const tableForeignKeys = dbForeignKeys.filter((dbForeignKey) => {
          return dbForeignKey["TABLE_NAME"] === dbTable["TABLE_NAME"];
        });
        table.foreignKeys = OrmUtils.uniq(tableForeignKeys, (dbForeignKey) => dbForeignKey["CONSTRAINT_NAME"]).map((dbForeignKey) => {
          const foreignKeys = tableForeignKeys.filter((dbFk) => dbFk["CONSTRAINT_NAME"] === dbForeignKey["CONSTRAINT_NAME"]);
          return new TableForeignKey({
            name: dbForeignKey["CONSTRAINT_NAME"],
            columnNames: OrmUtils.uniq(foreignKeys.map((dbFk) => dbFk["COLUMN_NAME"])),
            referencedDatabase: dbForeignKey["REFERENCED_TABLE_SCHEMA"],
            referencedTableName: dbForeignKey["REFERENCED_TABLE_NAME"],
            referencedColumnNames: OrmUtils.uniq(foreignKeys.map((dbFk) => dbFk["REFERENCED_COLUMN_NAME"])),
            onDelete: dbForeignKey["DELETE_RULE"],
            onUpdate: dbForeignKey["UPDATE_RULE"]
          });
        });
        const tableIndices = dbIndices.filter((dbIndex) => dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"]);
        table.indices = OrmUtils.uniq(tableIndices, (dbIndex) => dbIndex["INDEX_NAME"]).map((constraint) => {
          const indices = tableIndices.filter((index) => {
            return index["INDEX_NAME"] === constraint["INDEX_NAME"];
          });
          return new TableIndex({
            table,
            name: constraint["INDEX_NAME"],
            columnNames: indices.map((i) => i["COLUMN_NAME"]),
            isUnique: constraint["IS_UNIQUE"],
            isNullFiltered: constraint["IS_NULL_FILTERED"]
          });
        });
        const tableChecks = dbChecks.filter((dbCheck) => dbCheck["TABLE_NAME"] === dbTable["TABLE_NAME"]);
        table.checks = OrmUtils.uniq(tableChecks, (dbIndex) => dbIndex["CONSTRAINT_NAME"]).map((constraint) => {
          const checks = tableChecks.filter((dbC) => dbC["CONSTRAINT_NAME"] === constraint["CONSTRAINT_NAME"]);
          return new TableCheck({
            name: constraint["CONSTRAINT_NAME"],
            columnNames: checks.map((c) => c["COLUMN_NAME"]),
            expression: constraint["CHECK_CLAUSE"]
          });
        });
        return table;
      })));
    });
  }
  /**
   * Builds create table sql.
   */
  createTableSql(table, createForeignKeys) {
    const columnDefinitions = table.columns.map((column) => this.buildCreateColumnSql(column)).join(", ");
    let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;
    table.columns.filter((column) => column.isUnique).forEach((column) => {
      const isUniqueIndexExist = table.indices.some((index) => {
        return index.columnNames.length === 1 && !!index.isUnique && index.columnNames.indexOf(column.name) !== -1;
      });
      const isUniqueConstraintExist = table.uniques.some((unique) => {
        return unique.columnNames.length === 1 && unique.columnNames.indexOf(column.name) !== -1;
      });
      if (!isUniqueIndexExist && !isUniqueConstraintExist) table.indices.push(new TableIndex({
        name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
        columnNames: [column.name],
        isUnique: true
      }));
    });
    if (table.uniques.length > 0) {
      table.uniques.forEach((unique) => {
        const uniqueExist = table.indices.some((index) => index.name === unique.name);
        if (!uniqueExist) {
          table.indices.push(new TableIndex({
            name: unique.name,
            columnNames: unique.columnNames,
            isUnique: true
          }));
        }
      });
    }
    if (table.checks.length > 0) {
      const checksSql = table.checks.map((check) => {
        const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table, check.expression);
        return `CONSTRAINT \`${checkName}\` CHECK (${check.expression})`;
      }).join(", ");
      sql += `, ${checksSql}`;
    }
    if (table.foreignKeys.length > 0 && createForeignKeys) {
      const foreignKeysSql = table.foreignKeys.map((fk) => {
        const columnNames = fk.columnNames.map((columnName) => `\`${columnName}\``).join(", ");
        if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);
        const referencedColumnNames = fk.referencedColumnNames.map((columnName) => `\`${columnName}\``).join(", ");
        return `CONSTRAINT \`${fk.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;
      }).join(", ");
      sql += `, ${foreignKeysSql}`;
    }
    sql += `)`;
    const primaryColumns = table.columns.filter((column) => column.isPrimary);
    if (primaryColumns.length > 0) {
      const columnNames = primaryColumns.map((column) => this.driver.escape(column.name)).join(", ");
      sql += ` PRIMARY KEY (${columnNames})`;
    }
    return new Query(sql);
  }
  /**
   * Builds drop table sql.
   */
  dropTableSql(tableOrPath) {
    return new Query(`DROP TABLE ${this.escapePath(tableOrPath)}`);
  }
  createViewSql(view) {
    const materializedClause = view.materialized ? "MATERIALIZED " : "";
    const viewName = this.escapePath(view);
    const expression = typeof view.expression === "string" ? view.expression : view.expression(this.connection).getQuery();
    return new Query(`CREATE ${materializedClause}VIEW ${viewName} SQL SECURITY INVOKER AS ${expression}`);
  }
  insertViewDefinitionSql(view) {
    return __async(this, null, function* () {
      let {
        schema,
        tableName: name
      } = this.driver.parseTableName(view);
      const type = view.materialized ? MetadataTableType.MATERIALIZED_VIEW : MetadataTableType.VIEW;
      const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
      return this.insertTypeormMetadataSql({
        type,
        schema,
        name,
        value: expression
      });
    });
  }
  /**
   * Builds drop view sql.
   */
  dropViewSql(view) {
    const materializedClause = view.materialized ? "MATERIALIZED " : "";
    return new Query(`DROP ${materializedClause}VIEW ${this.escapePath(view)}`);
  }
  /**
   * Builds remove view sql.
   */
  deleteViewDefinitionSql(view) {
    return __async(this, null, function* () {
      let {
        schema,
        tableName: name
      } = this.driver.parseTableName(view);
      const type = view.materialized ? MetadataTableType.MATERIALIZED_VIEW : MetadataTableType.VIEW;
      return this.deleteTypeormMetadataSql({
        type,
        schema,
        name
      });
    });
  }
  /**
   * Builds create index sql.
   */
  createIndexSql(table, index) {
    const columns = index.columnNames.map((columnName) => this.driver.escape(columnName)).join(", ");
    let indexType = "";
    if (index.isUnique) indexType += "UNIQUE ";
    if (index.isNullFiltered) indexType += "NULL_FILTERED ";
    return new Query(`CREATE ${indexType}INDEX \`${index.name}\` ON ${this.escapePath(table)} (${columns})`);
  }
  /**
   * Builds drop index sql.
   */
  dropIndexSql(table, indexOrName) {
    let indexName = indexOrName instanceof TableIndex ? indexOrName.name : indexOrName;
    return new Query(`DROP INDEX \`${indexName}\``);
  }
  /**
   * Builds create check constraint sql.
   */
  createCheckConstraintSql(table, checkConstraint) {
    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \`${checkConstraint.name}\` CHECK (${checkConstraint.expression})`);
  }
  /**
   * Builds drop check constraint sql.
   */
  dropCheckConstraintSql(table, checkOrName) {
    const checkName = checkOrName instanceof TableCheck ? checkOrName.name : checkOrName;
    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \`${checkName}\``);
  }
  /**
   * Builds create foreign key sql.
   */
  createForeignKeySql(table, foreignKey) {
    const columnNames = foreignKey.columnNames.map((column) => this.driver.escape(column)).join(", ");
    const referencedColumnNames = foreignKey.referencedColumnNames.map((column) => this.driver.escape(column)).join(",");
    let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \`${foreignKey.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))} (${referencedColumnNames})`;
    return new Query(sql);
  }
  /**
   * Builds drop foreign key sql.
   */
  dropForeignKeySql(table, foreignKeyOrName) {
    const foreignKeyName = foreignKeyOrName instanceof TableForeignKey ? foreignKeyOrName.name : foreignKeyOrName;
    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \`${foreignKeyName}\``);
  }
  /**
   * Escapes given table or view path.
   */
  escapePath(target) {
    const {
      tableName
    } = this.driver.parseTableName(target);
    return `\`${tableName}\``;
  }
  /**
   * Builds a part of query to create/change a column.
   */
  buildCreateColumnSql(column) {
    let c = `${this.driver.escape(column.name)} ${this.connection.driver.createFullType(column)}`;
    if (column.generatedType === "STORED" && column.asExpression) {
      c += ` AS (${column.asExpression}) STORED`;
    } else {
      if (!column.isNullable) c += " NOT NULL";
    }
    return c;
  }
  /**
   * Executes sql used special for schema build.
   */
  executeQueries(upQueries, downQueries) {
    return __async(this, null, function* () {
      if (upQueries instanceof Query) upQueries = [upQueries];
      if (downQueries instanceof Query) downQueries = [downQueries];
      this.sqlInMemory.upQueries.push(...upQueries);
      this.sqlInMemory.downQueries.push(...downQueries);
      if (this.sqlMemoryMode === true) return Promise.resolve();
      for (const {
        query,
        parameters
      } of upQueries) {
        if (this.isDMLQuery(query)) {
          yield this.query(query, parameters);
        } else {
          yield this.updateDDL(query, parameters);
        }
      }
    });
  }
  isDMLQuery(query) {
    return query.startsWith("INSERT") || query.startsWith("UPDATE") || query.startsWith("DELETE");
  }
  /**
   * Change table comment.
   */
  changeTableComment(tableOrName, comment) {
    throw new TypeORMError(`spanner driver does not support change table comment.`);
  }
};

// ../node_modules/typeorm/browser/driver/spanner/SpannerDriver.js
var SpannerDriver = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    this.isReplicated = false;
    this.treeSupport = true;
    this.transactionSupport = "none";
    this.supportedDataTypes = ["bool", "int64", "float64", "numeric", "string", "json", "bytes", "date", "timestamp", "array"];
    this.supportedUpsertTypes = [];
    this.spatialTypes = [];
    this.withLengthColumnTypes = ["string", "bytes"];
    this.withWidthColumnTypes = [];
    this.withPrecisionColumnTypes = [];
    this.withScaleColumnTypes = [];
    this.mappedDataTypes = {
      createDate: "timestamp",
      createDateDefault: "",
      updateDate: "timestamp",
      updateDateDefault: "",
      deleteDate: "timestamp",
      deleteDateNullable: true,
      version: "int64",
      treeLevel: "int64",
      migrationId: "int64",
      migrationName: "string",
      migrationTimestamp: "int64",
      cacheId: "string",
      cacheIdentifier: "string",
      cacheTime: "int64",
      cacheDuration: "int64",
      cacheQuery: "string",
      cacheResult: "string",
      metadataType: "string",
      metadataDatabase: "string",
      metadataSchema: "string",
      metadataTable: "string",
      metadataName: "string",
      metadataValue: "string"
    };
    this.parametersPrefix = "@param";
    this.dataTypeDefaults = {};
    this.maxAliasLength = 63;
    this.cteCapabilities = {
      enabled: true
    };
    this._isReturningSqlSupported = {
      delete: false,
      insert: false,
      update: false
    };
    this.connection = connection;
    this.options = connection.options;
    this.isReplicated = this.options.replication ? true : false;
    this.loadDependencies();
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Performs connection to the database.
   */
  connect() {
    return __async(this, null, function* () {
      this.instance = this.spanner.instance(this.options.instanceId);
      this.instanceDatabase = this.instance.database(this.options.databaseId);
    });
  }
  /**
   * Makes any action after connection (e.g. create extensions in Postgres driver).
   */
  afterConnect() {
    return Promise.resolve();
  }
  /**
   * Closes connection with the database.
   */
  disconnect() {
    return __async(this, null, function* () {
      this.instanceDatabase.close();
    });
  }
  /**
   * Creates a schema builder used to build and sync a schema.
   */
  createSchemaBuilder() {
    return new RdbmsSchemaBuilder(this.connection);
  }
  /**
   * Creates a query runner used to execute database queries.
   */
  createQueryRunner(mode) {
    return new SpannerQueryRunner(this, mode);
  }
  /**
   * Replaces parameters in the given sql with special escaping character
   * and an array of parameter names to be passed to a query.
   */
  escapeQueryWithParameters(sql, parameters, nativeParameters) {
    const escapedParameters = Object.keys(nativeParameters).map((key) => nativeParameters[key]);
    if (!parameters || !Object.keys(parameters).length) return [sql, escapedParameters];
    const parameterIndexMap = /* @__PURE__ */ new Map();
    sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {
      if (!parameters.hasOwnProperty(key)) {
        return full;
      }
      if (parameterIndexMap.has(key)) {
        return this.parametersPrefix + parameterIndexMap.get(key);
      }
      let value = parameters[key];
      if (value === null) {
        return full;
      }
      if (isArray) {
        return value.map((v) => {
          escapedParameters.push(v);
          return this.createParameter(key, escapedParameters.length - 1);
        }).join(", ");
      }
      if (value instanceof Function) {
        return value();
      }
      escapedParameters.push(value);
      parameterIndexMap.set(key, escapedParameters.length - 1);
      return this.createParameter(key, escapedParameters.length - 1);
    });
    sql = sql.replace(/([ ]+)?=([ ]+)?:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, emptySpaceBefore, emptySpaceAfter, isArray, key) => {
      if (!parameters.hasOwnProperty(key)) {
        return full;
      }
      let value = parameters[key];
      if (value === null) {
        return " IS NULL";
      }
      return full;
    });
    return [sql, escapedParameters];
  }
  /**
   * Escapes a column name.
   */
  escape(columnName) {
    return `\`${columnName}\``;
  }
  /**
   * Build full table name with database name, schema name and table name.
   * E.g. myDB.mySchema.myTable
   */
  buildTableName(tableName, schema, database) {
    let tablePath = [tableName];
    if (database) {
      tablePath.unshift(database);
    }
    return tablePath.join(".");
  }
  /**
   * Parse a target table name or other types and return a normalized table definition.
   */
  parseTableName(target) {
    const driverDatabase = this.database;
    const driverSchema = void 0;
    if (target instanceof Table || target instanceof View) {
      const parsed = this.parseTableName(target.name);
      return {
        database: target.database || parsed.database || driverDatabase,
        schema: target.schema || parsed.schema || driverSchema,
        tableName: parsed.tableName
      };
    }
    if (target instanceof TableForeignKey) {
      const parsed = this.parseTableName(target.referencedTableName);
      return {
        database: target.referencedDatabase || parsed.database || driverDatabase,
        schema: target.referencedSchema || parsed.schema || driverSchema,
        tableName: parsed.tableName
      };
    }
    if (target instanceof EntityMetadata) {
      return {
        database: target.database || driverDatabase,
        schema: target.schema || driverSchema,
        tableName: target.tableName
      };
    }
    const parts = target.split(".");
    return {
      database: (parts.length > 1 ? parts[0] : void 0) || driverDatabase,
      schema: driverSchema,
      tableName: parts.length > 1 ? parts[1] : parts[0]
    };
  }
  /**
   * Prepares given value to a value to be persisted, based on its column type and metadata.
   */
  preparePersistentValue(value, columnMetadata) {
    if (columnMetadata.transformer) value = ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
    if (value === null || value === void 0) return value;
    if (columnMetadata.type === "numeric") {
      const lib = this.options.driver || PlatformTools.load("spanner");
      return lib.Spanner.numeric(value);
    } else if (columnMetadata.type === "date") {
      return DateUtils.mixedDateToDateString(value);
    } else if (columnMetadata.type === "json") {
      return value;
    } else if (columnMetadata.type === "timestamp" || columnMetadata.type === Date) {
      return DateUtils.mixedDateToDate(value);
    }
    return value;
  }
  /**
   * Prepares given value to a value to be persisted, based on its column type or metadata.
   */
  prepareHydratedValue(value, columnMetadata) {
    if (value === null || value === void 0) return columnMetadata.transformer ? ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
    if (columnMetadata.type === Boolean || columnMetadata.type === "bool") {
      value = value ? true : false;
    } else if (columnMetadata.type === "timestamp" || columnMetadata.type === Date) {
      value = new Date(value);
    } else if (columnMetadata.type === "numeric") {
      value = value.value;
    } else if (columnMetadata.type === "date") {
      value = DateUtils.mixedDateToDateString(value);
    } else if (columnMetadata.type === "json") {
      value = typeof value === "string" ? JSON.parse(value) : value;
    } else if (columnMetadata.type === Number) {
      value = !isNaN(+value) ? parseInt(value) : value;
    }
    if (columnMetadata.transformer) value = ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
    return value;
  }
  /**
   * Creates a database type from a given column metadata.
   */
  normalizeType(column) {
    if (column.type === Number) {
      return "int64";
    } else if (column.type === String || column.type === "uuid") {
      return "string";
    } else if (column.type === Date) {
      return "timestamp";
    } else if (column.type === Buffer) {
      return "bytes";
    } else if (column.type === Boolean) {
      return "bool";
    } else {
      return column.type || "";
    }
  }
  /**
   * Normalizes "default" value of the column.
   *
   * Spanner does not support default values.
   */
  normalizeDefault(columnMetadata) {
    return columnMetadata.default === "" ? `"${columnMetadata.default}"` : `${columnMetadata.default}`;
  }
  /**
   * Normalizes "isUnique" value of the column.
   */
  normalizeIsUnique(column) {
    return column.entityMetadata.indices.some((idx) => idx.isUnique && idx.columns.length === 1 && idx.columns[0] === column);
  }
  /**
   * Returns default column lengths, which is required on column creation.
   */
  getColumnLength(column) {
    if (column.length) return column.length.toString();
    if (column.generationStrategy === "uuid") return "36";
    switch (column.type) {
      case String:
      case "string":
      case "bytes":
        return "max";
      default:
        return "";
    }
  }
  /**
   * Creates column type definition including length, precision and scale
   */
  createFullType(column) {
    let type = column.type;
    if (this.getColumnLength(column)) {
      type += `(${this.getColumnLength(column)})`;
    } else if (column.width) {
      type += `(${column.width})`;
    } else if (column.precision !== null && column.precision !== void 0 && column.scale !== null && column.scale !== void 0) {
      type += `(${column.precision},${column.scale})`;
    } else if (column.precision !== null && column.precision !== void 0) {
      type += `(${column.precision})`;
    }
    if (column.isArray) type = `array<${type}>`;
    return type;
  }
  /**
   * Obtains a new database connection to a master server.
   * Used for replication.
   * If replication is not setup then returns default connection's database connection.
   */
  obtainMasterConnection() {
    return this.instanceDatabase;
  }
  /**
   * Obtains a new database connection to a slave server.
   * Used for replication.
   * If replication is not setup then returns master (default) connection's database connection.
   */
  obtainSlaveConnection() {
    return this.instanceDatabase;
  }
  /**
   * Creates generated map of values generated or returned by database after INSERT query.
   */
  createGeneratedMap(metadata, insertResult, entityIndex) {
    if (!insertResult) {
      return void 0;
    }
    if (insertResult.insertId === void 0) {
      return Object.keys(insertResult).reduce((map, key) => {
        const column = metadata.findColumnWithDatabaseName(key);
        if (column) {
          OrmUtils.mergeDeep(map, column.createValueMap(insertResult[key]));
        }
        return map;
      }, {});
    }
    const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {
      let value;
      if (generatedColumn.generationStrategy === "increment" && insertResult.insertId) {
        value = insertResult.insertId + entityIndex;
      }
      return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
    }, {});
    return Object.keys(generatedMap).length > 0 ? generatedMap : void 0;
  }
  /**
   * Differentiate columns of this table and columns from the given column metadatas columns
   * and returns only changed.
   */
  findChangedColumns(tableColumns, columnMetadatas) {
    return columnMetadatas.filter((columnMetadata) => {
      const tableColumn = tableColumns.find((c) => c.name === columnMetadata.databaseName);
      if (!tableColumn) return false;
      const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== this.getColumnLength(columnMetadata) || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.isPrimary !== columnMetadata.isPrimary || !this.compareNullableValues(columnMetadata, tableColumn) || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata);
      return isColumnChanged;
    });
  }
  /**
   * Returns true if driver supports RETURNING / OUTPUT statement.
   */
  isReturningSqlSupported(returningType) {
    return this._isReturningSqlSupported[returningType];
  }
  /**
   * Returns true if driver supports uuid values generation on its own.
   */
  isUUIDGenerationSupported() {
    return false;
  }
  /**
   * Returns true if driver supports fulltext indices.
   */
  isFullTextColumnTypeSupported() {
    return false;
  }
  /**
   * Creates an escaped parameter.
   */
  createParameter(parameterName, index) {
    return this.parametersPrefix + index;
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Loads all driver dependencies.
   */
  loadDependencies() {
    try {
      const lib = this.options.driver || PlatformTools.load("spanner");
      this.spanner = new lib.Spanner({
        projectId: this.options.projectId
      });
    } catch (e) {
      console.error(e);
      throw new DriverPackageNotInstalledError("Spanner", "@google-cloud/spanner");
    }
  }
  compareNullableValues(columnMetadata, tableColumn) {
    if (columnMetadata.generatedType) {
      return true;
    }
    return columnMetadata.isNullable === tableColumn.isNullable;
  }
  /**
   * Checks if "DEFAULT" values in the column metadata and in the database are equal.
   */
  compareDefaultValues(columnMetadataValue, databaseValue) {
    if (typeof columnMetadataValue === "string" && typeof databaseValue === "string") {
      columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, "");
      databaseValue = databaseValue.replace(/^'+|'+$/g, "");
    }
    return columnMetadataValue === databaseValue;
  }
  /**
   * If parameter is a datetime function, e.g. "CURRENT_TIMESTAMP", normalizes it.
   * Otherwise returns original input.
   */
  normalizeDatetimeFunction(value) {
    if (!value) return value;
    const isDatetimeFunction = value.toUpperCase().indexOf("CURRENT_TIMESTAMP") !== -1 || value.toUpperCase().indexOf("NOW") !== -1;
    if (isDatetimeFunction) {
      const precision = value.match(/\(\d+\)/);
      return precision ? `CURRENT_TIMESTAMP${precision[0]}` : "CURRENT_TIMESTAMP";
    } else {
      return value;
    }
  }
  /**
   * Escapes a given comment.
   */
  escapeComment(comment) {
    if (!comment) return comment;
    comment = comment.replace(/\u0000/g, "");
    return comment;
  }
};

// ../node_modules/typeorm/browser/driver/DriverFactory.js
var DriverFactory = class {
  /**
   * Creates a new driver depend on a given connection's driver type.
   */
  create(connection) {
    const {
      type
    } = connection.options;
    switch (type) {
      case "mysql":
        return new MysqlDriver(connection);
      case "postgres":
        return new PostgresDriver(connection);
      case "cockroachdb":
        return new CockroachDriver(connection);
      case "sap":
        return new SapDriver(connection);
      case "mariadb":
        return new MysqlDriver(connection);
      case "sqlite":
        return new SqliteDriver(connection);
      case "better-sqlite3":
        return new BetterSqlite3Driver(connection);
      case "cordova":
        return new CordovaDriver(connection);
      case "nativescript":
        return new NativescriptDriver(connection);
      case "react-native":
        return new ReactNativeDriver(connection);
      case "sqljs":
        return new SqljsDriver(connection);
      case "oracle":
        return new OracleDriver(connection);
      case "mssql":
        return new SqlServerDriver(connection);
      case "mongodb":
        return new MongoDriver(connection);
      case "expo":
        return new ExpoDriver(connection);
      case "aurora-mysql":
        return new AuroraMysqlDriver2(connection);
      case "aurora-postgres":
        return new AuroraPostgresDriver2(connection);
      case "capacitor":
        return new CapacitorDriver(connection);
      case "spanner":
        return new SpannerDriver(connection);
      default:
        throw new MissingDriverError(type, ["aurora-mysql", "aurora-postgres", "better-sqlite3", "capacitor", "cockroachdb", "cordova", "expo", "mariadb", "mongodb", "mssql", "mysql", "nativescript", "oracle", "postgres", "react-native", "sap", "sqlite", "sqljs", "spanner"]);
    }
  }
};

// ../node_modules/typeorm/browser/platform/BrowserDirectoryExportedClassesLoader.js
function importClassesFromDirectories(logger, directories, formats = [".js", ".cjs", ".ts"]) {
  return [];
}

// ../node_modules/typeorm/browser/container.js
var defaultContainer = new class {
  constructor() {
    this.instances = [];
  }
  get(someClass) {
    let instance = this.instances.find((i) => i.type === someClass);
    if (!instance) {
      instance = {
        type: someClass,
        object: new someClass()
      };
      this.instances.push(instance);
    }
    return instance.object;
  }
}();
var userContainer;
var userContainerOptions;
function useContainer(iocContainer, options) {
  userContainer = iocContainer;
  userContainerOptions = options;
}
function getFromContainer(someClass) {
  if (userContainer) {
    try {
      const instance = userContainer.get(someClass);
      if (instance) return instance;
      if (!userContainerOptions || !userContainerOptions.fallback) return instance;
    } catch (error) {
      if (!userContainerOptions || !userContainerOptions.fallbackOnErrors) throw error;
    }
  }
  return defaultContainer.get(someClass);
}

// ../node_modules/typeorm/browser/metadata/ColumnMetadata.js
var ColumnMetadata = class {
  // ---------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------
  constructor(options) {
    this["@instanceof"] = Symbol.for("ColumnMetadata");
    this.length = "";
    this.isPrimary = false;
    this.isGenerated = false;
    this.isNullable = false;
    this.isSelect = true;
    this.isInsert = true;
    this.isUpdate = true;
    this.zerofill = false;
    this.unsigned = false;
    this.isArray = false;
    this.isVirtual = false;
    this.isVirtualProperty = false;
    this.isDiscriminator = false;
    this.isTreeLevel = false;
    this.isCreateDate = false;
    this.isUpdateDate = false;
    this.isDeleteDate = false;
    this.isVersion = false;
    this.isObjectId = false;
    this.isNestedSetLeft = false;
    this.isNestedSetRight = false;
    this.isMaterializedPath = false;
    this.entityMetadata = options.entityMetadata;
    this.embeddedMetadata = options.embeddedMetadata;
    this.referencedColumn = options.referencedColumn;
    if (options.args.target) this.target = options.args.target;
    if (options.args.propertyName) this.propertyName = options.args.propertyName;
    if (options.args.options.name) this.givenDatabaseName = options.args.options.name;
    if (options.args.options.type) this.type = options.args.options.type;
    if (options.args.options.length) this.length = options.args.options.length ? options.args.options.length.toString() : "";
    if (options.args.options.width) this.width = options.args.options.width;
    if (options.args.options.charset) this.charset = options.args.options.charset;
    if (options.args.options.collation) this.collation = options.args.options.collation;
    if (options.args.options.primary) this.isPrimary = options.args.options.primary;
    if (options.args.options.default === null)
      this.isNullable = true;
    if (options.args.options.nullable !== void 0) this.isNullable = options.args.options.nullable;
    if (options.args.options.select !== void 0) this.isSelect = options.args.options.select;
    if (options.args.options.insert !== void 0) this.isInsert = options.args.options.insert;
    if (options.args.options.update !== void 0) this.isUpdate = options.args.options.update;
    if (options.args.options.readonly !== void 0) this.isUpdate = !options.args.options.readonly;
    if (options.args.options.comment) this.comment = options.args.options.comment;
    if (options.args.options.default !== void 0) this.default = options.args.options.default;
    if (options.args.options.onUpdate) this.onUpdate = options.args.options.onUpdate;
    if (options.args.options.generatedIdentity) this.generatedIdentity = options.args.options.generatedIdentity;
    if (options.args.options.scale !== null && options.args.options.scale !== void 0) this.scale = options.args.options.scale;
    if (options.args.options.zerofill) {
      this.zerofill = options.args.options.zerofill;
      this.unsigned = true;
    }
    if (options.args.options.unsigned) this.unsigned = options.args.options.unsigned;
    if (options.args.options.precision !== null) this.precision = options.args.options.precision;
    if (options.args.options.enum) {
      if (ObjectUtils.isObject(options.args.options.enum) && !Array.isArray(options.args.options.enum)) {
        this.enum = Object.keys(options.args.options.enum).filter((key) => isNaN(+key) && typeof options.args.options.enum[key] !== "function").map((key) => options.args.options.enum[key]);
      } else {
        this.enum = options.args.options.enum;
      }
    }
    if (options.args.options.enumName) {
      this.enumName = options.args.options.enumName;
    }
    if (options.args.options.primaryKeyConstraintName) {
      this.primaryKeyConstraintName = options.args.options.primaryKeyConstraintName;
    }
    if (options.args.options.foreignKeyConstraintName) {
      this.foreignKeyConstraintName = options.args.options.foreignKeyConstraintName;
    }
    if (options.args.options.asExpression) {
      this.asExpression = options.args.options.asExpression;
      this.generatedType = options.args.options.generatedType ? options.args.options.generatedType : "VIRTUAL";
    }
    if (options.args.options.hstoreType) this.hstoreType = options.args.options.hstoreType;
    if (options.args.options.array) this.isArray = options.args.options.array;
    if (options.args.mode) {
      this.isVirtualProperty = options.args.mode === "virtual-property";
      this.isVirtual = options.args.mode === "virtual";
      this.isTreeLevel = options.args.mode === "treeLevel";
      this.isCreateDate = options.args.mode === "createDate";
      this.isUpdateDate = options.args.mode === "updateDate";
      this.isDeleteDate = options.args.mode === "deleteDate";
      this.isVersion = options.args.mode === "version";
      this.isObjectId = options.args.mode === "objectId";
    }
    if (this.isVirtualProperty) {
      this.isInsert = false;
      this.isUpdate = false;
    }
    if (options.args.options.transformer) this.transformer = options.args.options.transformer;
    if (options.args.options.spatialFeatureType) this.spatialFeatureType = options.args.options.spatialFeatureType;
    if (options.args.options.srid !== void 0) this.srid = options.args.options.srid;
    if (options.args.options.query) this.query = options.args.options.query;
    if (this.isTreeLevel) this.type = options.connection.driver.mappedDataTypes.treeLevel;
    if (this.isCreateDate) {
      if (!this.type) this.type = options.connection.driver.mappedDataTypes.createDate;
      if (!this.default) this.default = () => options.connection.driver.mappedDataTypes.createDateDefault;
      if (this.precision === void 0 && options.args.options.precision === void 0 && options.connection.driver.mappedDataTypes.createDatePrecision) this.precision = options.connection.driver.mappedDataTypes.createDatePrecision;
    }
    if (this.isUpdateDate) {
      if (!this.type) this.type = options.connection.driver.mappedDataTypes.updateDate;
      if (!this.default) this.default = () => options.connection.driver.mappedDataTypes.updateDateDefault;
      if (!this.onUpdate) this.onUpdate = options.connection.driver.mappedDataTypes.updateDateDefault;
      if (this.precision === void 0 && options.args.options.precision === void 0 && options.connection.driver.mappedDataTypes.updateDatePrecision) this.precision = options.connection.driver.mappedDataTypes.updateDatePrecision;
    }
    if (this.isDeleteDate) {
      if (!this.type) this.type = options.connection.driver.mappedDataTypes.deleteDate;
      if (!this.isNullable) this.isNullable = options.connection.driver.mappedDataTypes.deleteDateNullable;
      if (this.precision === void 0 && options.args.options.precision === void 0 && options.connection.driver.mappedDataTypes.deleteDatePrecision) this.precision = options.connection.driver.mappedDataTypes.deleteDatePrecision;
    }
    if (this.isVersion) this.type = options.connection.driver.mappedDataTypes.version;
    if (options.closureType) this.closureType = options.closureType;
    if (options.nestedSetLeft) this.isNestedSetLeft = options.nestedSetLeft;
    if (options.nestedSetRight) this.isNestedSetRight = options.nestedSetRight;
    if (options.materializedPath) this.isMaterializedPath = options.materializedPath;
  }
  // ---------------------------------------------------------------------
  // Public Methods
  // ---------------------------------------------------------------------
  /**
   * Creates entity id map from the given entity ids array.
   */
  createValueMap(value, useDatabaseName = false) {
    if (this.embeddedMetadata) {
      const propertyNames = [...this.embeddedMetadata.parentPropertyNames];
      const extractEmbeddedColumnValue = (propertyNames2, map) => {
        const propertyName = propertyNames2.shift();
        if (propertyName) {
          map[propertyName] = {};
          extractEmbeddedColumnValue(propertyNames2, map[propertyName]);
          return map;
        }
        if ((this.generationStrategy === "increment" || this.generationStrategy === "rowid") && this.type === "bigint" && value !== null) value = String(value);
        map[useDatabaseName ? this.databaseName : this.propertyName] = value;
        return map;
      };
      return extractEmbeddedColumnValue(propertyNames, {});
    } else {
      if ((this.generationStrategy === "increment" || this.generationStrategy === "rowid") && this.type === "bigint" && value !== null) value = String(value);
      return {
        [useDatabaseName ? this.databaseName : this.propertyName]: value
      };
    }
  }
  /**
   * Extracts column value and returns its column name with this value in a literal object.
   * If column is in embedded (or recursive embedded) it returns complex literal object.
   *
   * Examples what this method can return depend if this column is in embeds.
   * { id: 1 } or { title: "hello" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }
   */
  getEntityValueMap(entity, options) {
    const returnNulls = false;
    if (this.embeddedMetadata) {
      const propertyNames = [...this.embeddedMetadata.parentPropertyNames];
      const isEmbeddedArray = this.embeddedMetadata.isArray;
      const extractEmbeddedColumnValue = (propertyNames2, value) => {
        if (value === void 0) {
          return {};
        }
        const propertyName = propertyNames2.shift();
        if (propertyName) {
          const submap = extractEmbeddedColumnValue(propertyNames2, value[propertyName]);
          if (Object.keys(submap).length > 0) {
            return {
              [propertyName]: submap
            };
          }
          return {};
        }
        if (isEmbeddedArray && Array.isArray(value)) {
          return value.map((v) => ({
            [this.propertyName]: v[this.propertyName]
          }));
        }
        if (value[this.propertyName] !== void 0 && (returnNulls === false || value[this.propertyName] !== null)) {
          return {
            [this.propertyName]: value[this.propertyName]
          };
        }
        return {};
      };
      const map = extractEmbeddedColumnValue(propertyNames, entity);
      return Object.keys(map).length > 0 ? map : void 0;
    } else {
      if (this.relationMetadata && !Object.getOwnPropertyDescriptor(entity, this.relationMetadata.propertyName)?.get && entity[this.relationMetadata.propertyName] && ObjectUtils.isObject(entity[this.relationMetadata.propertyName])) {
        if (this.relationMetadata.joinColumns.length > 1) {
          const map = this.relationMetadata.joinColumns.reduce((map2, joinColumn) => {
            const value = joinColumn.referencedColumn.getEntityValueMap(entity[this.relationMetadata.propertyName]);
            if (value === void 0) return map2;
            return OrmUtils.mergeDeep(map2, value);
          }, {});
          if (Object.keys(map).length > 0) return {
            [this.propertyName]: map
          };
        } else {
          const value = this.relationMetadata.joinColumns[0].referencedColumn.getEntityValue(entity[this.relationMetadata.propertyName]);
          if (value) {
            return {
              [this.propertyName]: value
            };
          }
        }
        return void 0;
      } else {
        if (entity[this.propertyName] !== void 0 && (returnNulls === false || entity[this.propertyName] !== null)) {
          return {
            [this.propertyName]: entity[this.propertyName]
          };
        }
        return void 0;
      }
    }
  }
  /**
   * Extracts column value from the given entity.
   * If column is in embedded (or recursive embedded) it extracts its value from there.
   */
  getEntityValue(entity, transform = false) {
    if (entity === void 0 || entity === null) return void 0;
    let value = void 0;
    if (this.embeddedMetadata) {
      const propertyNames = [...this.embeddedMetadata.parentPropertyNames];
      const isEmbeddedArray = this.embeddedMetadata.isArray;
      const extractEmbeddedColumnValue = (propertyNames2, value2) => {
        const propertyName = propertyNames2.shift();
        return propertyName && value2 ? extractEmbeddedColumnValue(propertyNames2, value2[propertyName]) : value2;
      };
      const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);
      if (embeddedObject) {
        if (this.relationMetadata && this.referencedColumn) {
          const relatedEntity = this.relationMetadata.getEntityValue(embeddedObject);
          if (relatedEntity && ObjectUtils.isObject(relatedEntity) && !InstanceChecker.isFindOperator(relatedEntity) && !Buffer.isBuffer(relatedEntity)) {
            value = this.referencedColumn.getEntityValue(relatedEntity);
          } else if (embeddedObject[this.propertyName] && ObjectUtils.isObject(embeddedObject[this.propertyName]) && !InstanceChecker.isFindOperator(embeddedObject[this.propertyName]) && !Buffer.isBuffer(embeddedObject[this.propertyName]) && !(embeddedObject[this.propertyName] instanceof Date)) {
            value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);
          } else {
            value = embeddedObject[this.propertyName];
          }
        } else if (this.referencedColumn) {
          value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);
        } else if (isEmbeddedArray && Array.isArray(embeddedObject)) {
          value = embeddedObject.map((o) => o[this.propertyName]);
        } else {
          value = embeddedObject[this.propertyName];
        }
      }
    } else {
      if (this.relationMetadata && this.referencedColumn) {
        const relatedEntity = this.relationMetadata.getEntityValue(entity);
        if (relatedEntity && ObjectUtils.isObject(relatedEntity) && !InstanceChecker.isFindOperator(relatedEntity) && !(typeof relatedEntity === "function") && !Buffer.isBuffer(relatedEntity)) {
          value = this.referencedColumn.getEntityValue(relatedEntity);
        } else if (entity[this.propertyName] && ObjectUtils.isObject(entity[this.propertyName]) && !InstanceChecker.isFindOperator(entity[this.propertyName]) && !(typeof entity[this.propertyName] === "function") && !Buffer.isBuffer(entity[this.propertyName]) && !(entity[this.propertyName] instanceof Date)) {
          value = this.referencedColumn.getEntityValue(entity[this.propertyName]);
        } else {
          value = entity[this.propertyName];
        }
      } else if (this.referencedColumn) {
        value = this.referencedColumn.getEntityValue(entity[this.propertyName]);
      } else {
        value = entity[this.propertyName];
      }
    }
    if (transform && this.transformer) value = ApplyValueTransformers.transformTo(this.transformer, value);
    return value;
  }
  /**
   * Sets given entity's column value.
   * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.
   */
  setEntityValue(entity, value) {
    if (this.embeddedMetadata) {
      const extractEmbeddedColumnValue = (embeddedMetadatas, map) => {
        const embeddedMetadata = embeddedMetadatas.shift();
        if (embeddedMetadata) {
          if (!map[embeddedMetadata.propertyName]) map[embeddedMetadata.propertyName] = embeddedMetadata.create();
          extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);
          return map;
        }
        map[this.propertyName] = value;
        return map;
      };
      return extractEmbeddedColumnValue([...this.embeddedMetadata.embeddedMetadataTree], entity);
    } else {
      if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName) {
        if (!(this.propertyName in entity)) {
          entity[this.propertyName] = {};
        }
        entity[this.propertyName][this.referencedColumn.propertyName] = value;
      } else {
        entity[this.propertyName] = value;
      }
    }
  }
  /**
   * Compares given entity's column value with a given value.
   */
  compareEntityValue(entity, valueToCompareWith) {
    const columnValue = this.getEntityValue(entity);
    if (ObjectUtils.isObject(columnValue)) {
      return columnValue.equals(valueToCompareWith);
    }
    return columnValue === valueToCompareWith;
  }
  // ---------------------------------------------------------------------
  // Builder Methods
  // ---------------------------------------------------------------------
  build(connection) {
    this.propertyPath = this.buildPropertyPath();
    this.propertyAliasName = this.propertyPath.replace(".", "_");
    this.databaseName = this.buildDatabaseName(connection);
    this.databasePath = this.buildDatabasePath();
    this.databaseNameWithoutPrefixes = connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, []);
    return this;
  }
  buildPropertyPath() {
    let path = "";
    if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length) path = this.embeddedMetadata.parentPropertyNames.join(".") + ".";
    path += this.propertyName;
    if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName) path += "." + this.referencedColumn.propertyName;
    return path;
  }
  buildDatabasePath() {
    let path = "";
    if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length) path = this.embeddedMetadata.parentPropertyNames.join(".") + ".";
    path += this.databaseName;
    if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.databaseName !== this.databaseName) path += "." + this.referencedColumn.databaseName;
    return path;
  }
  buildDatabaseName(connection) {
    let propertyNames = this.embeddedMetadata ? this.embeddedMetadata.parentPrefixes : [];
    if (connection.driver.options.type === "mongodb")
      propertyNames = [];
    return connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, propertyNames);
  }
};

// ../node_modules/typeorm/browser/metadata/IndexMetadata.js
var IndexMetadata = class {
  // ---------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------
  constructor(options) {
    this.isUnique = false;
    this.isSpatial = false;
    this.isFulltext = false;
    this.isNullFiltered = false;
    this.synchronize = true;
    this.columns = [];
    this.columnNamesWithOrderingMap = {};
    this.entityMetadata = options.entityMetadata;
    this.embeddedMetadata = options.embeddedMetadata;
    if (options.columns) this.columns = options.columns;
    if (options.args) {
      this.target = options.args.target;
      if (options.args.synchronize !== null && options.args.synchronize !== void 0) this.synchronize = options.args.synchronize;
      this.isUnique = !!options.args.unique;
      this.isSpatial = !!options.args.spatial;
      this.isFulltext = !!options.args.fulltext;
      this.isNullFiltered = !!options.args.nullFiltered;
      this.parser = options.args.parser;
      this.where = options.args.where;
      this.isSparse = options.args.sparse;
      this.isBackground = options.args.background;
      this.isConcurrent = options.args.concurrent;
      this.expireAfterSeconds = options.args.expireAfterSeconds;
      this.givenName = options.args.name;
      this.givenColumnNames = options.args.columns;
    }
  }
  // ---------------------------------------------------------------------
  // Public Build Methods
  // ---------------------------------------------------------------------
  /**
   * Builds some depend index properties.
   * Must be called after all entity metadata's properties map, columns and relations are built.
   */
  build(namingStrategy) {
    if (this.synchronize === false) {
      this.name = this.givenName;
      return this;
    }
    const map = {};
    if (this.givenColumnNames) {
      let columnPropertyPaths = [];
      if (Array.isArray(this.givenColumnNames)) {
        columnPropertyPaths = this.givenColumnNames.map((columnName) => {
          if (this.embeddedMetadata) return this.embeddedMetadata.propertyPath + "." + columnName;
          return columnName.trim();
        });
        columnPropertyPaths.forEach((propertyPath) => map[propertyPath] = 1);
      } else {
        const columnsFnResult = this.givenColumnNames(this.entityMetadata.propertiesMap);
        if (Array.isArray(columnsFnResult)) {
          columnPropertyPaths = columnsFnResult.map((i) => String(i));
          columnPropertyPaths.forEach((name) => map[name] = 1);
        } else {
          columnPropertyPaths = Object.keys(columnsFnResult).map((i) => String(i));
          Object.keys(columnsFnResult).forEach((columnName) => map[columnName] = columnsFnResult[columnName]);
        }
      }
      this.columns = columnPropertyPaths.map((propertyPath) => {
        const columnWithSameName = this.entityMetadata.columns.find((column) => column.propertyPath === propertyPath);
        if (columnWithSameName) {
          return [columnWithSameName];
        }
        const relationWithSameName = this.entityMetadata.relations.find((relation) => relation.isWithJoinColumn && relation.propertyName === propertyPath);
        if (relationWithSameName) {
          return relationWithSameName.joinColumns;
        }
        const indexName = this.givenName ? '"' + this.givenName + '" ' : "";
        const entityName = this.entityMetadata.targetName;
        throw new TypeORMError(`Index ${indexName}contains column that is missing in the entity (${entityName}): ` + propertyPath);
      }).reduce((a, b) => a.concat(b));
    }
    this.columnNamesWithOrderingMap = Object.keys(map).reduce((updatedMap, key) => {
      const column = this.entityMetadata.columns.find((column2) => column2.propertyPath === key);
      if (column) updatedMap[column.databasePath] = map[key];
      return updatedMap;
    }, {});
    this.name = this.givenName ? this.givenName : namingStrategy.indexName(this.entityMetadata.tableName, this.columns.map((column) => column.databaseName), this.where);
    return this;
  }
};

// ../node_modules/typeorm/browser/metadata/RelationMetadata.js
var RelationMetadata = class {
  // ---------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------
  constructor(options) {
    this.isTreeParent = false;
    this.isTreeChildren = false;
    this.isPrimary = false;
    this.isLazy = false;
    this.isEager = false;
    this.persistenceEnabled = true;
    this.isCascadeInsert = false;
    this.isCascadeUpdate = false;
    this.isCascadeRemove = false;
    this.isCascadeSoftRemove = false;
    this.isCascadeRecover = false;
    this.isNullable = true;
    this.createForeignKeyConstraints = true;
    this.isOwning = false;
    this.isOneToOne = false;
    this.isOneToOneOwner = false;
    this.isWithJoinColumn = false;
    this.isOneToOneNotOwner = false;
    this.isOneToMany = false;
    this.isManyToOne = false;
    this.isManyToMany = false;
    this.isManyToManyOwner = false;
    this.isManyToManyNotOwner = false;
    this.foreignKeys = [];
    this.joinColumns = [];
    this.inverseJoinColumns = [];
    this.entityMetadata = options.entityMetadata;
    this.embeddedMetadata = options.embeddedMetadata;
    const args = options.args;
    this.target = args.target;
    this.propertyName = args.propertyName;
    this.relationType = args.relationType;
    if (args.inverseSideProperty) this.givenInverseSidePropertyFactory = args.inverseSideProperty;
    this.isLazy = args.isLazy || false;
    this.isCascadeInsert = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("insert") !== -1;
    this.isCascadeUpdate = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("update") !== -1;
    this.isCascadeRemove = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("remove") !== -1;
    this.isCascadeSoftRemove = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("soft-remove") !== -1;
    this.isCascadeRecover = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("recover") !== -1;
    this.isNullable = args.options.nullable === false || this.isPrimary ? false : true;
    this.onDelete = args.options.onDelete;
    this.onUpdate = args.options.onUpdate;
    this.deferrable = args.options.deferrable;
    this.createForeignKeyConstraints = args.options.createForeignKeyConstraints === false ? false : true;
    this.isEager = args.options.eager || false;
    this.persistenceEnabled = args.options.persistence === false ? false : true;
    this.orphanedRowAction = args.options.orphanedRowAction || "nullify";
    this.isTreeParent = args.isTreeParent || false;
    this.isTreeChildren = args.isTreeChildren || false;
    if (typeof args.type === "function") {
      this.type = typeof args.type === "function" ? args.type() : args.type;
    } else if (InstanceChecker.isEntitySchema(args.type)) {
      this.type = args.type.options.name;
    } else if (ObjectUtils.isObject(args.type) && typeof args.type.name === "string") {
      this.type = args.type.name;
    } else {
      this.type = args.type;
    }
    this.isOneToOne = this.relationType === "one-to-one";
    this.isOneToMany = this.relationType === "one-to-many";
    this.isManyToOne = this.relationType === "many-to-one";
    this.isManyToMany = this.relationType === "many-to-many";
    this.isOneToOneNotOwner = this.isOneToOne ? true : false;
    this.isManyToManyNotOwner = this.isManyToMany ? true : false;
  }
  // ---------------------------------------------------------------------
  // Public Methods
  // ---------------------------------------------------------------------
  /**
   * Creates join column ids map from the given related entity ids array.
   */
  getRelationIdMap(entity) {
    const joinColumns = this.isOwning ? this.joinColumns : this.inverseRelation.joinColumns;
    const referencedColumns = joinColumns.map((joinColumn) => joinColumn.referencedColumn);
    return EntityMetadata.getValueMap(entity, referencedColumns);
  }
  /**
   * Ensures that given object is an entity id map.
   * If given id is an object then it means its already id map.
   * If given id isn't an object then it means its a value of the id column
   * and it creates a new id map with this value and name of the primary column.
   */
  ensureRelationIdMap(id) {
    if (ObjectUtils.isObject(id)) return id;
    const joinColumns = this.isOwning ? this.joinColumns : this.inverseRelation.joinColumns;
    const referencedColumns = joinColumns.map((joinColumn) => joinColumn.referencedColumn);
    if (referencedColumns.length > 1) throw new TypeORMError(`Cannot create relation id map for a single value because relation contains multiple referenced columns.`);
    return referencedColumns[0].createValueMap(id);
  }
  /**
   * Extracts column value from the given entity.
   * If column is in embedded (or recursive embedded) it extracts its value from there.
   */
  getEntityValue(entity, getLazyRelationsPromiseValue = false) {
    if (entity === null || entity === void 0) return void 0;
    if (this.embeddedMetadata) {
      const propertyNames = [...this.embeddedMetadata.parentPropertyNames];
      const extractEmbeddedColumnValue = (propertyNames2, value) => {
        const propertyName = propertyNames2.shift();
        if (propertyName) {
          if (value[propertyName]) {
            return extractEmbeddedColumnValue(propertyNames2, value[propertyName]);
          }
          return void 0;
        }
        return value;
      };
      const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);
      if (this.isLazy) {
        if (embeddedObject["__" + this.propertyName + "__"] !== void 0) return embeddedObject["__" + this.propertyName + "__"];
        if (getLazyRelationsPromiseValue === true) return embeddedObject[this.propertyName];
        return void 0;
      }
      return embeddedObject ? embeddedObject[this.isLazy ? "__" + this.propertyName + "__" : this.propertyName] : void 0;
    } else {
      if (this.isLazy) {
        if (entity["__" + this.propertyName + "__"] !== void 0) return entity["__" + this.propertyName + "__"];
        if (getLazyRelationsPromiseValue === true) return entity[this.propertyName];
        return void 0;
      }
      return entity[this.propertyName];
    }
  }
  /**
   * Sets given entity's relation's value.
   * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.
   *
   * If merge is set to true, it merges given value into currently
   */
  setEntityValue(entity, value) {
    const propertyName = this.isLazy ? "__" + this.propertyName + "__" : this.propertyName;
    if (this.embeddedMetadata) {
      const extractEmbeddedColumnValue = (embeddedMetadatas, map) => {
        const embeddedMetadata = embeddedMetadatas.shift();
        if (embeddedMetadata) {
          if (!map[embeddedMetadata.propertyName]) map[embeddedMetadata.propertyName] = embeddedMetadata.create();
          extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);
          return map;
        }
        map[propertyName] = value;
        return map;
      };
      return extractEmbeddedColumnValue([...this.embeddedMetadata.embeddedMetadataTree], entity);
    } else {
      entity[propertyName] = value;
    }
  }
  /**
   * Creates entity id map from the given entity ids array.
   */
  createValueMap(value) {
    if (this.embeddedMetadata) {
      const propertyNames = [...this.embeddedMetadata.parentPropertyNames];
      const extractEmbeddedColumnValue = (propertyNames2, map) => {
        const propertyName = propertyNames2.shift();
        if (propertyName) {
          map[propertyName] = {};
          extractEmbeddedColumnValue(propertyNames2, map[propertyName]);
          return map;
        }
        map[this.propertyName] = value;
        return map;
      };
      return extractEmbeddedColumnValue(propertyNames, {});
    } else {
      return {
        [this.propertyName]: value
      };
    }
  }
  // ---------------------------------------------------------------------
  // Builder Methods
  // ---------------------------------------------------------------------
  /**
   * Builds some depend relation metadata properties.
   * This builder method should be used only after embedded metadata tree was build.
   */
  build() {
    this.propertyPath = this.buildPropertyPath();
  }
  /**
   * Registers given foreign keys in the relation.
   * This builder method should be used to register foreign key in the relation.
   */
  registerForeignKeys(...foreignKeys) {
    this.foreignKeys.push(...foreignKeys);
  }
  /**
   * Registers given join columns in the relation.
   * This builder method should be used to register join column in the relation.
   */
  registerJoinColumns(joinColumns = [], inverseJoinColumns = []) {
    this.joinColumns = joinColumns;
    this.inverseJoinColumns = inverseJoinColumns;
    this.isOwning = this.isManyToOne || (this.isManyToMany || this.isOneToOne) && this.joinColumns.length > 0;
    this.isOneToOneOwner = this.isOneToOne && this.isOwning;
    this.isOneToOneNotOwner = this.isOneToOne && !this.isOwning;
    this.isManyToManyOwner = this.isManyToMany && this.isOwning;
    this.isManyToManyNotOwner = this.isManyToMany && !this.isOwning;
    this.isWithJoinColumn = this.isManyToOne || this.isOneToOneOwner;
  }
  /**
   * Registers a given junction entity metadata.
   * This builder method can be called after junction entity metadata for the many-to-many relation was created.
   */
  registerJunctionEntityMetadata(junctionEntityMetadata) {
    this.junctionEntityMetadata = junctionEntityMetadata;
    this.joinTableName = junctionEntityMetadata.tableName;
    if (this.inverseRelation) {
      this.inverseRelation.junctionEntityMetadata = junctionEntityMetadata;
      this.joinTableName = junctionEntityMetadata.tableName;
    }
  }
  /**
   * Builds inverse side property path based on given inverse side property factory.
   * This builder method should be used only after properties map of the inverse entity metadata was build.
   */
  buildInverseSidePropertyPath() {
    if (this.givenInverseSidePropertyFactory) {
      const ownerEntityPropertiesMap = this.inverseEntityMetadata.propertiesMap;
      if (typeof this.givenInverseSidePropertyFactory === "function") return this.givenInverseSidePropertyFactory(ownerEntityPropertiesMap);
      if (typeof this.givenInverseSidePropertyFactory === "string") return this.givenInverseSidePropertyFactory;
    } else if (this.isTreeParent && this.entityMetadata.treeChildrenRelation) {
      return this.entityMetadata.treeChildrenRelation.propertyName;
    } else if (this.isTreeChildren && this.entityMetadata.treeParentRelation) {
      return this.entityMetadata.treeParentRelation.propertyName;
    }
    return "";
  }
  /**
   * Builds relation's property path based on its embedded tree.
   */
  buildPropertyPath() {
    if (!this.embeddedMetadata || !this.embeddedMetadata.parentPropertyNames.length) return this.propertyName;
    return this.embeddedMetadata.parentPropertyNames.join(".") + "." + this.propertyName;
  }
};

// ../node_modules/typeorm/browser/metadata/EmbeddedMetadata.js
var EmbeddedMetadata = class {
  // ---------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------
  constructor(options) {
    this.columns = [];
    this.relations = [];
    this.listeners = [];
    this.indices = [];
    this.uniques = [];
    this.relationIds = [];
    this.relationCounts = [];
    this.embeddeds = [];
    this.isAlwaysUsingConstructor = true;
    this.isArray = false;
    this.parentPropertyNames = [];
    this.parentPrefixes = [];
    this.embeddedMetadataTree = [];
    this.columnsFromTree = [];
    this.relationsFromTree = [];
    this.listenersFromTree = [];
    this.indicesFromTree = [];
    this.uniquesFromTree = [];
    this.relationIdsFromTree = [];
    this.relationCountsFromTree = [];
    this.entityMetadata = options.entityMetadata;
    this.type = options.args.type();
    this.propertyName = options.args.propertyName;
    this.customPrefix = options.args.prefix;
    this.isArray = options.args.isArray;
  }
  // ---------------------------------------------------------------------
  // Public Methods
  // ---------------------------------------------------------------------
  /**
   * Creates a new embedded object.
   */
  create(options) {
    if (!(typeof this.type === "function")) {
      return {};
    }
    if (options?.fromDeserializer || !this.isAlwaysUsingConstructor) {
      return Object.create(this.type.prototype);
    } else {
      return new this.type();
    }
  }
  // ---------------------------------------------------------------------
  // Builder Methods
  // ---------------------------------------------------------------------
  build(connection) {
    this.embeddeds.forEach((embedded) => embedded.build(connection));
    this.prefix = this.buildPrefix(connection);
    this.parentPropertyNames = this.buildParentPropertyNames();
    this.parentPrefixes = this.buildParentPrefixes();
    this.propertyPath = this.parentPropertyNames.join(".");
    this.embeddedMetadataTree = this.buildEmbeddedMetadataTree();
    this.columnsFromTree = this.buildColumnsFromTree();
    this.relationsFromTree = this.buildRelationsFromTree();
    this.listenersFromTree = this.buildListenersFromTree();
    this.indicesFromTree = this.buildIndicesFromTree();
    this.uniquesFromTree = this.buildUniquesFromTree();
    this.relationIdsFromTree = this.buildRelationIdsFromTree();
    this.relationCountsFromTree = this.buildRelationCountsFromTree();
    if (connection.options.entitySkipConstructor) {
      this.isAlwaysUsingConstructor = !connection.options.entitySkipConstructor;
    }
    return this;
  }
  // ---------------------------------------------------------------------
  // Protected Methods
  // ---------------------------------------------------------------------
  buildPartialPrefix() {
    if (this.customPrefix === void 0 || this.customPrefix === true) {
      return [this.propertyName];
    }
    if (this.customPrefix === "" || this.customPrefix === false) {
      return [];
    }
    if (typeof this.customPrefix === "string") {
      return [this.customPrefix];
    }
    throw new TypeORMError(`Invalid prefix option given for ${this.entityMetadata.targetName}#${this.propertyName}`);
  }
  buildPrefix(connection) {
    if (connection.driver.options.type === "mongodb") return this.propertyName;
    let prefixes = [];
    if (this.parentEmbeddedMetadata) prefixes.push(this.parentEmbeddedMetadata.buildPrefix(connection));
    prefixes.push(...this.buildPartialPrefix());
    return prefixes.join("_");
  }
  buildParentPropertyNames() {
    return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildParentPropertyNames().concat(this.propertyName) : [this.propertyName];
  }
  buildParentPrefixes() {
    return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildParentPrefixes().concat(this.buildPartialPrefix()) : this.buildPartialPrefix();
  }
  buildEmbeddedMetadataTree() {
    return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildEmbeddedMetadataTree().concat(this) : [this];
  }
  buildColumnsFromTree() {
    return this.embeddeds.reduce((columns, embedded) => columns.concat(embedded.buildColumnsFromTree()), this.columns);
  }
  buildRelationsFromTree() {
    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildRelationsFromTree()), this.relations);
  }
  buildListenersFromTree() {
    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildListenersFromTree()), this.listeners);
  }
  buildIndicesFromTree() {
    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildIndicesFromTree()), this.indices);
  }
  buildUniquesFromTree() {
    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildUniquesFromTree()), this.uniques);
  }
  buildRelationIdsFromTree() {
    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildRelationIdsFromTree()), this.relationIds);
  }
  buildRelationCountsFromTree() {
    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildRelationCountsFromTree()), this.relationCounts);
  }
};

// ../node_modules/typeorm/browser/metadata/RelationIdMetadata.js
var RelationIdMetadata = class {
  // ---------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------
  constructor(options) {
    this.entityMetadata = options.entityMetadata;
    this.target = options.args.target;
    this.propertyName = options.args.propertyName;
    this.relationNameOrFactory = options.args.relation;
    this.alias = options.args.alias;
    this.queryBuilderFactory = options.args.queryBuilderFactory;
  }
  // ---------------------------------------------------------------------
  // Public Methods
  // ---------------------------------------------------------------------
  /**
   * Sets relation id value from the given entity.
   *
   * todo: make it to work in embeds as well.
   */
  setValue(entity) {
    const inverseEntity = this.relation.getEntityValue(entity);
    if (Array.isArray(inverseEntity)) {
      entity[this.propertyName] = inverseEntity.map((item) => {
        return this.relation.inverseEntityMetadata.getEntityIdMixedMap(item);
      }).filter((item) => item !== null && item !== void 0);
    } else {
      const value = this.relation.inverseEntityMetadata.getEntityIdMixedMap(inverseEntity);
      if (value !== void 0) entity[this.propertyName] = value;
    }
  }
  // ---------------------------------------------------------------------
  // Public Builder Methods
  // ---------------------------------------------------------------------
  /**
   * Builds some depend relation id properties.
   * This builder method should be used only after entity metadata, its properties map and all relations are build.
   */
  build() {
    const propertyPath = typeof this.relationNameOrFactory === "function" ? this.relationNameOrFactory(this.entityMetadata.propertiesMap) : this.relationNameOrFactory;
    const relation = this.entityMetadata.findRelationWithPropertyPath(propertyPath);
    if (!relation) throw new TypeORMError(`Cannot find relation ${propertyPath}. Wrong relation specified for @RelationId decorator.`);
    this.relation = relation;
  }
};

// ../node_modules/typeorm/browser/metadata/RelationCountMetadata.js
var RelationCountMetadata = class {
  // ---------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------
  constructor(options) {
    this.entityMetadata = options.entityMetadata;
    this.target = options.args.target;
    this.propertyName = options.args.propertyName;
    this.relationNameOrFactory = options.args.relation;
    this.alias = options.args.alias;
    this.queryBuilderFactory = options.args.queryBuilderFactory;
  }
  // ---------------------------------------------------------------------
  // Public Builder Methods
  // ---------------------------------------------------------------------
  /**
   * Builds some depend relation count metadata properties.
   * This builder method should be used only after entity metadata, its properties map and all relations are build.
   */
  build() {
    const propertyPath = typeof this.relationNameOrFactory === "function" ? this.relationNameOrFactory(this.entityMetadata.propertiesMap) : this.relationNameOrFactory;
    const relation = this.entityMetadata.findRelationWithPropertyPath(propertyPath);
    if (!relation) throw new TypeORMError(`Cannot find relation ${propertyPath}. Wrong relation specified for @RelationCount decorator.`);
    this.relation = relation;
  }
};

// ../node_modules/typeorm/browser/metadata/types/EventListenerTypes.js
var EventListenerTypes = class {
};
EventListenerTypes.AFTER_LOAD = "after-load";
EventListenerTypes.BEFORE_INSERT = "before-insert";
EventListenerTypes.AFTER_INSERT = "after-insert";
EventListenerTypes.BEFORE_UPDATE = "before-update";
EventListenerTypes.AFTER_UPDATE = "after-update";
EventListenerTypes.BEFORE_REMOVE = "before-remove";
EventListenerTypes.AFTER_REMOVE = "after-remove";
EventListenerTypes.BEFORE_SOFT_REMOVE = "before-soft-remove";
EventListenerTypes.AFTER_SOFT_REMOVE = "after-soft-remove";
EventListenerTypes.BEFORE_RECOVER = "before-recover";
EventListenerTypes.AFTER_RECOVER = "after-recover";

// ../node_modules/typeorm/browser/metadata/ForeignKeyMetadata.js
var ForeignKeyMetadata = class {
  // ---------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------
  constructor(options) {
    this.columns = [];
    this.referencedColumns = [];
    this.columnNames = [];
    this.referencedColumnNames = [];
    this.entityMetadata = options.entityMetadata;
    this.referencedEntityMetadata = options.referencedEntityMetadata;
    this.columns = options.columns;
    this.referencedColumns = options.referencedColumns;
    this.onDelete = options.onDelete || "NO ACTION";
    this.onUpdate = options.onUpdate || "NO ACTION";
    this.deferrable = options.deferrable;
    this.givenName = options.name;
    if (options.namingStrategy) this.build(options.namingStrategy);
  }
  // ---------------------------------------------------------------------
  // Public Methods
  // ---------------------------------------------------------------------
  /**
   * Builds some depend foreign key properties.
   * Must be called after all entity metadatas and their columns are built.
   */
  build(namingStrategy) {
    this.columnNames = this.columns.map((column) => column.databaseName);
    this.referencedColumnNames = this.referencedColumns.map((column) => column.databaseName);
    this.referencedTablePath = this.referencedEntityMetadata.tablePath;
    this.name = this.givenName ? this.givenName : namingStrategy.foreignKeyName(this.entityMetadata.tableName, this.columnNames, this.referencedEntityMetadata.tableName, this.referencedColumnNames);
  }
};

// ../node_modules/typeorm/browser/metadata-builder/JunctionEntityMetadataBuilder.js
var JunctionEntityMetadataBuilder = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    this.connection = connection;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Builds EntityMetadata for the junction of the given many-to-many relation.
   */
  build(relation, joinTable) {
    const referencedColumns = this.collectReferencedColumns(relation, joinTable);
    const inverseReferencedColumns = this.collectInverseReferencedColumns(relation, joinTable);
    const joinTableName = joinTable.name || this.connection.namingStrategy.joinTableName(relation.entityMetadata.tableNameWithoutPrefix, relation.inverseEntityMetadata.tableNameWithoutPrefix, relation.propertyPath, relation.inverseRelation ? relation.inverseRelation.propertyName : "");
    const entityMetadata = new EntityMetadata({
      connection: this.connection,
      args: {
        target: "",
        name: joinTableName,
        type: "junction",
        database: joinTable.database || relation.entityMetadata.database,
        schema: joinTable.schema || relation.entityMetadata.schema,
        synchronize: joinTable.synchronize
      }
    });
    entityMetadata.build();
    const junctionColumns = referencedColumns.map((referencedColumn) => {
      const joinColumn = joinTable.joinColumns ? joinTable.joinColumns.find((joinColumnArgs) => {
        return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === referencedColumn.propertyName) && !!joinColumnArgs.name;
      }) : void 0;
      const columnName = joinColumn && joinColumn.name ? joinColumn.name : this.connection.namingStrategy.joinTableColumnName(relation.entityMetadata.tableNameWithoutPrefix, referencedColumn.propertyName, referencedColumn.databaseName);
      return new ColumnMetadata({
        connection: this.connection,
        entityMetadata,
        referencedColumn,
        args: {
          target: "",
          mode: "virtual",
          propertyName: columnName,
          options: {
            name: columnName,
            length: !referencedColumn.length && (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") && // some versions of mariadb support the column type and should not try to provide the length property
            this.connection.driver.normalizeType(referencedColumn) !== "uuid" && (referencedColumn.generationStrategy === "uuid" || referencedColumn.type === "uuid") ? "36" : referencedColumn.length,
            // fix https://github.com/typeorm/typeorm/issues/3604
            width: referencedColumn.width,
            type: referencedColumn.type,
            precision: referencedColumn.precision,
            scale: referencedColumn.scale,
            charset: referencedColumn.charset,
            collation: referencedColumn.collation,
            zerofill: referencedColumn.zerofill,
            unsigned: referencedColumn.zerofill ? true : referencedColumn.unsigned,
            enum: referencedColumn.enum,
            enumName: referencedColumn.enumName,
            foreignKeyConstraintName: joinColumn?.foreignKeyConstraintName,
            nullable: false,
            primary: true
          }
        }
      });
    });
    const inverseJunctionColumns = inverseReferencedColumns.map((inverseReferencedColumn) => {
      const joinColumn = joinTable.inverseJoinColumns ? joinTable.inverseJoinColumns.find((joinColumnArgs) => {
        return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === inverseReferencedColumn.propertyName) && !!joinColumnArgs.name;
      }) : void 0;
      const columnName = joinColumn && joinColumn.name ? joinColumn.name : this.connection.namingStrategy.joinTableInverseColumnName(relation.inverseEntityMetadata.tableNameWithoutPrefix, inverseReferencedColumn.propertyName, inverseReferencedColumn.databaseName);
      return new ColumnMetadata({
        connection: this.connection,
        entityMetadata,
        referencedColumn: inverseReferencedColumn,
        args: {
          target: "",
          mode: "virtual",
          propertyName: columnName,
          options: {
            length: !inverseReferencedColumn.length && (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") && // some versions of mariadb support the column type and should not try to provide the length property
            this.connection.driver.normalizeType(inverseReferencedColumn) !== "uuid" && (inverseReferencedColumn.generationStrategy === "uuid" || inverseReferencedColumn.type === "uuid") ? "36" : inverseReferencedColumn.length,
            // fix https://github.com/typeorm/typeorm/issues/3604
            width: inverseReferencedColumn.width,
            // fix https://github.com/typeorm/typeorm/issues/6442
            type: inverseReferencedColumn.type,
            precision: inverseReferencedColumn.precision,
            scale: inverseReferencedColumn.scale,
            charset: inverseReferencedColumn.charset,
            collation: inverseReferencedColumn.collation,
            zerofill: inverseReferencedColumn.zerofill,
            unsigned: inverseReferencedColumn.zerofill ? true : inverseReferencedColumn.unsigned,
            enum: inverseReferencedColumn.enum,
            enumName: inverseReferencedColumn.enumName,
            foreignKeyConstraintName: joinColumn?.foreignKeyConstraintName,
            name: columnName,
            nullable: false,
            primary: true
          }
        }
      });
    });
    this.changeDuplicatedColumnNames(junctionColumns, inverseJunctionColumns);
    entityMetadata.ownerColumns = junctionColumns;
    entityMetadata.inverseColumns = inverseJunctionColumns;
    entityMetadata.ownColumns = [...junctionColumns, ...inverseJunctionColumns];
    entityMetadata.ownColumns.forEach((column) => column.relationMetadata = relation);
    entityMetadata.foreignKeys = relation.createForeignKeyConstraints ? [new ForeignKeyMetadata({
      entityMetadata,
      referencedEntityMetadata: relation.entityMetadata,
      columns: junctionColumns,
      referencedColumns,
      name: junctionColumns[0]?.foreignKeyConstraintName,
      onDelete: this.connection.driver.options.type === "spanner" ? "NO ACTION" : relation.onDelete || "CASCADE",
      onUpdate: this.connection.driver.options.type === "oracle" || this.connection.driver.options.type === "spanner" ? "NO ACTION" : relation.onUpdate || "CASCADE"
    }), new ForeignKeyMetadata({
      entityMetadata,
      referencedEntityMetadata: relation.inverseEntityMetadata,
      columns: inverseJunctionColumns,
      referencedColumns: inverseReferencedColumns,
      name: inverseJunctionColumns[0]?.foreignKeyConstraintName,
      onDelete: this.connection.driver.options.type === "spanner" ? "NO ACTION" : relation.inverseRelation ? relation.inverseRelation.onDelete : "CASCADE",
      onUpdate: this.connection.driver.options.type === "oracle" || this.connection.driver.options.type === "spanner" ? "NO ACTION" : relation.inverseRelation ? relation.inverseRelation.onUpdate : "CASCADE"
    })] : [];
    entityMetadata.ownIndices = [new IndexMetadata({
      entityMetadata,
      columns: junctionColumns,
      args: {
        target: entityMetadata.target,
        synchronize: true
      }
    }), new IndexMetadata({
      entityMetadata,
      columns: inverseJunctionColumns,
      args: {
        target: entityMetadata.target,
        synchronize: true
      }
    })];
    return entityMetadata;
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Collects referenced columns from the given join column args.
   */
  collectReferencedColumns(relation, joinTable) {
    const hasAnyReferencedColumnName = joinTable.joinColumns ? joinTable.joinColumns.find((joinColumn) => !!joinColumn.referencedColumnName) : false;
    if (!joinTable.joinColumns || joinTable.joinColumns && !hasAnyReferencedColumnName) {
      return relation.entityMetadata.columns.filter((column) => column.isPrimary);
    } else {
      return joinTable.joinColumns.map((joinColumn) => {
        const referencedColumn = relation.entityMetadata.columns.find((column) => column.propertyName === joinColumn.referencedColumnName);
        if (!referencedColumn) throw new TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.entityMetadata.name}`);
        return referencedColumn;
      });
    }
  }
  /**
   * Collects inverse referenced columns from the given join column args.
   */
  collectInverseReferencedColumns(relation, joinTable) {
    const hasInverseJoinColumns = !!joinTable.inverseJoinColumns;
    const hasAnyInverseReferencedColumnName = hasInverseJoinColumns ? joinTable.inverseJoinColumns.find((joinColumn) => !!joinColumn.referencedColumnName) : false;
    if (!hasInverseJoinColumns || hasInverseJoinColumns && !hasAnyInverseReferencedColumnName) {
      return relation.inverseEntityMetadata.primaryColumns;
    } else {
      return joinTable.inverseJoinColumns.map((joinColumn) => {
        const referencedColumn = relation.inverseEntityMetadata.ownColumns.find((column) => column.propertyName === joinColumn.referencedColumnName);
        if (!referencedColumn) throw new TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);
        return referencedColumn;
      });
    }
  }
  changeDuplicatedColumnNames(junctionColumns, inverseJunctionColumns) {
    junctionColumns.forEach((junctionColumn) => {
      inverseJunctionColumns.forEach((inverseJunctionColumn) => {
        if (junctionColumn.givenDatabaseName === inverseJunctionColumn.givenDatabaseName) {
          const junctionColumnName = this.connection.namingStrategy.joinTableColumnDuplicationPrefix(junctionColumn.propertyName, 1);
          junctionColumn.propertyName = junctionColumnName;
          junctionColumn.givenDatabaseName = junctionColumnName;
          const inverseJunctionColumnName = this.connection.namingStrategy.joinTableColumnDuplicationPrefix(inverseJunctionColumn.propertyName, 2);
          inverseJunctionColumn.propertyName = inverseJunctionColumnName;
          inverseJunctionColumn.givenDatabaseName = inverseJunctionColumnName;
        }
      });
    });
  }
};

// ../node_modules/typeorm/browser/metadata-builder/ClosureJunctionEntityMetadataBuilder.js
var ClosureJunctionEntityMetadataBuilder = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    this.connection = connection;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Builds EntityMetadata for the closure junction of the given closure entity.
   */
  build(parentClosureEntityMetadata) {
    const entityMetadata = new EntityMetadata({
      parentClosureEntityMetadata,
      connection: this.connection,
      args: {
        target: "",
        name: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.closureTableName ? parentClosureEntityMetadata.treeOptions.closureTableName : parentClosureEntityMetadata.tableNameWithoutPrefix,
        type: "closure-junction"
      }
    });
    entityMetadata.build();
    parentClosureEntityMetadata.primaryColumns.forEach((primaryColumn) => {
      entityMetadata.ownColumns.push(new ColumnMetadata({
        connection: this.connection,
        entityMetadata,
        closureType: "ancestor",
        referencedColumn: primaryColumn,
        args: {
          target: "",
          mode: "virtual",
          propertyName: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.ancestorColumnName ? parentClosureEntityMetadata.treeOptions.ancestorColumnName(primaryColumn) : primaryColumn.propertyName + "_ancestor",
          options: {
            primary: true,
            length: primaryColumn.length,
            type: primaryColumn.type
          }
        }
      }));
      entityMetadata.ownColumns.push(new ColumnMetadata({
        connection: this.connection,
        entityMetadata,
        closureType: "descendant",
        referencedColumn: primaryColumn,
        args: {
          target: "",
          mode: "virtual",
          propertyName: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.descendantColumnName ? parentClosureEntityMetadata.treeOptions.descendantColumnName(primaryColumn) : primaryColumn.propertyName + "_descendant",
          options: {
            primary: true,
            length: primaryColumn.length,
            type: primaryColumn.type
          }
        }
      }));
    });
    entityMetadata.ownIndices = [new IndexMetadata({
      entityMetadata,
      columns: [entityMetadata.ownColumns[0]],
      args: {
        target: entityMetadata.target,
        synchronize: true
      }
    }), new IndexMetadata({
      entityMetadata,
      columns: [entityMetadata.ownColumns[1]],
      args: {
        target: entityMetadata.target,
        synchronize: true
      }
    })];
    if (parentClosureEntityMetadata.treeLevelColumn) {
      entityMetadata.ownColumns.push(new ColumnMetadata({
        connection: this.connection,
        entityMetadata,
        args: {
          target: "",
          mode: "virtual",
          propertyName: "level",
          options: {
            type: this.connection.driver.mappedDataTypes.treeLevel
          }
        }
      }));
    }
    entityMetadata.foreignKeys = [new ForeignKeyMetadata({
      entityMetadata,
      referencedEntityMetadata: parentClosureEntityMetadata,
      columns: [entityMetadata.ownColumns[0]],
      referencedColumns: parentClosureEntityMetadata.primaryColumns,
      onDelete: this.connection.driver.options.type === "mssql" ? "NO ACTION" : "CASCADE"
    }), new ForeignKeyMetadata({
      entityMetadata,
      referencedEntityMetadata: parentClosureEntityMetadata,
      columns: [entityMetadata.ownColumns[1]],
      referencedColumns: parentClosureEntityMetadata.primaryColumns,
      onDelete: this.connection.driver.options.type === "mssql" ? "NO ACTION" : "CASCADE"
    })];
    return entityMetadata;
  }
};

// ../node_modules/typeorm/browser/metadata/UniqueMetadata.js
var UniqueMetadata = class {
  // ---------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------
  constructor(options) {
    this.columns = [];
    this.columnNamesWithOrderingMap = {};
    this.entityMetadata = options.entityMetadata;
    this.embeddedMetadata = options.embeddedMetadata;
    if (options.columns) this.columns = options.columns;
    if (options.args) {
      this.target = options.args.target;
      this.givenName = options.args.name;
      this.givenColumnNames = options.args.columns;
      this.deferrable = options.args.deferrable;
    }
  }
  // ---------------------------------------------------------------------
  // Public Build Methods
  // ---------------------------------------------------------------------
  /**
   * Builds some depend unique constraint properties.
   * Must be called after all entity metadata's properties map, columns and relations are built.
   */
  build(namingStrategy) {
    const map = {};
    if (this.givenColumnNames) {
      let columnPropertyPaths = [];
      if (Array.isArray(this.givenColumnNames)) {
        columnPropertyPaths = this.givenColumnNames.map((columnName) => {
          if (this.embeddedMetadata) return this.embeddedMetadata.propertyPath + "." + columnName;
          return columnName.trim();
        });
        columnPropertyPaths.forEach((propertyPath) => map[propertyPath] = 1);
      } else {
        const columnsFnResult = this.givenColumnNames(this.entityMetadata.propertiesMap);
        if (Array.isArray(columnsFnResult)) {
          columnPropertyPaths = columnsFnResult.map((i) => String(i));
          columnPropertyPaths.forEach((name) => map[name] = 1);
        } else {
          columnPropertyPaths = Object.keys(columnsFnResult).map((i) => String(i));
          Object.keys(columnsFnResult).forEach((columnName) => map[columnName] = columnsFnResult[columnName]);
        }
      }
      this.columns = columnPropertyPaths.map((propertyName) => {
        const columnWithSameName = this.entityMetadata.columns.find((column) => column.propertyPath === propertyName);
        if (columnWithSameName) {
          return [columnWithSameName];
        }
        const relationWithSameName = this.entityMetadata.relations.find((relation) => relation.isWithJoinColumn && relation.propertyName === propertyName);
        if (relationWithSameName) {
          return relationWithSameName.joinColumns;
        }
        const indexName = this.givenName ? '"' + this.givenName + '" ' : "";
        const entityName = this.entityMetadata.targetName;
        throw new TypeORMError(`Unique constraint ${indexName}contains column that is missing in the entity (${entityName}): ` + propertyName);
      }).reduce((a, b) => a.concat(b));
    }
    this.columnNamesWithOrderingMap = Object.keys(map).reduce((updatedMap, key) => {
      const column = this.entityMetadata.columns.find((column2) => column2.propertyPath === key);
      if (column) updatedMap[column.databasePath] = map[key];
      return updatedMap;
    }, {});
    this.name = this.givenName ? this.givenName : namingStrategy.uniqueConstraintName(this.entityMetadata.tableName, this.columns.map((column) => column.databaseName));
    return this;
  }
};

// ../node_modules/typeorm/browser/metadata-builder/RelationJoinColumnBuilder.js
var RelationJoinColumnBuilder = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    this.connection = connection;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Builds a foreign key of the many-to-one or one-to-one owner relations.
   */
  build(joinColumns, relation) {
    const referencedColumns = this.collectReferencedColumns(joinColumns, relation);
    const columns = this.collectColumns(joinColumns, relation, referencedColumns);
    if (!referencedColumns.length || !relation.createForeignKeyConstraints) return {
      foreignKey: void 0,
      columns,
      uniqueConstraint: void 0
    };
    const foreignKey = new ForeignKeyMetadata({
      name: joinColumns[0]?.foreignKeyConstraintName,
      entityMetadata: relation.entityMetadata,
      referencedEntityMetadata: relation.inverseEntityMetadata,
      namingStrategy: this.connection.namingStrategy,
      columns,
      referencedColumns,
      onDelete: relation.onDelete,
      onUpdate: relation.onUpdate,
      deferrable: relation.deferrable
    });
    if (columns.every((column) => column.isPrimary) || !relation.isOneToOne) {
      return {
        foreignKey,
        columns,
        uniqueConstraint: void 0
      };
    }
    const uniqueConstraint = new UniqueMetadata({
      entityMetadata: relation.entityMetadata,
      columns: foreignKey.columns,
      args: {
        name: this.connection.namingStrategy.relationConstraintName(relation.entityMetadata.tableName, foreignKey.columns.map((column) => column.databaseName)),
        target: relation.entityMetadata.target
      }
    });
    uniqueConstraint.build(this.connection.namingStrategy);
    return {
      foreignKey,
      columns,
      uniqueConstraint
    };
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Collects referenced columns from the given join column args.
   */
  collectReferencedColumns(joinColumns, relation) {
    const hasAnyReferencedColumnName = joinColumns.find((joinColumnArgs) => !!joinColumnArgs.referencedColumnName);
    const manyToOneWithoutJoinColumn = joinColumns.length === 0 && relation.isManyToOne;
    const hasJoinColumnWithoutAnyReferencedColumnName = joinColumns.length > 0 && !hasAnyReferencedColumnName;
    if (manyToOneWithoutJoinColumn || hasJoinColumnWithoutAnyReferencedColumnName) {
      return relation.inverseEntityMetadata.primaryColumns;
    } else {
      return joinColumns.map((joinColumn) => {
        const referencedColumn = relation.inverseEntityMetadata.ownColumns.find((column) => column.propertyName === joinColumn.referencedColumnName);
        if (!referencedColumn) throw new TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);
        return referencedColumn;
      });
    }
  }
  /**
   * Collects columns from the given join column args.
   */
  collectColumns(joinColumns, relation, referencedColumns) {
    return referencedColumns.map((referencedColumn) => {
      const joinColumnMetadataArg = joinColumns.find((joinColumn) => {
        return (!joinColumn.referencedColumnName || joinColumn.referencedColumnName === referencedColumn.propertyName) && !!joinColumn.name;
      });
      const joinColumnName = joinColumnMetadataArg ? joinColumnMetadataArg.name : this.connection.namingStrategy.joinColumnName(relation.propertyName, referencedColumn.propertyName);
      const relationalColumns = relation.embeddedMetadata ? relation.embeddedMetadata.columns : relation.entityMetadata.ownColumns;
      let relationalColumn = relationalColumns.find((column) => column.databaseNameWithoutPrefixes === joinColumnName);
      if (!relationalColumn) {
        relationalColumn = new ColumnMetadata({
          connection: this.connection,
          entityMetadata: relation.entityMetadata,
          embeddedMetadata: relation.embeddedMetadata,
          args: {
            target: "",
            mode: "virtual",
            propertyName: relation.propertyName,
            options: {
              name: joinColumnName,
              type: referencedColumn.type,
              length: !referencedColumn.length && (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") && // some versions of mariadb support the column type and should not try to provide the length property
              this.connection.driver.normalizeType(referencedColumn) !== "uuid" && (referencedColumn.generationStrategy === "uuid" || referencedColumn.type === "uuid") ? "36" : referencedColumn.length,
              // fix https://github.com/typeorm/typeorm/issues/3604
              width: referencedColumn.width,
              charset: referencedColumn.charset,
              collation: referencedColumn.collation,
              precision: referencedColumn.precision,
              scale: referencedColumn.scale,
              zerofill: referencedColumn.zerofill,
              unsigned: referencedColumn.unsigned,
              comment: referencedColumn.comment,
              enum: referencedColumn.enum,
              enumName: referencedColumn.enumName,
              primary: relation.isPrimary,
              nullable: relation.isNullable
            }
          }
        });
        relation.entityMetadata.registerColumn(relationalColumn);
      }
      relationalColumn.referencedColumn = referencedColumn;
      relationalColumn.type = referencedColumn.type;
      relationalColumn.relationMetadata = relation;
      relationalColumn.build(this.connection);
      return relationalColumn;
    });
  }
};

// ../node_modules/typeorm/browser/metadata/EntityListenerMetadata.js
var EntityListenerMetadata = class {
  // ---------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------
  constructor(options) {
    this.entityMetadata = options.entityMetadata;
    this.embeddedMetadata = options.embeddedMetadata;
    this.target = options.args.target;
    this.propertyName = options.args.propertyName;
    this.type = options.args.type;
  }
  // ---------------------------------------------------------------------
  // Public Methods
  // ---------------------------------------------------------------------
  /**
   * Checks if entity listener is allowed to be executed on the given entity.
   */
  isAllowed(entity) {
    return this.entityMetadata.target === entity.constructor || // todo: .constructor won't work for entity schemas, but there are no entity listeners in schemas since there are no objects, right?
    typeof this.entityMetadata.target === "function" && entity.constructor.prototype instanceof this.entityMetadata.target;
  }
  /**
   * Executes listener method of the given entity.
   */
  execute(entity) {
    if (!this.embeddedMetadata) return entity[this.propertyName]();
    this.callEntityEmbeddedMethod(entity, this.embeddedMetadata.propertyPath.split("."));
  }
  // ---------------------------------------------------------------------
  // Protected Methods
  // ---------------------------------------------------------------------
  /**
   * Calls embedded entity listener method no matter how nested it is.
   */
  callEntityEmbeddedMethod(entity, propertyPaths) {
    const propertyPath = propertyPaths.shift();
    if (!propertyPath || !entity[propertyPath]) return;
    if (propertyPaths.length === 0) {
      if (Array.isArray(entity[propertyPath])) {
        entity[propertyPath].map((embedded) => embedded[this.propertyName]());
      } else {
        entity[propertyPath][this.propertyName]();
      }
    } else {
      if (entity[propertyPath]) this.callEntityEmbeddedMethod(entity[propertyPath], propertyPaths);
    }
  }
};

// ../node_modules/typeorm/browser/metadata/CheckMetadata.js
var CheckMetadata = class {
  // ---------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------
  constructor(options) {
    this.entityMetadata = options.entityMetadata;
    if (options.args) {
      this.target = options.args.target;
      this.expression = options.args.expression;
      this.givenName = options.args.name;
    }
  }
  // ---------------------------------------------------------------------
  // Public Build Methods
  // ---------------------------------------------------------------------
  /**
   * Builds some depend check constraint properties.
   * Must be called after all entity metadata's properties map, columns and relations are built.
   */
  build(namingStrategy) {
    this.name = this.givenName ? this.givenName : namingStrategy.checkConstraintName(this.entityMetadata.tableName, this.expression);
    return this;
  }
};

// ../node_modules/typeorm/browser/metadata/ExclusionMetadata.js
var ExclusionMetadata = class {
  // ---------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------
  constructor(options) {
    this.entityMetadata = options.entityMetadata;
    if (options.args) {
      this.target = options.args.target;
      this.expression = options.args.expression;
      this.givenName = options.args.name;
    }
  }
  // ---------------------------------------------------------------------
  // Public Build Methods
  // ---------------------------------------------------------------------
  /**
   * Builds some depend exclusion constraint properties.
   * Must be called after all entity metadata's properties map, columns and relations are built.
   */
  build(namingStrategy) {
    this.name = this.givenName ? this.givenName : namingStrategy.exclusionConstraintName(this.entityMetadata.tableName, this.expression);
    return this;
  }
};

// ../node_modules/typeorm/browser/metadata-builder/EntityMetadataBuilder.js
var EntityMetadataBuilder = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection, metadataArgsStorage) {
    this.connection = connection;
    this.metadataArgsStorage = metadataArgsStorage;
    this.junctionEntityMetadataBuilder = new JunctionEntityMetadataBuilder(connection);
    this.closureJunctionEntityMetadataBuilder = new ClosureJunctionEntityMetadataBuilder(connection);
    this.relationJoinColumnBuilder = new RelationJoinColumnBuilder(connection);
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Builds a complete entity metadatas for the given entity classes.
   */
  build(entityClasses) {
    const allTables = entityClasses ? this.metadataArgsStorage.filterTables(entityClasses) : this.metadataArgsStorage.tables;
    const realTables = allTables.filter((table) => table.type === "regular" || table.type === "closure" || table.type === "entity-child" || table.type === "view");
    const entityMetadatas = realTables.map((tableArgs) => this.createEntityMetadata(tableArgs));
    entityMetadatas.forEach((entityMetadata) => this.computeParentEntityMetadata(entityMetadatas, entityMetadata));
    entityMetadatas.forEach((metadata) => {
      metadata.childEntityMetadatas = entityMetadatas.filter((childMetadata) => {
        return typeof metadata.target === "function" && typeof childMetadata.target === "function" && MetadataUtils.isInherited(childMetadata.target, metadata.target);
      });
    });
    entityMetadatas.filter((entityMetadata) => entityMetadata.tableType !== "entity-child").forEach((entityMetadata) => entityMetadata.build());
    entityMetadatas.filter((entityMetadata) => entityMetadata.tableType === "entity-child").forEach((entityMetadata) => entityMetadata.build());
    entityMetadatas.filter((entityMetadata) => entityMetadata.tableType !== "entity-child").forEach((entityMetadata) => this.computeEntityMetadataStep1(entityMetadatas, entityMetadata));
    entityMetadatas.filter((entityMetadata) => entityMetadata.tableType === "entity-child").forEach((entityMetadata) => this.computeEntityMetadataStep1(entityMetadatas, entityMetadata));
    entityMetadatas.forEach((entityMetadata) => this.computeEntityMetadataStep2(entityMetadata));
    entityMetadatas.forEach((entityMetadata) => this.computeInverseProperties(entityMetadata, entityMetadatas));
    entityMetadatas.filter((entityMetadata) => entityMetadata.tableType !== "entity-child").forEach((entityMetadata) => {
      entityMetadata.relations.filter((relation) => relation.isOneToOne || relation.isManyToOne).forEach((relation) => {
        const joinColumns = this.metadataArgsStorage.filterJoinColumns(relation.target, relation.propertyName);
        const {
          foreignKey,
          columns,
          uniqueConstraint
        } = this.relationJoinColumnBuilder.build(joinColumns, relation);
        if (foreignKey) {
          relation.registerForeignKeys(foreignKey);
          entityMetadata.foreignKeys.push(foreignKey);
        }
        if (columns) {
          relation.registerJoinColumns(columns);
        }
        if (uniqueConstraint) {
          if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql" || this.connection.driver.options.type === "mssql" || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") {
            const index = new IndexMetadata({
              entityMetadata: uniqueConstraint.entityMetadata,
              columns: uniqueConstraint.columns,
              args: {
                target: uniqueConstraint.target,
                name: uniqueConstraint.name,
                unique: true,
                synchronize: true
              }
            });
            if (this.connection.driver.options.type === "mssql") {
              index.where = index.columns.map((column) => {
                return `${this.connection.driver.escape(column.databaseName)} IS NOT NULL`;
              }).join(" AND ");
            }
            if (this.connection.driver.options.type === "spanner") {
              index.isNullFiltered = true;
            }
            if (relation.embeddedMetadata) {
              relation.embeddedMetadata.indices.push(index);
            } else {
              relation.entityMetadata.ownIndices.push(index);
            }
            this.computeEntityMetadataStep2(entityMetadata);
          } else {
            if (relation.embeddedMetadata) {
              relation.embeddedMetadata.uniques.push(uniqueConstraint);
            } else {
              relation.entityMetadata.ownUniques.push(uniqueConstraint);
            }
            this.computeEntityMetadataStep2(entityMetadata);
          }
        }
        if (foreignKey && this.connection.driver.options.type === "cockroachdb") {
          const index = new IndexMetadata({
            entityMetadata: relation.entityMetadata,
            columns: foreignKey.columns,
            args: {
              target: relation.entityMetadata.target,
              synchronize: true
            }
          });
          if (relation.embeddedMetadata) {
            relation.embeddedMetadata.indices.push(index);
          } else {
            relation.entityMetadata.ownIndices.push(index);
          }
          this.computeEntityMetadataStep2(entityMetadata);
        }
      });
      entityMetadata.relations.filter((relation) => relation.isManyToMany).forEach((relation) => {
        const joinTable = this.metadataArgsStorage.findJoinTable(relation.target, relation.propertyName);
        if (!joinTable) return;
        const junctionEntityMetadata = this.junctionEntityMetadataBuilder.build(relation, joinTable);
        relation.registerForeignKeys(...junctionEntityMetadata.foreignKeys);
        relation.registerJoinColumns(junctionEntityMetadata.ownIndices[0].columns, junctionEntityMetadata.ownIndices[1].columns);
        relation.registerJunctionEntityMetadata(junctionEntityMetadata);
        this.computeEntityMetadataStep2(junctionEntityMetadata);
        this.computeInverseProperties(junctionEntityMetadata, entityMetadatas);
        entityMetadatas.push(junctionEntityMetadata);
      });
    });
    entityMetadatas.forEach((entityMetadata) => {
      entityMetadata.relationsWithJoinColumns = entityMetadata.relations.filter((relation) => relation.isWithJoinColumn);
      entityMetadata.hasNonNullableRelations = entityMetadata.relationsWithJoinColumns.some((relation) => !relation.isNullable || relation.isPrimary);
    });
    entityMetadatas.filter((metadata) => metadata.treeType === "closure-table").forEach((entityMetadata) => {
      const closureJunctionEntityMetadata = this.closureJunctionEntityMetadataBuilder.build(entityMetadata);
      entityMetadata.closureJunctionTable = closureJunctionEntityMetadata;
      this.computeEntityMetadataStep2(closureJunctionEntityMetadata);
      this.computeInverseProperties(closureJunctionEntityMetadata, entityMetadatas);
      entityMetadatas.push(closureJunctionEntityMetadata);
    });
    entityMetadatas.filter((metadata) => metadata.inheritancePattern === "STI" && metadata.discriminatorColumn).forEach((entityMetadata) => this.createKeysForTableInheritance(entityMetadata));
    entityMetadatas.forEach((entityMetadata) => {
      entityMetadata.indices.forEach((index) => index.build(this.connection.namingStrategy));
    });
    entityMetadatas.forEach((entityMetadata) => {
      entityMetadata.uniques.forEach((unique) => unique.build(this.connection.namingStrategy));
    });
    entityMetadatas.forEach((entityMetadata) => {
      entityMetadata.checks.forEach((check) => check.build(this.connection.namingStrategy));
    });
    entityMetadatas.forEach((entityMetadata) => {
      entityMetadata.exclusions.forEach((exclusion) => exclusion.build(this.connection.namingStrategy));
    });
    entityMetadatas.filter((metadata) => typeof metadata.target === "function").forEach((entityMetadata) => {
      entityMetadata.relations.filter((relation) => relation.isLazy).forEach((relation) => {
        this.connection.relationLoader.enableLazyLoad(relation, entityMetadata.target.prototype);
      });
    });
    entityMetadatas.forEach((entityMetadata) => {
      entityMetadata.columns.forEach((column) => {
        const generated = this.metadataArgsStorage.findGenerated(column.target, column.propertyName);
        if (generated) {
          column.isGenerated = true;
          column.generationStrategy = generated.strategy;
          if (generated.strategy === "uuid") {
            column.type = "uuid";
          } else if (generated.strategy === "rowid") {
            column.type = "int";
          } else {
            column.type = column.type || Number;
          }
          column.build(this.connection);
          this.computeEntityMetadataStep2(entityMetadata);
        }
      });
    });
    return entityMetadatas;
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Creates entity metadata from the given table args.
   * Creates column, relation, etc. metadatas for everything this entity metadata owns.
   */
  createEntityMetadata(tableArgs) {
    const inheritanceTree = typeof tableArgs.target === "function" ? MetadataUtils.getInheritanceTree(tableArgs.target) : [tableArgs.target];
    const tableInheritance = this.metadataArgsStorage.findInheritanceType(tableArgs.target);
    const tableTree = this.metadataArgsStorage.findTree(tableArgs.target);
    let singleTableChildrenTargets;
    if (tableInheritance && tableInheritance.pattern === "STI" || tableArgs.type === "entity-child") {
      singleTableChildrenTargets = this.metadataArgsStorage.filterSingleTableChildren(tableArgs.target).map((args) => args.target).filter((target) => typeof target === "function");
      inheritanceTree.push(...singleTableChildrenTargets);
    }
    return new EntityMetadata({
      connection: this.connection,
      args: tableArgs,
      inheritanceTree,
      tableTree,
      inheritancePattern: tableInheritance ? tableInheritance.pattern : void 0
    });
  }
  computeParentEntityMetadata(allEntityMetadatas, entityMetadata) {
    if (entityMetadata.tableType === "entity-child") {
      entityMetadata.parentEntityMetadata = allEntityMetadatas.find((allEntityMetadata) => {
        return allEntityMetadata.inheritanceTree.indexOf(entityMetadata.target) !== -1 && allEntityMetadata.inheritancePattern === "STI";
      });
    }
  }
  computeEntityMetadataStep1(allEntityMetadatas, entityMetadata) {
    const entityInheritance = this.metadataArgsStorage.findInheritanceType(entityMetadata.target);
    const discriminatorValue = this.metadataArgsStorage.findDiscriminatorValue(entityMetadata.target);
    if (typeof discriminatorValue !== "undefined") {
      entityMetadata.discriminatorValue = discriminatorValue.value;
    } else {
      entityMetadata.discriminatorValue = entityMetadata.target.name;
    }
    entityMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(entityMetadata.inheritanceTree)).map((embedded) => {
      if (entityMetadata.inheritancePattern === "STI") {
        embedded.columns = embedded.columns.map((column) => {
          column.isNullable = true;
          return column;
        });
      }
      return embedded;
    });
    entityMetadata.ownColumns = this.metadataArgsStorage.filterColumns(entityMetadata.inheritanceTree).map((args) => {
      if (entityMetadata.tableType === "entity-child") return entityMetadata.parentEntityMetadata.ownColumns.find((column2) => column2.propertyName === args.propertyName);
      if (entityMetadata.tableType === "regular" && args.target !== entityMetadata.target) {
        const childArgs = this.metadataArgsStorage.columns.find((c) => c.propertyName === args.propertyName && c.target === entityMetadata.target);
        if (childArgs && childArgs.options.default) {
          args.options.default = childArgs.options.default;
        }
      }
      const column = new ColumnMetadata({
        connection: this.connection,
        entityMetadata,
        args
      });
      const columnInSingleTableInheritedChild = allEntityMetadatas.find((otherEntityMetadata) => otherEntityMetadata.tableType === "entity-child" && otherEntityMetadata.target === args.target);
      if (columnInSingleTableInheritedChild) column.isNullable = true;
      return column;
    });
    if (entityInheritance && entityInheritance.column) {
      const discriminatorColumnName = entityInheritance.column && entityInheritance.column.name ? entityInheritance.column.name : "type";
      let discriminatorColumn = entityMetadata.ownColumns.find((column) => column.propertyName === discriminatorColumnName);
      if (!discriminatorColumn) {
        discriminatorColumn = new ColumnMetadata({
          connection: this.connection,
          entityMetadata,
          args: {
            target: entityMetadata.target,
            mode: "virtual",
            propertyName: discriminatorColumnName,
            options: entityInheritance.column || {
              name: discriminatorColumnName,
              type: "varchar",
              nullable: false
            }
          }
        });
        discriminatorColumn.isVirtual = true;
        discriminatorColumn.isDiscriminator = true;
        entityMetadata.ownColumns.push(discriminatorColumn);
      } else {
        discriminatorColumn.isDiscriminator = true;
      }
    }
    if (entityMetadata.tableType === "entity-child") {
      const discriminatorColumn = entityMetadata.parentEntityMetadata.ownColumns.find((column) => column.isDiscriminator);
      if (discriminatorColumn && !entityMetadata.ownColumns.find((column) => column === discriminatorColumn)) {
        entityMetadata.ownColumns.push(discriminatorColumn);
      }
      entityMetadata.inheritancePattern = entityMetadata.parentEntityMetadata.inheritancePattern;
      if (!entityMetadata.treeType && !!entityMetadata.parentEntityMetadata.treeType) {
        entityMetadata.treeType = entityMetadata.parentEntityMetadata.treeType;
        entityMetadata.treeOptions = entityMetadata.parentEntityMetadata.treeOptions;
        entityMetadata.treeParentRelation = entityMetadata.parentEntityMetadata.treeParentRelation;
        entityMetadata.treeLevelColumn = entityMetadata.parentEntityMetadata.treeLevelColumn;
      }
    }
    const {
      namingStrategy
    } = this.connection;
    if (entityMetadata.treeType === "materialized-path") {
      entityMetadata.ownColumns.push(new ColumnMetadata({
        connection: this.connection,
        entityMetadata,
        materializedPath: true,
        args: {
          target: entityMetadata.target,
          mode: "virtual",
          propertyName: "mpath",
          options: (
            /*tree.column || */
            {
              name: namingStrategy.materializedPathColumnName,
              type: String,
              nullable: true,
              default: ""
            }
          )
        }
      }));
    } else if (entityMetadata.treeType === "nested-set") {
      const {
        left,
        right
      } = namingStrategy.nestedSetColumnNames;
      entityMetadata.ownColumns.push(new ColumnMetadata({
        connection: this.connection,
        entityMetadata,
        nestedSetLeft: true,
        args: {
          target: entityMetadata.target,
          mode: "virtual",
          propertyName: left,
          options: (
            /*tree.column || */
            {
              name: left,
              type: Number,
              nullable: false,
              default: 1
            }
          )
        }
      }));
      entityMetadata.ownColumns.push(new ColumnMetadata({
        connection: this.connection,
        entityMetadata,
        nestedSetRight: true,
        args: {
          target: entityMetadata.target,
          mode: "virtual",
          propertyName: right,
          options: (
            /*tree.column || */
            {
              name: right,
              type: Number,
              nullable: false,
              default: 2
            }
          )
        }
      }));
    }
    entityMetadata.ownRelations = this.metadataArgsStorage.filterRelations(entityMetadata.inheritanceTree).map((args) => {
      if (entityMetadata.tableType === "entity-child") {
        const parentRelation = entityMetadata.parentEntityMetadata.ownRelations.find((relation) => relation.propertyName === args.propertyName);
        const type = typeof args.type === "function" ? args.type() : args.type;
        if (parentRelation.type !== type) {
          const clone = Object.create(parentRelation);
          clone.type = type;
          return clone;
        }
        return parentRelation;
      }
      return new RelationMetadata({
        entityMetadata,
        args
      });
    });
    entityMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(entityMetadata.inheritanceTree).map((args) => {
      if (entityMetadata.tableType === "entity-child") return entityMetadata.parentEntityMetadata.relationIds.find((relationId) => relationId.propertyName === args.propertyName);
      return new RelationIdMetadata({
        entityMetadata,
        args
      });
    });
    entityMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(entityMetadata.inheritanceTree).map((args) => {
      if (entityMetadata.tableType === "entity-child") return entityMetadata.parentEntityMetadata.relationCounts.find((relationCount) => relationCount.propertyName === args.propertyName);
      return new RelationCountMetadata({
        entityMetadata,
        args
      });
    });
    entityMetadata.ownListeners = this.metadataArgsStorage.filterListeners(entityMetadata.inheritanceTree).map((args) => {
      return new EntityListenerMetadata({
        entityMetadata,
        args
      });
    });
    entityMetadata.checks = this.metadataArgsStorage.filterChecks(entityMetadata.inheritanceTree).map((args) => {
      return new CheckMetadata({
        entityMetadata,
        args
      });
    });
    if (this.connection.driver.options.type === "postgres") {
      entityMetadata.exclusions = this.metadataArgsStorage.filterExclusions(entityMetadata.inheritanceTree).map((args) => {
        return new ExclusionMetadata({
          entityMetadata,
          args
        });
      });
    }
    if (this.connection.driver.options.type === "cockroachdb") {
      entityMetadata.ownIndices = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).filter((args) => !args.unique).map((args) => {
        return new IndexMetadata({
          entityMetadata,
          args
        });
      });
      const uniques = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).filter((args) => args.unique).map((args) => {
        return new UniqueMetadata({
          entityMetadata,
          args: {
            target: args.target,
            name: args.name,
            columns: args.columns
          }
        });
      });
      entityMetadata.ownUniques.push(...uniques);
    } else {
      entityMetadata.ownIndices = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).map((args) => {
        return new IndexMetadata({
          entityMetadata,
          args
        });
      });
    }
    if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql" || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") {
      const indices = this.metadataArgsStorage.filterUniques(entityMetadata.inheritanceTree).map((args) => {
        return new IndexMetadata({
          entityMetadata,
          args: {
            target: args.target,
            name: args.name,
            columns: args.columns,
            unique: true,
            synchronize: true
          }
        });
      });
      entityMetadata.ownIndices.push(...indices);
    } else {
      const uniques = this.metadataArgsStorage.filterUniques(entityMetadata.inheritanceTree).map((args) => {
        return new UniqueMetadata({
          entityMetadata,
          args
        });
      });
      entityMetadata.ownUniques.push(...uniques);
    }
  }
  /**
   * Creates from the given embedded metadata args real embedded metadatas with its columns and relations,
   * and does the same for all its sub-embeddeds (goes recursively).
   */
  createEmbeddedsRecursively(entityMetadata, embeddedArgs) {
    return embeddedArgs.map((embeddedArgs2) => {
      const embeddedMetadata = new EmbeddedMetadata({
        entityMetadata,
        args: embeddedArgs2
      });
      const targets = typeof embeddedMetadata.type === "function" ? MetadataUtils.getInheritanceTree(embeddedMetadata.type) : [embeddedMetadata.type];
      embeddedMetadata.columns = this.metadataArgsStorage.filterColumns(targets).map((args) => {
        return new ColumnMetadata({
          connection: this.connection,
          entityMetadata,
          embeddedMetadata,
          args
        });
      });
      embeddedMetadata.relations = this.metadataArgsStorage.filterRelations(targets).map((args) => {
        return new RelationMetadata({
          entityMetadata,
          embeddedMetadata,
          args
        });
      });
      embeddedMetadata.listeners = this.metadataArgsStorage.filterListeners(targets).map((args) => {
        return new EntityListenerMetadata({
          entityMetadata,
          embeddedMetadata,
          args
        });
      });
      embeddedMetadata.indices = this.metadataArgsStorage.filterIndices(targets).map((args) => {
        return new IndexMetadata({
          entityMetadata,
          embeddedMetadata,
          args
        });
      });
      embeddedMetadata.uniques = this.metadataArgsStorage.filterUniques(targets).map((args) => {
        return new UniqueMetadata({
          entityMetadata,
          embeddedMetadata,
          args
        });
      });
      embeddedMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(targets).map((args) => {
        return new RelationIdMetadata({
          entityMetadata,
          args
        });
      });
      embeddedMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(targets).map((args) => {
        return new RelationCountMetadata({
          entityMetadata,
          args
        });
      });
      embeddedMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(targets));
      embeddedMetadata.embeddeds.forEach((subEmbedded) => subEmbedded.parentEmbeddedMetadata = embeddedMetadata);
      entityMetadata.allEmbeddeds.push(embeddedMetadata);
      return embeddedMetadata;
    });
  }
  /**
   * Computes all entity metadata's computed properties, and all its sub-metadatas (relations, columns, embeds, etc).
   */
  computeEntityMetadataStep2(entityMetadata) {
    entityMetadata.embeddeds.forEach((embedded) => embedded.build(this.connection));
    entityMetadata.embeddeds.forEach((embedded) => {
      embedded.columnsFromTree.forEach((column) => column.build(this.connection));
      embedded.relationsFromTree.forEach((relation) => relation.build());
    });
    entityMetadata.ownColumns.forEach((column) => column.build(this.connection));
    entityMetadata.ownRelations.forEach((relation) => relation.build());
    entityMetadata.relations = entityMetadata.embeddeds.reduce((relations, embedded) => relations.concat(embedded.relationsFromTree), entityMetadata.ownRelations);
    entityMetadata.eagerRelations = entityMetadata.relations.filter((relation) => relation.isEager);
    entityMetadata.lazyRelations = entityMetadata.relations.filter((relation) => relation.isLazy);
    entityMetadata.oneToOneRelations = entityMetadata.relations.filter((relation) => relation.isOneToOne);
    entityMetadata.oneToManyRelations = entityMetadata.relations.filter((relation) => relation.isOneToMany);
    entityMetadata.manyToOneRelations = entityMetadata.relations.filter((relation) => relation.isManyToOne);
    entityMetadata.manyToManyRelations = entityMetadata.relations.filter((relation) => relation.isManyToMany);
    entityMetadata.ownerOneToOneRelations = entityMetadata.relations.filter((relation) => relation.isOneToOneOwner);
    entityMetadata.ownerManyToManyRelations = entityMetadata.relations.filter((relation) => relation.isManyToManyOwner);
    entityMetadata.treeParentRelation = entityMetadata.relations.find((relation) => relation.isTreeParent);
    entityMetadata.treeChildrenRelation = entityMetadata.relations.find((relation) => relation.isTreeChildren);
    entityMetadata.columns = entityMetadata.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), entityMetadata.ownColumns);
    entityMetadata.listeners = entityMetadata.embeddeds.reduce((listeners, embedded) => listeners.concat(embedded.listenersFromTree), entityMetadata.ownListeners);
    entityMetadata.afterLoadListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.AFTER_LOAD);
    entityMetadata.afterInsertListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.AFTER_INSERT);
    entityMetadata.afterUpdateListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.AFTER_UPDATE);
    entityMetadata.afterRemoveListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.AFTER_REMOVE);
    entityMetadata.afterSoftRemoveListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.AFTER_SOFT_REMOVE);
    entityMetadata.afterRecoverListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.AFTER_RECOVER);
    entityMetadata.beforeInsertListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.BEFORE_INSERT);
    entityMetadata.beforeUpdateListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.BEFORE_UPDATE);
    entityMetadata.beforeRemoveListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.BEFORE_REMOVE);
    entityMetadata.beforeSoftRemoveListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.BEFORE_SOFT_REMOVE);
    entityMetadata.beforeRecoverListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.BEFORE_RECOVER);
    entityMetadata.indices = entityMetadata.embeddeds.reduce((indices, embedded) => indices.concat(embedded.indicesFromTree), entityMetadata.ownIndices);
    entityMetadata.uniques = entityMetadata.embeddeds.reduce((uniques, embedded) => uniques.concat(embedded.uniquesFromTree), entityMetadata.ownUniques);
    entityMetadata.primaryColumns = entityMetadata.columns.filter((column) => column.isPrimary);
    entityMetadata.nonVirtualColumns = entityMetadata.columns.filter((column) => !column.isVirtual);
    entityMetadata.ancestorColumns = entityMetadata.columns.filter((column) => column.closureType === "ancestor");
    entityMetadata.descendantColumns = entityMetadata.columns.filter((column) => column.closureType === "descendant");
    entityMetadata.hasMultiplePrimaryKeys = entityMetadata.primaryColumns.length > 1;
    entityMetadata.generatedColumns = entityMetadata.columns.filter((column) => column.isGenerated || column.isObjectId);
    entityMetadata.hasUUIDGeneratedColumns = entityMetadata.columns.filter((column) => column.isGenerated || column.generationStrategy === "uuid").length > 0;
    entityMetadata.createDateColumn = entityMetadata.columns.find((column) => column.isCreateDate);
    entityMetadata.updateDateColumn = entityMetadata.columns.find((column) => column.isUpdateDate);
    entityMetadata.deleteDateColumn = entityMetadata.columns.find((column) => column.isDeleteDate);
    entityMetadata.versionColumn = entityMetadata.columns.find((column) => column.isVersion);
    entityMetadata.discriminatorColumn = entityMetadata.columns.find((column) => column.isDiscriminator);
    entityMetadata.treeLevelColumn = entityMetadata.columns.find((column) => column.isTreeLevel);
    entityMetadata.nestedSetLeftColumn = entityMetadata.columns.find((column) => column.isNestedSetLeft);
    entityMetadata.nestedSetRightColumn = entityMetadata.columns.find((column) => column.isNestedSetRight);
    entityMetadata.materializedPathColumn = entityMetadata.columns.find((column) => column.isMaterializedPath);
    entityMetadata.objectIdColumn = entityMetadata.columns.find((column) => column.isObjectId);
    entityMetadata.foreignKeys.forEach((foreignKey) => foreignKey.build(this.connection.namingStrategy));
    entityMetadata.propertiesMap = entityMetadata.createPropertiesMap();
    entityMetadata.relationIds.forEach((relationId) => relationId.build());
    entityMetadata.relationCounts.forEach((relationCount) => relationCount.build());
    entityMetadata.embeddeds.forEach((embedded) => {
      embedded.relationIdsFromTree.forEach((relationId) => relationId.build());
      embedded.relationCountsFromTree.forEach((relationCount) => relationCount.build());
    });
  }
  /**
   * Computes entity metadata's relations inverse side properties.
   */
  computeInverseProperties(entityMetadata, entityMetadatas) {
    entityMetadata.relations.forEach((relation) => {
      const inverseEntityMetadata = entityMetadatas.find((m) => m.target === relation.type || typeof relation.type === "string" && (m.targetName === relation.type || m.givenTableName === relation.type));
      if (!inverseEntityMetadata) throw new TypeORMError("Entity metadata for " + entityMetadata.name + "#" + relation.propertyPath + " was not found. Check if you specified a correct entity object and if it's connected in the connection options.");
      relation.inverseEntityMetadata = inverseEntityMetadata;
      relation.inverseSidePropertyPath = relation.buildInverseSidePropertyPath();
      relation.inverseRelation = inverseEntityMetadata.relations.find((foundRelation) => foundRelation.propertyPath === relation.inverseSidePropertyPath);
    });
  }
  /**
   * Creates indices for the table of single table inheritance.
   */
  createKeysForTableInheritance(entityMetadata) {
    const isDiscriminatorColumnAlreadyIndexed = entityMetadata.indices.some(({
      givenColumnNames
    }) => !!givenColumnNames && Array.isArray(givenColumnNames) && givenColumnNames.length === 1 && givenColumnNames[0] === entityMetadata.discriminatorColumn?.databaseName);
    if (isDiscriminatorColumnAlreadyIndexed) {
      return;
    }
    entityMetadata.indices.push(new IndexMetadata({
      entityMetadata,
      columns: [entityMetadata.discriminatorColumn],
      args: {
        target: entityMetadata.target,
        unique: false
      }
    }));
  }
};

// ../node_modules/typeorm/browser/entity-schema/EntitySchemaEmbeddedError.js
var EntitySchemaEmbeddedError = class _EntitySchemaEmbeddedError extends TypeORMError {
  static createEntitySchemaIsRequiredException(field) {
    return new _EntitySchemaEmbeddedError(`EntitySchema is required for ${field} embedded field`);
  }
  static createTargetIsRequired(field) {
    return new _EntitySchemaEmbeddedError(`Target field is required for ${field} embedded EntitySchema`);
  }
  constructor(message) {
    super(message);
  }
};

// ../node_modules/typeorm/browser/entity-schema/EntitySchemaTransformer.js
var EntitySchemaTransformer = class {
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Transforms entity schema into new metadata args storage object.
   */
  transform(schemas) {
    const metadataArgsStorage = new MetadataArgsStorage();
    schemas.forEach((entitySchema) => {
      const options = entitySchema.options;
      const tableMetadata = {
        target: options.target || options.name,
        name: options.tableName,
        database: options.database,
        schema: options.schema,
        type: options.type || "regular",
        orderBy: options.orderBy,
        synchronize: options.synchronize,
        withoutRowid: !!options.withoutRowid,
        expression: options.expression
      };
      metadataArgsStorage.tables.push(tableMetadata);
      const {
        inheritance
      } = options;
      if (inheritance) {
        metadataArgsStorage.inheritances.push({
          target: options.target,
          pattern: inheritance.pattern ?? "STI",
          column: inheritance.column ? typeof inheritance.column === "string" ? {
            name: inheritance.column
          } : inheritance.column : void 0
        });
      }
      const {
        discriminatorValue
      } = options;
      if (discriminatorValue) {
        metadataArgsStorage.discriminatorValues.push({
          target: options.target || options.name,
          value: discriminatorValue
        });
      }
      this.transformColumnsRecursive(options, metadataArgsStorage);
    });
    return metadataArgsStorage;
  }
  transformColumnsRecursive(options, metadataArgsStorage) {
    Object.keys(options.columns).forEach((columnName) => {
      const column = options.columns[columnName];
      const regularColumn = column;
      let mode = "regular";
      if (regularColumn.createDate) mode = "createDate";
      if (regularColumn.updateDate) mode = "updateDate";
      if (regularColumn.deleteDate) mode = "deleteDate";
      if (regularColumn.version) mode = "version";
      if (regularColumn.treeChildrenCount) mode = "treeChildrenCount";
      if (regularColumn.treeLevel) mode = "treeLevel";
      if (regularColumn.objectId) mode = "objectId";
      const columnArgs = {
        target: options.target || options.name,
        mode,
        propertyName: columnName,
        options: {
          type: regularColumn.type,
          name: regularColumn.objectId ? "_id" : regularColumn.name,
          primaryKeyConstraintName: regularColumn.primaryKeyConstraintName,
          length: regularColumn.length,
          width: regularColumn.width,
          nullable: regularColumn.nullable,
          readonly: regularColumn.readonly,
          update: regularColumn.update,
          select: regularColumn.select,
          insert: regularColumn.insert,
          primary: regularColumn.primary,
          unique: regularColumn.unique,
          comment: regularColumn.comment,
          default: regularColumn.default,
          onUpdate: regularColumn.onUpdate,
          precision: regularColumn.precision,
          scale: regularColumn.scale,
          zerofill: regularColumn.zerofill,
          unsigned: regularColumn.unsigned,
          charset: regularColumn.charset,
          collation: regularColumn.collation,
          enum: regularColumn.enum,
          enumName: regularColumn.enumName,
          asExpression: regularColumn.asExpression,
          generatedType: regularColumn.generatedType,
          hstoreType: regularColumn.hstoreType,
          array: regularColumn.array,
          transformer: regularColumn.transformer,
          spatialFeatureType: regularColumn.spatialFeatureType,
          srid: regularColumn.srid
        }
      };
      metadataArgsStorage.columns.push(columnArgs);
      if (regularColumn.generated) {
        const generationArgs = {
          target: options.target || options.name,
          propertyName: columnName,
          strategy: typeof regularColumn.generated === "string" ? regularColumn.generated : "increment"
        };
        metadataArgsStorage.generations.push(generationArgs);
      }
      if (regularColumn.unique) metadataArgsStorage.uniques.push({
        target: options.target || options.name,
        columns: [columnName]
      });
    });
    if (options.relations) {
      Object.keys(options.relations).forEach((relationName) => {
        const relationSchema = options.relations[relationName];
        const relation = {
          target: options.target || options.name,
          propertyName: relationName,
          relationType: relationSchema.type,
          isLazy: relationSchema.lazy || false,
          type: relationSchema.target,
          inverseSideProperty: relationSchema.inverseSide,
          isTreeParent: relationSchema.treeParent,
          isTreeChildren: relationSchema.treeChildren,
          options: {
            eager: relationSchema.eager || false,
            cascade: relationSchema.cascade,
            nullable: relationSchema.nullable,
            onDelete: relationSchema.onDelete,
            onUpdate: relationSchema.onUpdate,
            deferrable: relationSchema.deferrable,
            // primary: relationSchema.primary,
            createForeignKeyConstraints: relationSchema.createForeignKeyConstraints,
            persistence: relationSchema.persistence,
            orphanedRowAction: relationSchema.orphanedRowAction
          }
        };
        metadataArgsStorage.relations.push(relation);
        if (relationSchema.joinColumn) {
          if (typeof relationSchema.joinColumn === "boolean") {
            const joinColumn = {
              target: options.target || options.name,
              propertyName: relationName
            };
            metadataArgsStorage.joinColumns.push(joinColumn);
          } else {
            const joinColumnsOptions = Array.isArray(relationSchema.joinColumn) ? relationSchema.joinColumn : [relationSchema.joinColumn];
            for (const joinColumnOption of joinColumnsOptions) {
              const joinColumn = {
                target: options.target || options.name,
                propertyName: relationName,
                name: joinColumnOption.name,
                referencedColumnName: joinColumnOption.referencedColumnName,
                foreignKeyConstraintName: joinColumnOption.foreignKeyConstraintName
              };
              metadataArgsStorage.joinColumns.push(joinColumn);
            }
          }
        }
        if (relationSchema.joinTable) {
          if (typeof relationSchema.joinTable === "boolean") {
            const joinTable = {
              target: options.target || options.name,
              propertyName: relationName
            };
            metadataArgsStorage.joinTables.push(joinTable);
          } else {
            const joinTable = {
              target: options.target || options.name,
              propertyName: relationName,
              name: relationSchema.joinTable.name,
              database: relationSchema.joinTable.database,
              schema: relationSchema.joinTable.schema,
              joinColumns: relationSchema.joinTable.joinColumn ? [relationSchema.joinTable.joinColumn] : relationSchema.joinTable.joinColumns,
              inverseJoinColumns: relationSchema.joinTable.inverseJoinColumn ? [relationSchema.joinTable.inverseJoinColumn] : relationSchema.joinTable.inverseJoinColumns
            };
            metadataArgsStorage.joinTables.push(joinTable);
          }
        }
      });
    }
    if (options.relationIds) {
      Object.keys(options.relationIds).forEach((relationIdName) => {
        const relationIdOptions = options.relationIds[relationIdName];
        const relationId = {
          propertyName: relationIdName,
          relation: relationIdOptions.relationName,
          target: options.target || options.name,
          alias: relationIdOptions.alias,
          queryBuilderFactory: relationIdOptions.queryBuilderFactory
        };
        metadataArgsStorage.relationIds.push(relationId);
      });
    }
    if (options.indices) {
      options.indices.forEach((index) => {
        const indexArgs = {
          target: options.target || options.name,
          name: index.name,
          unique: index.unique === true ? true : false,
          spatial: index.spatial === true ? true : false,
          fulltext: index.fulltext === true ? true : false,
          nullFiltered: index.nullFiltered === true ? true : false,
          parser: index.parser,
          synchronize: index.synchronize === false ? false : true,
          where: index.where,
          sparse: index.sparse,
          columns: index.columns
        };
        metadataArgsStorage.indices.push(indexArgs);
      });
    }
    if (options.uniques) {
      options.uniques.forEach((unique) => {
        const uniqueArgs = {
          target: options.target || options.name,
          name: unique.name,
          columns: unique.columns,
          deferrable: unique.deferrable
        };
        metadataArgsStorage.uniques.push(uniqueArgs);
      });
    }
    if (options.checks) {
      options.checks.forEach((check) => {
        const checkArgs = {
          target: options.target || options.name,
          name: check.name,
          expression: check.expression
        };
        metadataArgsStorage.checks.push(checkArgs);
      });
    }
    if (options.exclusions) {
      options.exclusions.forEach((exclusion) => {
        const exclusionArgs = {
          target: options.target || options.name,
          name: exclusion.name,
          expression: exclusion.expression
        };
        metadataArgsStorage.exclusions.push(exclusionArgs);
      });
    }
    if (options.embeddeds) {
      Object.keys(options.embeddeds).forEach((columnName) => {
        const embeddedOptions = options.embeddeds[columnName];
        if (!embeddedOptions.schema) throw EntitySchemaEmbeddedError.createEntitySchemaIsRequiredException(columnName);
        const embeddedSchema = embeddedOptions.schema.options;
        metadataArgsStorage.embeddeds.push({
          target: options.target || options.name,
          propertyName: columnName,
          isArray: embeddedOptions.array === true,
          prefix: embeddedOptions.prefix !== void 0 ? embeddedOptions.prefix : void 0,
          type: () => embeddedSchema?.target || embeddedSchema.name
        });
        this.transformColumnsRecursive(embeddedSchema, metadataArgsStorage);
      });
    }
  }
};

// ../node_modules/typeorm/browser/connection/ConnectionMetadataBuilder.js
var ConnectionMetadataBuilder = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    this.connection = connection;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Builds migration instances for the given classes or directories.
   */
  buildMigrations(migrations) {
    return __async(this, null, function* () {
      const [migrationClasses, migrationDirectories] = OrmUtils.splitClassesAndStrings(migrations);
      const allMigrationClasses = [...migrationClasses, ...yield importClassesFromDirectories(this.connection.logger, migrationDirectories)];
      return allMigrationClasses.map((migrationClass) => getFromContainer(migrationClass));
    });
  }
  /**
   * Builds subscriber instances for the given classes or directories.
   */
  buildSubscribers(subscribers) {
    return __async(this, null, function* () {
      const [subscriberClasses, subscriberDirectories] = OrmUtils.splitClassesAndStrings(subscribers || []);
      const allSubscriberClasses = [...subscriberClasses, ...yield importClassesFromDirectories(this.connection.logger, subscriberDirectories)];
      return getMetadataArgsStorage().filterSubscribers(allSubscriberClasses).map((metadata) => getFromContainer(metadata.target));
    });
  }
  /**
   * Builds entity metadatas for the given classes or directories.
   */
  buildEntityMetadatas(entities) {
    return __async(this, null, function* () {
      const [entityClassesOrSchemas, entityDirectories] = OrmUtils.splitClassesAndStrings(entities || []);
      const entityClasses = entityClassesOrSchemas.filter((entityClass) => !InstanceChecker.isEntitySchema(entityClass));
      const entitySchemas = entityClassesOrSchemas.filter((entityClass) => InstanceChecker.isEntitySchema(entityClass));
      const allEntityClasses = [...entityClasses, ...yield importClassesFromDirectories(this.connection.logger, entityDirectories)];
      allEntityClasses.forEach((entityClass) => {
        if (InstanceChecker.isEntitySchema(entityClass)) {
          entitySchemas.push(entityClass);
        }
      });
      const decoratorEntityMetadatas = new EntityMetadataBuilder(this.connection, getMetadataArgsStorage()).build(allEntityClasses);
      const metadataArgsStorageFromSchema = new EntitySchemaTransformer().transform(entitySchemas);
      const schemaEntityMetadatas = new EntityMetadataBuilder(this.connection, metadataArgsStorageFromSchema).build();
      return [...decoratorEntityMetadatas, ...schemaEntityMetadatas];
    });
  }
};

// ../node_modules/typeorm/browser/logger/AbstractLogger.js
var AbstractLogger = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(options) {
    this.options = options;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Logs query and parameters used in it.
   */
  logQuery(query, parameters, queryRunner) {
    if (!this.isLogEnabledFor("query")) {
      return;
    }
    this.writeLog("query", {
      type: "query",
      prefix: "query",
      message: query,
      format: "sql",
      parameters
    }, queryRunner);
  }
  /**
   * Logs query that is failed.
   */
  logQueryError(error, query, parameters, queryRunner) {
    if (!this.isLogEnabledFor("query-error")) {
      return;
    }
    this.writeLog("warn", [{
      type: "query-error",
      prefix: "query failed",
      message: query,
      format: "sql",
      parameters
    }, {
      type: "query-error",
      prefix: "error",
      message: error
    }], queryRunner);
  }
  /**
   * Logs query that is slow.
   */
  logQuerySlow(time, query, parameters, queryRunner) {
    if (!this.isLogEnabledFor("query-slow")) {
      return;
    }
    this.writeLog("warn", [{
      type: "query-slow",
      prefix: "query is slow",
      message: query,
      format: "sql",
      parameters,
      additionalInfo: {
        time
      }
    }, {
      type: "query-slow",
      prefix: "execution time",
      message: time
    }], queryRunner);
  }
  /**
   * Logs events from the schema build process.
   */
  logSchemaBuild(message, queryRunner) {
    if (!this.isLogEnabledFor("schema-build")) {
      return;
    }
    this.writeLog("schema", {
      type: "schema-build",
      message
    }, queryRunner);
  }
  /**
   * Logs events from the migration run process.
   */
  logMigration(message, queryRunner) {
    if (!this.isLogEnabledFor("migration")) {
      return;
    }
    this.writeLog("log", {
      type: "migration",
      message
    }, queryRunner);
  }
  /**
   * Perform logging using given logger, or by default to the console.
   * Log has its own level and message.
   */
  log(level, message, queryRunner) {
    switch (level) {
      case "log":
        if (!this.isLogEnabledFor("log")) {
          return;
        }
        this.writeLog("log", {
          type: "log",
          message
        }, queryRunner);
        break;
      case "info":
        if (!this.isLogEnabledFor("info")) {
          return;
        }
        this.writeLog("info", {
          type: "info",
          prefix: "info",
          message
        }, queryRunner);
        break;
      case "warn":
        if (!this.isLogEnabledFor("warn")) {
          return;
        }
        this.writeLog("warn", {
          type: "warn",
          message
        }, queryRunner);
        break;
    }
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Check is logging for level or message type is enabled.
   */
  isLogEnabledFor(type) {
    switch (type) {
      case "query":
        return this.options === "all" || this.options === true || Array.isArray(this.options) && this.options.indexOf("query") !== -1;
      case "error":
      case "query-error":
        return this.options === "all" || this.options === true || Array.isArray(this.options) && this.options.indexOf("error") !== -1;
      case "query-slow":
        return true;
      case "schema":
      case "schema-build":
        return this.options === "all" || Array.isArray(this.options) && this.options.indexOf("schema") !== -1;
      case "migration":
        return true;
      case "log":
        return this.options === "all" || Array.isArray(this.options) && this.options.indexOf("log") !== -1;
      case "info":
        return this.options === "all" || Array.isArray(this.options) && this.options.indexOf("info") !== -1;
      case "warn":
        return this.options === "all" || Array.isArray(this.options) && this.options.indexOf("warn") !== -1;
      default:
        return false;
    }
  }
  /**
   * Prepare and format log messages
   */
  prepareLogMessages(logMessage, options) {
    options = __spreadValues(__spreadValues({}, {
      addColonToPrefix: true,
      appendParameterAsComment: true,
      highlightSql: true
    }), options);
    const messages = Array.isArray(logMessage) ? logMessage : [logMessage];
    for (let message of messages) {
      if (typeof message !== "object") {
        message = {
          message
        };
      }
      if (message.format === "sql") {
        let sql = String(message.message);
        if (options.appendParameterAsComment && message.parameters && message.parameters.length) {
          sql += ` -- PARAMETERS: ${this.stringifyParams(message.parameters)}`;
        }
        if (options.highlightSql) {
          sql = PlatformTools.highlightSql(sql);
        }
        message.message = sql;
      }
      if (options.addColonToPrefix && message.prefix) {
        message.prefix += ":";
      }
    }
    return messages;
  }
  /**
   * Converts parameters to a string.
   * Sometimes parameters can have circular objects and therefor we are handle this case too.
   */
  stringifyParams(parameters) {
    try {
      return JSON.stringify(parameters);
    } catch (error) {
      return parameters;
    }
  }
};

// ../node_modules/typeorm/browser/logger/SimpleConsoleLogger.js
var SimpleConsoleLogger = class extends AbstractLogger {
  /**
   * Write log to specific output.
   */
  writeLog(level, logMessage, queryRunner) {
    const messages = this.prepareLogMessages(logMessage, {
      highlightSql: false
    });
    for (let message of messages) {
      switch (message.type ?? level) {
        case "log":
        case "schema-build":
        case "migration":
          console.log(message.message);
          break;
        case "info":
        case "query":
          if (message.prefix) {
            console.info(message.prefix, message.message);
          } else {
            console.info(message.message);
          }
          break;
        case "warn":
        case "query-slow":
          if (message.prefix) {
            console.warn(message.prefix, message.message);
          } else {
            console.warn(message.message);
          }
          break;
        case "error":
        case "query-error":
          if (message.prefix) {
            console.error(message.prefix, message.message);
          } else {
            console.error(message.message);
          }
          break;
      }
    }
  }
};

// ../node_modules/typeorm/browser/logger/AdvancedConsoleLogger.js
var AdvancedConsoleLogger = class extends AbstractLogger {
  /**
   * Write log to specific output.
   */
  writeLog(level, logMessage, queryRunner) {
    const messages = this.prepareLogMessages(logMessage);
    for (let message of messages) {
      switch (message.type ?? level) {
        case "log":
        case "schema-build":
        case "migration":
          PlatformTools.log(String(message.message));
          break;
        case "info":
        case "query":
          if (message.prefix) {
            PlatformTools.logInfo(message.prefix, message.message);
          } else {
            PlatformTools.log(String(message.message));
          }
          break;
        case "warn":
        case "query-slow":
          if (message.prefix) {
            PlatformTools.logWarn(message.prefix, message.message);
          } else {
            console.warn(PlatformTools.warn(String(message.message)));
          }
          break;
        case "error":
        case "query-error":
          if (message.prefix) {
            PlatformTools.logError(message.prefix, String(message.message));
          } else {
            console.error(PlatformTools.error(String(message.message)));
          }
          break;
      }
    }
  }
};

// ../node_modules/typeorm/browser/platform/BrowserFileLoggerDummy.js
var DummyLogger = class {
  /**
   * Logs query and parameters used in it.
   */
  logQuery() {
    throw new Error("This logger is not applicable in a browser context");
  }
  /**
   * Logs query that is failed.
   */
  logQueryError() {
    throw new Error("This logger is not applicable in a browser context");
  }
  /**
   * Logs query that is slow.
   */
  logQuerySlow() {
    throw new Error("This logger is not applicable in a browser context");
  }
  /**
   * Logs events from the schema build process.
   */
  logSchemaBuild() {
    throw new Error("This logger is not applicable in a browser context");
  }
  /**
   * Logs events from the migrations run process.
   */
  logMigration() {
    throw new Error("This logger is not applicable in a browser context");
  }
  /**
   * Perform logging using given logger, or by default to the console.
   * Log has its own level and message.
   */
  log() {
    throw new Error("This logger is not applicable in a browser context");
  }
};
var FileLogger = class extends DummyLogger {
};

// ../node_modules/typeorm/browser/logger/DebugLogger.js
var import_debug = __toESM(require_browser());
var DebugLogger = class extends AbstractLogger {
  constructor() {
    super(...arguments);
    this.logger = {
      log: (0, import_debug.debug)("typeorm:log"),
      info: (0, import_debug.debug)("typeorm:info"),
      warn: (0, import_debug.debug)("typeorm:warn"),
      error: (0, import_debug.debug)("typeorm:error"),
      query: (0, import_debug.debug)("typeorm:query:log"),
      "query-error": (0, import_debug.debug)("typeorm:query:error"),
      "query-slow": (0, import_debug.debug)("typeorm:query:slow"),
      "schema-build": (0, import_debug.debug)("typeorm:schema"),
      migration: (0, import_debug.debug)("typeorm:migration")
    };
  }
  /**
   * Check is logging for level or message type is enabled.
   */
  isLogEnabledFor(type) {
    switch (type) {
      case "query":
        return this.logger["query"].enabled;
      case "query-error":
        return this.logger["query-error"].enabled;
      case "query-slow":
        return true;
      case "schema":
      case "schema-build":
        return this.logger["schema-build"].enabled;
      case "migration":
        return this.logger["migration"].enabled;
      case "log":
        return this.logger["log"].enabled;
      case "info":
        return this.logger["info"].enabled;
      case "warn":
        return this.logger["warn"].enabled;
      default:
        return false;
    }
  }
  /**
   * Write log to specific output.
   */
  writeLog(level, logMessage, queryRunner) {
    const messages = this.prepareLogMessages(logMessage, {
      appendParameterAsComment: false
    });
    for (let message of messages) {
      const messageTypeOrLevel = message.type ?? level;
      if (messageTypeOrLevel in this.logger) {
        if (message.prefix) {
          this.logger[messageTypeOrLevel](message.prefix, message.message);
        } else {
          this.logger[messageTypeOrLevel](message.message);
        }
        if (message.parameters && message.parameters.length) {
          this.logger[messageTypeOrLevel]("parameters:", message.parameters);
        }
      }
    }
  }
};

// ../node_modules/typeorm/browser/logger/LoggerFactory.js
var LoggerFactory = class {
  /**
   * Creates a new logger depend on a given connection's driver.
   */
  create(logger, options) {
    if (ObjectUtils.isObject(logger)) return logger;
    if (logger) {
      switch (logger) {
        case "simple-console":
          return new SimpleConsoleLogger(options);
        case "file":
          return new FileLogger(options);
        case "advanced-console":
          return new AdvancedConsoleLogger(options);
        case "debug":
          return new DebugLogger();
      }
    }
    return new AdvancedConsoleLogger(options);
  }
};

// ../node_modules/typeorm/browser/cache/RedisQueryResultCache.js
var RedisQueryResultCache = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection, clientType) {
    this.connection = connection;
    this.clientType = clientType;
    this.redis = this.loadRedis();
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates a connection with given cache provider.
   */
  connect() {
    return __async(this, null, function* () {
      const cacheOptions = this.connection.options.cache;
      if (this.clientType === "redis") {
        this.client = this.redis.createClient(__spreadProps(__spreadValues({}, cacheOptions?.options), {
          legacyMode: true
        }));
        if (typeof this.connection.options.cache === "object" && this.connection.options.cache.ignoreErrors) {
          this.client.on("error", (err) => {
            this.connection.logger.log("warn", err);
          });
        }
        if ("connect" in this.client) {
          yield this.client.connect();
        }
      } else if (this.clientType === "ioredis") {
        if (cacheOptions && cacheOptions.port) {
          if (cacheOptions.options) {
            this.client = new this.redis(cacheOptions.port, cacheOptions.options);
          } else {
            this.client = new this.redis(cacheOptions.port);
          }
        } else if (cacheOptions && cacheOptions.options) {
          this.client = new this.redis(cacheOptions.options);
        } else {
          this.client = new this.redis();
        }
      } else if (this.clientType === "ioredis/cluster") {
        if (cacheOptions && cacheOptions.options && Array.isArray(cacheOptions.options)) {
          this.client = new this.redis.Cluster(cacheOptions.options);
        } else if (cacheOptions && cacheOptions.options && cacheOptions.options.startupNodes) {
          this.client = new this.redis.Cluster(cacheOptions.options.startupNodes, cacheOptions.options.options);
        } else {
          throw new TypeORMError(`options.startupNodes required for ${this.clientType}.`);
        }
      }
    });
  }
  /**
   * Disconnects the connection
   */
  disconnect() {
    return __async(this, null, function* () {
      return new Promise((ok, fail) => {
        this.client.quit((err, result) => {
          if (err) return fail(err);
          ok();
          this.client = void 0;
        });
      });
    });
  }
  /**
   * Creates table for storing cache if it does not exist yet.
   */
  synchronize(queryRunner) {
    return __async(this, null, function* () {
    });
  }
  /**
   * Get data from cache.
   * Returns cache result if found.
   * Returns undefined if result is not cached.
   */
  getFromCache(options, queryRunner) {
    return new Promise((ok, fail) => {
      if (options.identifier) {
        this.client.get(options.identifier, (err, result) => {
          if (err) return fail(err);
          ok(JSON.parse(result));
        });
      } else if (options.query) {
        this.client.get(options.query, (err, result) => {
          if (err) return fail(err);
          ok(JSON.parse(result));
        });
      } else {
        ok(void 0);
      }
    });
  }
  /**
   * Checks if cache is expired or not.
   */
  isExpired(savedCache) {
    return savedCache.time + savedCache.duration < (/* @__PURE__ */ new Date()).getTime();
  }
  /**
   * Stores given query result in the cache.
   */
  storeInCache(options, savedCache, queryRunner) {
    return __async(this, null, function* () {
      return new Promise((ok, fail) => {
        if (options.identifier) {
          this.client.set(options.identifier, JSON.stringify(options), "PX", options.duration, (err, result) => {
            if (err) return fail(err);
            ok();
          });
        } else if (options.query) {
          this.client.set(options.query, JSON.stringify(options), "PX", options.duration, (err, result) => {
            if (err) return fail(err);
            ok();
          });
        }
      });
    });
  }
  /**
   * Clears everything stored in the cache.
   */
  clear(queryRunner) {
    return __async(this, null, function* () {
      return new Promise((ok, fail) => {
        this.client.flushdb((err, result) => {
          if (err) return fail(err);
          ok();
        });
      });
    });
  }
  /**
   * Removes all cached results by given identifiers from cache.
   */
  remove(identifiers, queryRunner) {
    return __async(this, null, function* () {
      yield Promise.all(identifiers.map((identifier) => {
        return this.deleteKey(identifier);
      }));
    });
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Removes a single key from redis database.
   */
  deleteKey(key) {
    return new Promise((ok, fail) => {
      this.client.del(key, (err, result) => {
        if (err) return fail(err);
        ok();
      });
    });
  }
  /**
   * Loads redis dependency.
   */
  loadRedis() {
    try {
      if (this.clientType === "ioredis/cluster") {
        return PlatformTools.load("ioredis");
      } else {
        return PlatformTools.load(this.clientType);
      }
    } catch (e) {
      throw new TypeORMError(`Cannot use cache because ${this.clientType} is not installed. Please run "npm i ${this.clientType} --save".`);
    }
  }
};

// ../node_modules/typeorm/browser/cache/DbQueryResultCache.js
var DbQueryResultCache = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    this.connection = connection;
    const {
      schema
    } = this.connection.driver.options;
    const database = this.connection.driver.database;
    const cacheOptions = typeof this.connection.options.cache === "object" ? this.connection.options.cache : {};
    const cacheTableName = cacheOptions.tableName || "query-result-cache";
    this.queryResultCacheDatabase = database;
    this.queryResultCacheSchema = schema;
    this.queryResultCacheTable = this.connection.driver.buildTableName(cacheTableName, schema, database);
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates a connection with given cache provider.
   */
  connect() {
    return __async(this, null, function* () {
    });
  }
  /**
   * Disconnects with given cache provider.
   */
  disconnect() {
    return __async(this, null, function* () {
    });
  }
  /**
   * Creates table for storing cache if it does not exist yet.
   */
  synchronize(queryRunner) {
    return __async(this, null, function* () {
      queryRunner = this.getQueryRunner(queryRunner);
      const driver = this.connection.driver;
      const tableExist = yield queryRunner.hasTable(this.queryResultCacheTable);
      if (tableExist) return;
      yield queryRunner.createTable(new Table({
        database: this.queryResultCacheDatabase,
        schema: this.queryResultCacheSchema,
        name: this.queryResultCacheTable,
        columns: [{
          name: "id",
          isPrimary: true,
          isNullable: false,
          type: driver.normalizeType({
            type: driver.mappedDataTypes.cacheId
          }),
          generationStrategy: driver.options.type === "spanner" ? "uuid" : "increment",
          isGenerated: true
        }, {
          name: "identifier",
          type: driver.normalizeType({
            type: driver.mappedDataTypes.cacheIdentifier
          }),
          isNullable: true
        }, {
          name: "time",
          type: driver.normalizeType({
            type: driver.mappedDataTypes.cacheTime
          }),
          isPrimary: false,
          isNullable: false
        }, {
          name: "duration",
          type: driver.normalizeType({
            type: driver.mappedDataTypes.cacheDuration
          }),
          isPrimary: false,
          isNullable: false
        }, {
          name: "query",
          type: driver.normalizeType({
            type: driver.mappedDataTypes.cacheQuery
          }),
          isPrimary: false,
          isNullable: false
        }, {
          name: "result",
          type: driver.normalizeType({
            type: driver.mappedDataTypes.cacheResult
          }),
          isNullable: false
        }]
      }));
    });
  }
  /**
   * Get data from cache.
   * Returns cache result if found.
   * Returns undefined if result is not cached.
   */
  getFromCache(options, queryRunner) {
    queryRunner = this.getQueryRunner(queryRunner);
    const qb = this.connection.createQueryBuilder(queryRunner).select().from(this.queryResultCacheTable, "cache");
    if (options.identifier) {
      return qb.where(`${qb.escape("cache")}.${qb.escape("identifier")} = :identifier`).setParameters({
        identifier: this.connection.driver.options.type === "mssql" ? new MssqlParameter(options.identifier, "nvarchar") : options.identifier
      }).cache(false).getRawOne();
    } else if (options.query) {
      if (this.connection.driver.options.type === "oracle") {
        return qb.where(`dbms_lob.compare(${qb.escape("cache")}.${qb.escape("query")}, :query) = 0`, {
          query: options.query
        }).cache(false).getRawOne();
      }
      return qb.where(`${qb.escape("cache")}.${qb.escape("query")} = :query`).setParameters({
        query: this.connection.driver.options.type === "mssql" ? new MssqlParameter(options.query, "nvarchar") : options.query
      }).cache(false).getRawOne();
    }
    return Promise.resolve(void 0);
  }
  /**
   * Checks if cache is expired or not.
   */
  isExpired(savedCache) {
    const duration = typeof savedCache.duration === "string" ? parseInt(savedCache.duration) : savedCache.duration;
    return (typeof savedCache.time === "string" ? parseInt(savedCache.time) : savedCache.time) + duration < (/* @__PURE__ */ new Date()).getTime();
  }
  /**
   * Stores given query result in the cache.
   */
  storeInCache(options, savedCache, queryRunner) {
    return __async(this, null, function* () {
      const shouldCreateQueryRunner = queryRunner === void 0 || queryRunner?.getReplicationMode() === "slave";
      if (queryRunner === void 0 || shouldCreateQueryRunner) {
        queryRunner = this.connection.createQueryRunner("master");
      }
      let insertedValues = options;
      if (this.connection.driver.options.type === "mssql") {
        insertedValues = {
          identifier: new MssqlParameter(options.identifier, "nvarchar"),
          time: new MssqlParameter(options.time, "bigint"),
          duration: new MssqlParameter(options.duration, "int"),
          query: new MssqlParameter(options.query, "nvarchar"),
          result: new MssqlParameter(options.result, "nvarchar")
        };
      }
      if (savedCache && savedCache.identifier) {
        const qb = queryRunner.manager.createQueryBuilder().update(this.queryResultCacheTable).set(insertedValues);
        qb.where(`${qb.escape("identifier")} = :condition`, {
          condition: insertedValues.identifier
        });
        yield qb.execute();
      } else if (savedCache && savedCache.query) {
        const qb = queryRunner.manager.createQueryBuilder().update(this.queryResultCacheTable).set(insertedValues);
        if (this.connection.driver.options.type === "oracle") {
          qb.where(`dbms_lob.compare("query", :condition) = 0`, {
            condition: insertedValues.query
          });
        } else {
          qb.where(`${qb.escape("query")} = :condition`, {
            condition: insertedValues.query
          });
        }
        yield qb.execute();
      } else {
        if (this.connection.driver.options.type === "spanner" && !insertedValues.id) {
          insertedValues.id = v4_default();
        }
        yield queryRunner.manager.createQueryBuilder().insert().into(this.queryResultCacheTable).values(insertedValues).execute();
      }
      if (shouldCreateQueryRunner) {
        yield queryRunner.release();
      }
    });
  }
  /**
   * Clears everything stored in the cache.
   */
  clear(queryRunner) {
    return __async(this, null, function* () {
      return this.getQueryRunner(queryRunner).clearTable(this.queryResultCacheTable);
    });
  }
  /**
   * Removes all cached results by given identifiers from cache.
   */
  remove(identifiers, queryRunner) {
    return __async(this, null, function* () {
      let _queryRunner = queryRunner || this.getQueryRunner();
      yield Promise.all(identifiers.map((identifier) => {
        const qb = _queryRunner.manager.createQueryBuilder();
        return qb.delete().from(this.queryResultCacheTable).where(`${qb.escape("identifier")} = :identifier`, {
          identifier
        }).execute();
      }));
      if (!queryRunner) {
        yield _queryRunner.release();
      }
    });
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Gets a query runner to work with.
   */
  getQueryRunner(queryRunner) {
    if (queryRunner) return queryRunner;
    return this.connection.createQueryRunner();
  }
};

// ../node_modules/typeorm/browser/cache/QueryResultCacheFactory.js
var QueryResultCacheFactory = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    this.connection = connection;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Creates a new query result cache based on connection options.
   */
  create() {
    if (!this.connection.options.cache) throw new TypeORMError(`To use cache you need to enable it in connection options by setting cache: true or providing some caching options. Example: { host: ..., username: ..., cache: true }`);
    const cache = this.connection.options.cache;
    if (cache.provider && typeof cache.provider === "function") {
      return cache.provider(this.connection);
    }
    if (cache.type === "redis" || cache.type === "ioredis" || cache.type === "ioredis/cluster") {
      return new RedisQueryResultCache(this.connection, cache.type);
    } else {
      return new DbQueryResultCache(this.connection);
    }
  }
};

// ../node_modules/typeorm/browser/query-builder/RelationLoader.js
var RelationLoader = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(connection) {
    this.connection = connection;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Loads relation data for the given entity and its relation.
   */
  load(relation, entityOrEntities, queryRunner, queryBuilder) {
    if (queryRunner && queryRunner.isReleased) queryRunner = void 0;
    if (relation.isManyToOne || relation.isOneToOneOwner) {
      return this.loadManyToOneOrOneToOneOwner(relation, entityOrEntities, queryRunner, queryBuilder);
    } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
      return this.loadOneToManyOrOneToOneNotOwner(relation, entityOrEntities, queryRunner, queryBuilder);
    } else if (relation.isManyToManyOwner) {
      return this.loadManyToManyOwner(relation, entityOrEntities, queryRunner, queryBuilder);
    } else {
      return this.loadManyToManyNotOwner(relation, entityOrEntities, queryRunner, queryBuilder);
    }
  }
  /**
   * Loads data for many-to-one and one-to-one owner relations.
   *
   * (ow) post.category<=>category.post
   * loaded: category from post
   * example: SELECT category.id AS category_id, category.name AS category_name FROM category category
   *              INNER JOIN post Post ON Post.category=category.id WHERE Post.id=1
   */
  loadManyToOneOrOneToOneOwner(relation, entityOrEntities, queryRunner, queryBuilder) {
    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];
    const joinAliasName = relation.entityMetadata.name;
    const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.type, relation.propertyName);
    const mainAlias = qb.expressionMap.mainAlias.name;
    const columns = relation.entityMetadata.primaryColumns;
    const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.joinColumns;
    const conditions = joinColumns.map((joinColumn) => {
      return `${relation.entityMetadata.name}.${joinColumn.propertyName} = ${mainAlias}.${joinColumn.referencedColumn.propertyName}`;
    }).join(" AND ");
    qb.innerJoin(relation.entityMetadata.target, joinAliasName, conditions);
    if (columns.length === 1) {
      qb.where(`${joinAliasName}.${columns[0].propertyPath} IN (:...${joinAliasName + "_" + columns[0].propertyName})`);
      qb.setParameter(joinAliasName + "_" + columns[0].propertyName, entities.map((entity) => columns[0].getEntityValue(entity, true)));
    } else {
      const condition = entities.map((entity, entityIndex) => {
        return columns.map((column, columnIndex) => {
          const paramName = joinAliasName + "_entity_" + entityIndex + "_" + columnIndex;
          qb.setParameter(paramName, column.getEntityValue(entity, true));
          return joinAliasName + "." + column.propertyPath + " = :" + paramName;
        }).join(" AND ");
      }).map((condition2) => "(" + condition2 + ")").join(" OR ");
      qb.where(condition);
    }
    FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);
    return qb.getMany();
  }
  /**
   * Loads data for one-to-many and one-to-one not owner relations.
   *
   * SELECT post
   * FROM post post
   * WHERE post.[joinColumn.name] = entity[joinColumn.referencedColumn]
   */
  loadOneToManyOrOneToOneNotOwner(relation, entityOrEntities, queryRunner, queryBuilder) {
    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];
    const columns = relation.inverseRelation.joinColumns;
    const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.inverseRelation.entityMetadata.target, relation.propertyName);
    const aliasName = qb.expressionMap.mainAlias.name;
    if (columns.length === 1) {
      qb.where(`${aliasName}.${columns[0].propertyPath} IN (:...${aliasName + "_" + columns[0].propertyName})`);
      qb.setParameter(aliasName + "_" + columns[0].propertyName, entities.map((entity) => columns[0].referencedColumn.getEntityValue(entity, true)));
    } else {
      const condition = entities.map((entity, entityIndex) => {
        return columns.map((column, columnIndex) => {
          const paramName = aliasName + "_entity_" + entityIndex + "_" + columnIndex;
          qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity, true));
          return aliasName + "." + column.propertyPath + " = :" + paramName;
        }).join(" AND ");
      }).map((condition2) => "(" + condition2 + ")").join(" OR ");
      qb.where(condition);
    }
    FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);
    return qb.getMany();
  }
  /**
   * Loads data for many-to-many owner relations.
   *
   * SELECT category
   * FROM category category
   * INNER JOIN post_categories post_categories
   * ON post_categories.postId = :postId
   * AND post_categories.categoryId = category.id
   */
  loadManyToManyOwner(relation, entityOrEntities, queryRunner, queryBuilder) {
    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];
    const parameters = relation.joinColumns.reduce((parameters2, joinColumn) => {
      parameters2[joinColumn.propertyName] = entities.map((entity) => joinColumn.referencedColumn.getEntityValue(entity, true));
      return parameters2;
    }, {});
    const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.type, relation.propertyName);
    const mainAlias = qb.expressionMap.mainAlias.name;
    const joinAlias = relation.junctionEntityMetadata.tableName;
    const joinColumnConditions = relation.joinColumns.map((joinColumn) => {
      return `${joinAlias}.${joinColumn.propertyName} IN (:...${joinColumn.propertyName})`;
    });
    const inverseJoinColumnConditions = relation.inverseJoinColumns.map((inverseJoinColumn) => {
      return `${joinAlias}.${inverseJoinColumn.propertyName}=${mainAlias}.${inverseJoinColumn.referencedColumn.propertyName}`;
    });
    qb.innerJoin(joinAlias, joinAlias, [...joinColumnConditions, ...inverseJoinColumnConditions].join(" AND ")).setParameters(parameters);
    FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);
    return qb.getMany();
  }
  /**
   * Loads data for many-to-many not owner relations.
   *
   * SELECT post
   * FROM post post
   * INNER JOIN post_categories post_categories
   * ON post_categories.postId = post.id
   * AND post_categories.categoryId = post_categories.categoryId
   */
  loadManyToManyNotOwner(relation, entityOrEntities, queryRunner, queryBuilder) {
    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];
    const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.type, relation.propertyName);
    const mainAlias = qb.expressionMap.mainAlias.name;
    const joinAlias = relation.junctionEntityMetadata.tableName;
    const joinColumnConditions = relation.inverseRelation.joinColumns.map((joinColumn) => {
      return `${joinAlias}.${joinColumn.propertyName} = ${mainAlias}.${joinColumn.referencedColumn.propertyName}`;
    });
    const inverseJoinColumnConditions = relation.inverseRelation.inverseJoinColumns.map((inverseJoinColumn) => {
      return `${joinAlias}.${inverseJoinColumn.propertyName} IN (:...${inverseJoinColumn.propertyName})`;
    });
    const parameters = relation.inverseRelation.inverseJoinColumns.reduce((parameters2, joinColumn) => {
      parameters2[joinColumn.propertyName] = entities.map((entity) => joinColumn.referencedColumn.getEntityValue(entity, true));
      return parameters2;
    }, {});
    qb.innerJoin(joinAlias, joinAlias, [...joinColumnConditions, ...inverseJoinColumnConditions].join(" AND ")).setParameters(parameters);
    FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);
    return qb.getMany();
  }
  /**
   * Wraps given entity and creates getters/setters for its given relation
   * to be able to lazily load data when accessing this relation.
   */
  enableLazyLoad(relation, entity, queryRunner) {
    const relationLoader = this;
    const dataIndex = "__" + relation.propertyName + "__";
    const promiseIndex = "__promise_" + relation.propertyName + "__";
    const resolveIndex = "__has_" + relation.propertyName + "__";
    const setData = (entity2, value) => {
      entity2[dataIndex] = value;
      entity2[resolveIndex] = true;
      delete entity2[promiseIndex];
      return value;
    };
    const setPromise = (entity2, value) => {
      delete entity2[resolveIndex];
      delete entity2[dataIndex];
      entity2[promiseIndex] = value;
      value.then(
        // ensure different value is not assigned yet
        (result) => entity2[promiseIndex] === value ? setData(entity2, result) : result
      );
      return value;
    };
    Object.defineProperty(entity, relation.propertyName, {
      get: function() {
        if (this[resolveIndex] === true || this[dataIndex] !== void 0)
          return Promise.resolve(this[dataIndex]);
        if (this[promiseIndex])
          return this[promiseIndex];
        const loader = relationLoader.load(relation, this, queryRunner).then((result) => relation.isOneToOne || relation.isManyToOne ? result.length === 0 ? null : result[0] : result);
        return setPromise(this, loader);
      },
      set: function(value) {
        if (value instanceof Promise) {
          setPromise(this, value);
        } else {
          setData(this, value);
        }
      },
      configurable: true,
      enumerable: false
    });
  }
};

// ../node_modules/typeorm/browser/data-source/DataSource.js
registerQueryBuilders();
var DataSource = class {
  // -------------------------------------------------------------------------
  // Constructor
  // -------------------------------------------------------------------------
  constructor(options) {
    this["@instanceof"] = Symbol.for("DataSource");
    this.migrations = [];
    this.subscribers = [];
    this.entityMetadatas = [];
    this.entityMetadatasMap = /* @__PURE__ */ new Map();
    registerQueryBuilders();
    this.name = options.name || "default";
    this.options = options;
    this.logger = new LoggerFactory().create(this.options.logger, this.options.logging);
    this.driver = new DriverFactory().create(this);
    this.manager = this.createEntityManager();
    this.namingStrategy = options.namingStrategy || new DefaultNamingStrategy();
    this.metadataTableName = options.metadataTableName || "typeorm_metadata";
    this.queryResultCache = options.cache ? new QueryResultCacheFactory(this).create() : void 0;
    this.relationLoader = new RelationLoader(this);
    this.relationIdLoader = new RelationIdLoader2(this);
    this.isInitialized = false;
  }
  // -------------------------------------------------------------------------
  // Public Accessors
  // -------------------------------------------------------------------------
  /**
   Indicates if DataSource is initialized or not.
   *
   * @deprecated use .isInitialized instead
   */
  get isConnected() {
    return this.isInitialized;
  }
  /**
   * Gets the mongodb entity manager that allows to perform mongodb-specific repository operations
   * with any entity in this connection.
   *
   * Available only in mongodb connections.
   */
  get mongoManager() {
    if (!InstanceChecker.isMongoEntityManager(this.manager)) throw new TypeORMError(`MongoEntityManager is only available for MongoDB databases.`);
    return this.manager;
  }
  /**
   * Gets a sql.js specific Entity Manager that allows to perform special load and save operations
   *
   * Available only in connection with the sqljs driver.
   */
  get sqljsManager() {
    if (!InstanceChecker.isSqljsEntityManager(this.manager)) throw new TypeORMError(`SqljsEntityManager is only available for Sqljs databases.`);
    return this.manager;
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Updates current connection options with provided options.
   */
  setOptions(options) {
    Object.assign(this.options, options);
    if (options.logger || options.logging) {
      this.logger = new LoggerFactory().create(options.logger || this.options.logger, options.logging || this.options.logging);
    }
    if (options.namingStrategy) {
      this.namingStrategy = options.namingStrategy;
    }
    if (options.cache) {
      this.queryResultCache = new QueryResultCacheFactory(this).create();
    }
    if (options.database) {
      this.driver.database = DriverUtils.buildDriverOptions(this.options).database;
    }
    return this;
  }
  /**
   * Performs connection to the database.
   * This method should be called once on application bootstrap.
   * This method not necessarily creates database connection (depend on database type),
   * but it also can setup a connection pool with database to use.
   */
  initialize() {
    return __async(this, null, function* () {
      if (this.isInitialized) throw new CannotConnectAlreadyConnectedError(this.name);
      yield this.driver.connect();
      if (this.queryResultCache) yield this.queryResultCache.connect();
      ObjectUtils.assign(this, {
        isInitialized: true
      });
      try {
        yield this.buildMetadatas();
        yield this.driver.afterConnect();
        if (this.options.dropSchema) yield this.dropDatabase();
        if (this.options.migrationsRun) yield this.runMigrations({
          transaction: this.options.migrationsTransactionMode
        });
        if (this.options.synchronize) yield this.synchronize();
      } catch (error) {
        yield this.destroy();
        throw error;
      }
      return this;
    });
  }
  /**
   * Performs connection to the database.
   * This method should be called once on application bootstrap.
   * This method not necessarily creates database connection (depend on database type),
   * but it also can setup a connection pool with database to use.
   *
   * @deprecated use .initialize method instead
   */
  connect() {
    return __async(this, null, function* () {
      return this.initialize();
    });
  }
  /**
   * Closes connection with the database.
   * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.
   */
  destroy() {
    return __async(this, null, function* () {
      if (!this.isInitialized) throw new CannotExecuteNotConnectedError(this.name);
      yield this.driver.disconnect();
      if (this.queryResultCache) yield this.queryResultCache.disconnect();
      ObjectUtils.assign(this, {
        isInitialized: false
      });
    });
  }
  /**
   * Closes connection with the database.
   * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.
   *
   * @deprecated use .destroy method instead
   */
  close() {
    return __async(this, null, function* () {
      return this.destroy();
    });
  }
  /**
   * Creates database schema for all entities registered in this connection.
   * Can be used only after connection to the database is established.
   *
   * @param dropBeforeSync If set to true then it drops the database with all its tables and data
   */
  synchronize(dropBeforeSync = false) {
    return __async(this, null, function* () {
      if (!this.isInitialized) throw new CannotExecuteNotConnectedError(this.name);
      if (dropBeforeSync) yield this.dropDatabase();
      const schemaBuilder = this.driver.createSchemaBuilder();
      yield schemaBuilder.build();
    });
  }
  /**
   * Drops the database and all its data.
   * Be careful with this method on production since this method will erase all your database tables and their data.
   * Can be used only after connection to the database is established.
   */
  // TODO rename
  dropDatabase() {
    return __async(this, null, function* () {
      const queryRunner = this.createQueryRunner();
      try {
        if (this.driver.options.type === "mssql" || DriverUtils.isMySQLFamily(this.driver) || this.driver.options.type === "aurora-mysql" || DriverUtils.isSQLiteFamily(this.driver)) {
          const databases = [];
          this.entityMetadatas.forEach((metadata) => {
            if (metadata.database && databases.indexOf(metadata.database) === -1) databases.push(metadata.database);
          });
          if (databases.length === 0 && this.driver.database) {
            databases.push(this.driver.database);
          }
          if (databases.length === 0) {
            yield queryRunner.clearDatabase();
          } else {
            for (const database of databases) {
              yield queryRunner.clearDatabase(database);
            }
          }
        } else {
          yield queryRunner.clearDatabase();
        }
      } finally {
        yield queryRunner.release();
      }
    });
  }
  /**
   * Runs all pending migrations.
   * Can be used only after connection to the database is established.
   */
  runMigrations(options) {
    return __async(this, null, function* () {
      if (!this.isInitialized) throw new CannotExecuteNotConnectedError(this.name);
      const migrationExecutor = new MigrationExecutor(this);
      migrationExecutor.transaction = options?.transaction || this.options?.migrationsTransactionMode || "all";
      migrationExecutor.fake = options && options.fake || false;
      const successMigrations = yield migrationExecutor.executePendingMigrations();
      return successMigrations;
    });
  }
  /**
   * Reverts last executed migration.
   * Can be used only after connection to the database is established.
   */
  undoLastMigration(options) {
    return __async(this, null, function* () {
      if (!this.isInitialized) throw new CannotExecuteNotConnectedError(this.name);
      const migrationExecutor = new MigrationExecutor(this);
      migrationExecutor.transaction = options && options.transaction || "all";
      migrationExecutor.fake = options && options.fake || false;
      yield migrationExecutor.undoLastMigration();
    });
  }
  /**
   * Lists all migrations and whether they have been run.
   * Returns true if there are pending migrations
   */
  showMigrations() {
    return __async(this, null, function* () {
      if (!this.isInitialized) {
        throw new CannotExecuteNotConnectedError(this.name);
      }
      const migrationExecutor = new MigrationExecutor(this);
      return yield migrationExecutor.showMigrations();
    });
  }
  /**
   * Checks if entity metadata exist for the given entity class, target name or table name.
   */
  hasMetadata(target) {
    return !!this.findMetadata(target);
  }
  /**
   * Gets entity metadata for the given entity class or schema name.
   */
  getMetadata(target) {
    const metadata = this.findMetadata(target);
    if (!metadata) throw new EntityMetadataNotFoundError(target);
    return metadata;
  }
  /**
   * Gets repository for the given entity.
   */
  getRepository(target) {
    return this.manager.getRepository(target);
  }
  /**
   * Gets tree repository for the given entity class or name.
   * Only tree-type entities can have a TreeRepository, like ones decorated with @Tree decorator.
   */
  getTreeRepository(target) {
    return this.manager.getTreeRepository(target);
  }
  /**
   * Gets mongodb-specific repository for the given entity class or name.
   * Works only if connection is mongodb-specific.
   */
  getMongoRepository(target) {
    if (!(this.driver.options.type === "mongodb")) throw new TypeORMError(`You can use getMongoRepository only for MongoDB connections.`);
    return this.manager.getRepository(target);
  }
  /**
   * Gets custom entity repository marked with @EntityRepository decorator.
   *
   * @deprecated use Repository.extend function to create a custom repository
   */
  getCustomRepository(customRepository) {
    return this.manager.getCustomRepository(customRepository);
  }
  transaction(isolationOrRunInTransaction, runInTransactionParam) {
    return __async(this, null, function* () {
      return this.manager.transaction(isolationOrRunInTransaction, runInTransactionParam);
    });
  }
  /**
   * Executes raw SQL query and returns raw database results.
   *
   * @see [Official docs](https://typeorm.io/data-source-api) for examples.
   */
  query(query, parameters, queryRunner) {
    return __async(this, null, function* () {
      if (InstanceChecker.isMongoEntityManager(this.manager)) throw new TypeORMError(`Queries aren't supported by MongoDB.`);
      if (queryRunner && queryRunner.isReleased) throw new QueryRunnerProviderAlreadyReleasedError();
      const usedQueryRunner = queryRunner || this.createQueryRunner();
      try {
        return yield usedQueryRunner.query(query, parameters);
      } finally {
        if (!queryRunner) yield usedQueryRunner.release();
      }
    });
  }
  /**
   * Creates a new query builder that can be used to build a SQL query.
   */
  createQueryBuilder(entityOrRunner, alias, queryRunner) {
    if (InstanceChecker.isMongoEntityManager(this.manager)) throw new TypeORMError(`Query Builder is not supported by MongoDB.`);
    if (alias) {
      alias = DriverUtils.buildAlias(this.driver, void 0, alias);
      const metadata = this.getMetadata(entityOrRunner);
      return new SelectQueryBuilder(this, queryRunner).select(alias).from(metadata.target, alias);
    } else {
      return new SelectQueryBuilder(this, entityOrRunner);
    }
  }
  /**
   * Creates a query runner used for perform queries on a single database connection.
   * Using query runners you can control your queries to execute using single database connection and
   * manually control your database transaction.
   *
   * Mode is used in replication mode and indicates whatever you want to connect
   * to master database or any of slave databases.
   * If you perform writes you must use master database,
   * if you perform reads you can use slave databases.
   */
  createQueryRunner(mode = "master") {
    const queryRunner = this.driver.createQueryRunner(mode);
    const manager = this.createEntityManager(queryRunner);
    Object.assign(queryRunner, {
      manager
    });
    return queryRunner;
  }
  /**
   * Gets entity metadata of the junction table (many-to-many table).
   */
  getManyToManyMetadata(entityTarget, relationPropertyPath) {
    const relationMetadata = this.getMetadata(entityTarget).findRelationWithPropertyPath(relationPropertyPath);
    if (!relationMetadata) throw new TypeORMError(`Relation "${relationPropertyPath}" was not found in ${entityTarget} entity.`);
    if (!relationMetadata.isManyToMany) throw new TypeORMError(`Relation "${entityTarget}#${relationPropertyPath}" does not have a many-to-many relationship.You can use this method only on many-to-many relations.`);
    return relationMetadata.junctionEntityMetadata;
  }
  /**
   * Creates an Entity Manager for the current connection with the help of the EntityManagerFactory.
   */
  createEntityManager(queryRunner) {
    return new EntityManagerFactory().create(this, queryRunner);
  }
  // -------------------------------------------------------------------------
  // Protected Methods
  // -------------------------------------------------------------------------
  /**
   * Finds exist entity metadata by the given entity class, target name or table name.
   */
  findMetadata(target) {
    const metadataFromMap = this.entityMetadatasMap.get(target);
    if (metadataFromMap) return metadataFromMap;
    for (let [_, metadata] of this.entityMetadatasMap) {
      if (InstanceChecker.isEntitySchema(target) && metadata.name === target.options.name) {
        return metadata;
      }
      if (typeof target === "string") {
        if (target.indexOf(".") !== -1) {
          if (metadata.tablePath === target) {
            return metadata;
          }
        } else {
          if (metadata.name === target || metadata.tableName === target) {
            return metadata;
          }
        }
      }
      if (ObjectUtils.isObjectWithName(target) && typeof target.name === "string") {
        if (target.name.indexOf(".") !== -1) {
          if (metadata.tablePath === target.name) {
            return metadata;
          }
        } else {
          if (metadata.name === target.name || metadata.tableName === target.name) {
            return metadata;
          }
        }
      }
    }
    return void 0;
  }
  /**
   * Builds metadatas for all registered classes inside this connection.
   */
  buildMetadatas() {
    return __async(this, null, function* () {
      const connectionMetadataBuilder = new ConnectionMetadataBuilder(this);
      const entityMetadataValidator = new EntityMetadataValidator();
      const flattenedSubscribers = ObjectUtils.mixedListToArray(this.options.subscribers || []);
      const subscribers = yield connectionMetadataBuilder.buildSubscribers(flattenedSubscribers);
      ObjectUtils.assign(this, {
        subscribers
      });
      const flattenedEntities = ObjectUtils.mixedListToArray(this.options.entities || []);
      const entityMetadatas = yield connectionMetadataBuilder.buildEntityMetadatas(flattenedEntities);
      ObjectUtils.assign(this, {
        entityMetadatas,
        entityMetadatasMap: new Map(entityMetadatas.map((metadata) => [metadata.target, metadata]))
      });
      const flattenedMigrations = ObjectUtils.mixedListToArray(this.options.migrations || []);
      const migrations = yield connectionMetadataBuilder.buildMigrations(flattenedMigrations);
      ObjectUtils.assign(this, {
        migrations
      });
      entityMetadataValidator.validateMany(this.entityMetadatas.filter((metadata) => metadata.tableType !== "view"), this.driver);
      for (let entityMetadata of entityMetadatas) {
        if (InstanceChecker.isBaseEntityConstructor(entityMetadata.target)) {
          entityMetadata.target.useDataSource(this);
        }
      }
    });
  }
  /**
   * Get the replication mode SELECT queries should use for this datasource by default
   */
  defaultReplicationModeForReads() {
    if ("replication" in this.driver.options) {
      const value = this.driver.options.replication.defaultMode;
      if (value) {
        return value;
      }
    }
    return "slave";
  }
};

// ../node_modules/typeorm/browser/connection/ConnectionManager.js
var ConnectionManager = class {
  constructor() {
    this.connectionMap = /* @__PURE__ */ new Map();
  }
  /**
   * List of connections registered in this connection manager.
   */
  get connections() {
    return Array.from(this.connectionMap.values());
  }
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Checks if connection with the given name exist in the manager.
   */
  has(name) {
    return this.connectionMap.has(name);
  }
  /**
   * Gets registered connection with the given name.
   * If connection name is not given then it will get a default connection.
   * Throws error if connection with the given name was not found.
   */
  get(name = "default") {
    const connection = this.connectionMap.get(name);
    if (!connection) throw new ConnectionNotFoundError(name);
    return connection;
  }
  /**
   * Creates a new connection based on the given connection options and registers it in the manager.
   * Connection won't be established, you'll need to manually call connect method to establish connection.
   */
  create(options) {
    const existConnection = this.connectionMap.get(options.name || "default");
    if (existConnection) {
      if (existConnection.isInitialized) throw new AlreadyHasActiveConnectionError(options.name || "default");
    }
    const connection = new DataSource(options);
    this.connectionMap.set(connection.name, connection);
    return connection;
  }
};

// ../node_modules/typeorm/browser/globals.js
function getMetadataArgsStorage() {
  const globalScope = PlatformTools.getGlobalVariable();
  if (!globalScope.typeormMetadataArgsStorage) globalScope.typeormMetadataArgsStorage = new MetadataArgsStorage();
  return globalScope.typeormMetadataArgsStorage;
}
function getConnectionOptions(connectionName = "default") {
  return __async(this, null, function* () {
    return new ConnectionOptionsReader().get(connectionName);
  });
}
function getConnectionManager() {
  return getFromContainer(ConnectionManager);
}
function createConnection(optionsOrName) {
  return __async(this, null, function* () {
    const connectionName = typeof optionsOrName === "string" ? optionsOrName : "default";
    const options = ObjectUtils.isObject(optionsOrName) ? optionsOrName : yield getConnectionOptions(connectionName);
    return getConnectionManager().create(options).connect();
  });
}
function createConnections(options) {
  return __async(this, null, function* () {
    if (!options) options = yield new ConnectionOptionsReader().all();
    const connections = options.map((options2) => getConnectionManager().create(options2));
    for (const connection of connections) {
      yield connection.connect();
    }
    return connections;
  });
}
function getConnection(connectionName = "default") {
  return getConnectionManager().get(connectionName);
}
function getManager(connectionName = "default") {
  return getConnectionManager().get(connectionName).manager;
}
function getMongoManager(connectionName = "default") {
  return getConnectionManager().get(connectionName).manager;
}
function getSqljsManager(connectionName = "default") {
  return getConnectionManager().get(connectionName).manager;
}
function getRepository(entityClass, connectionName = "default") {
  return getConnectionManager().get(connectionName).getRepository(entityClass);
}
function getTreeRepository(entityClass, connectionName = "default") {
  return getConnectionManager().get(connectionName).getTreeRepository(entityClass);
}
function getCustomRepository(customRepository, connectionName = "default") {
  return getConnectionManager().get(connectionName).getCustomRepository(customRepository);
}
function getMongoRepository(entityClass, connectionName = "default") {
  return getConnectionManager().get(connectionName).getMongoRepository(entityClass);
}
function createQueryBuilder(entityClass, alias, connectionName = "default") {
  if (entityClass) {
    return getRepository(entityClass, connectionName).createQueryBuilder(alias);
  }
  return getConnection(connectionName).createQueryBuilder();
}

// ../node_modules/typeorm/browser/decorator/columns/Column.js
function Column(typeOrOptions, options) {
  return function(object, propertyName) {
    let type;
    if (typeof typeOrOptions === "string" || typeof typeOrOptions === "function") {
      type = typeOrOptions;
    } else if (typeOrOptions) {
      options = typeOrOptions;
      type = typeOrOptions.type;
    }
    if (!options) options = {};
    const reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : void 0;
    if (!type && reflectMetadataType)
      type = reflectMetadataType;
    if (!options.type && type) options.type = type;
    if (options.type === "hstore" && !options.hstoreType) options.hstoreType = reflectMetadataType === Object ? "object" : "string";
    if (typeof typeOrOptions === "function") {
      getMetadataArgsStorage().embeddeds.push({
        target: object.constructor,
        propertyName,
        isArray: reflectMetadataType === Array || options.array === true,
        prefix: options.prefix !== void 0 ? options.prefix : void 0,
        type: typeOrOptions
      });
    } else {
      if (!options.type) throw new ColumnTypeUndefinedError(object, propertyName);
      if (options.unique === true) getMetadataArgsStorage().uniques.push({
        target: object.constructor,
        columns: [propertyName]
      });
      getMetadataArgsStorage().columns.push({
        target: object.constructor,
        propertyName,
        mode: "regular",
        options
      });
      if (options.generated) {
        getMetadataArgsStorage().generations.push({
          target: object.constructor,
          propertyName,
          strategy: typeof options.generated === "string" ? options.generated : "increment"
        });
      }
    }
  };
}

// ../node_modules/typeorm/browser/decorator/columns/CreateDateColumn.js
function CreateDateColumn(options) {
  return function(object, propertyName) {
    getMetadataArgsStorage().columns.push({
      target: object.constructor,
      propertyName,
      mode: "createDate",
      options: options || {}
    });
  };
}

// ../node_modules/typeorm/browser/decorator/columns/DeleteDateColumn.js
function DeleteDateColumn(options) {
  return function(object, propertyName) {
    getMetadataArgsStorage().columns.push({
      target: object.constructor,
      propertyName,
      mode: "deleteDate",
      options: options || {}
    });
  };
}

// ../node_modules/typeorm/browser/decorator/columns/PrimaryGeneratedColumn.js
function PrimaryGeneratedColumn(strategyOrOptions, maybeOptions) {
  const options = {};
  let strategy;
  if (strategyOrOptions) {
    if (typeof strategyOrOptions === "string") strategy = strategyOrOptions;
    if (ObjectUtils.isObject(strategyOrOptions)) {
      strategy = "increment";
      Object.assign(options, strategyOrOptions);
    }
  } else {
    strategy = "increment";
  }
  if (ObjectUtils.isObject(maybeOptions)) Object.assign(options, maybeOptions);
  return function(object, propertyName) {
    if (!options.type) {
      if (strategy === "increment" || strategy === "identity") {
        options.type = Number;
      } else if (strategy === "uuid") {
        options.type = "uuid";
      } else if (strategy === "rowid") {
        options.type = "int";
      }
    }
    options.primary = true;
    getMetadataArgsStorage().columns.push({
      target: object.constructor,
      propertyName,
      mode: "regular",
      options
    });
    getMetadataArgsStorage().generations.push({
      target: object.constructor,
      propertyName,
      strategy
    });
  };
}

// ../node_modules/typeorm/browser/decorator/columns/PrimaryColumn.js
function PrimaryColumn(typeOrOptions, options) {
  return function(object, propertyName) {
    let type;
    if (typeof typeOrOptions === "string" || typeOrOptions === String || typeOrOptions === Boolean || typeOrOptions === Number) {
      type = typeOrOptions;
    } else {
      options = Object.assign({}, typeOrOptions);
    }
    if (!options) options = {};
    const reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : void 0;
    if (!type && reflectMetadataType) type = reflectMetadataType;
    if (!options.type && type) options.type = type;
    if (!options.type) throw new ColumnTypeUndefinedError(object, propertyName);
    if (options.nullable) throw new PrimaryColumnCannotBeNullableError(object, propertyName);
    options.primary = true;
    getMetadataArgsStorage().columns.push({
      target: object.constructor,
      propertyName,
      mode: "regular",
      options
    });
    if (options.generated) {
      getMetadataArgsStorage().generations.push({
        target: object.constructor,
        propertyName,
        strategy: typeof options.generated === "string" ? options.generated : "increment"
      });
    }
  };
}

// ../node_modules/typeorm/browser/decorator/columns/UpdateDateColumn.js
function UpdateDateColumn(options) {
  return function(object, propertyName) {
    getMetadataArgsStorage().columns.push({
      target: object.constructor,
      propertyName,
      mode: "updateDate",
      options: options ? options : {}
    });
  };
}

// ../node_modules/typeorm/browser/decorator/columns/VersionColumn.js
function VersionColumn(options) {
  return function(object, propertyName) {
    getMetadataArgsStorage().columns.push({
      target: object.constructor,
      propertyName,
      mode: "version",
      options: options || {}
    });
  };
}

// ../node_modules/typeorm/browser/decorator/columns/VirtualColumn.js
function VirtualColumn(typeOrOptions, options) {
  return function(object, propertyName) {
    let type;
    if (typeof typeOrOptions === "string") {
      type = typeOrOptions;
    } else {
      options = typeOrOptions;
      type = options.type;
    }
    if (!options?.query) {
      throw new Error("Column options must be defined for calculated columns.");
    }
    const reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : void 0;
    if (!type && reflectMetadataType)
      type = reflectMetadataType;
    if (type) options.type = type;
    if (options.type === "hstore" && !options.hstoreType) options.hstoreType = reflectMetadataType === Object ? "object" : "string";
    if (!options.type) throw new ColumnTypeUndefinedError(object, propertyName);
    getMetadataArgsStorage().columns.push({
      target: object.constructor,
      propertyName,
      mode: "virtual-property",
      options: options || {}
    });
  };
}

// ../node_modules/typeorm/browser/decorator/columns/ViewColumn.js
function ViewColumn(options) {
  return function(object, propertyName) {
    getMetadataArgsStorage().columns.push({
      target: object.constructor,
      propertyName,
      mode: "regular",
      options: options || {}
    });
  };
}

// ../node_modules/typeorm/browser/decorator/columns/ObjectIdColumn.js
function ObjectIdColumn(options) {
  return function(object, propertyName) {
    if (!options) options = {};
    options.primary = true;
    if (!options.name) options.name = "_id";
    getMetadataArgsStorage().columns.push({
      target: object.constructor,
      propertyName,
      mode: "objectId",
      options
    });
  };
}

// ../node_modules/typeorm/browser/decorator/listeners/AfterInsert.js
function AfterInsert() {
  return function(object, propertyName) {
    getMetadataArgsStorage().entityListeners.push({
      target: object.constructor,
      propertyName,
      type: EventListenerTypes.AFTER_INSERT
    });
  };
}

// ../node_modules/typeorm/browser/decorator/listeners/AfterLoad.js
function AfterLoad() {
  return function(object, propertyName) {
    getMetadataArgsStorage().entityListeners.push({
      target: object.constructor,
      propertyName,
      type: EventListenerTypes.AFTER_LOAD
    });
  };
}

// ../node_modules/typeorm/browser/decorator/listeners/AfterRemove.js
function AfterRemove() {
  return function(object, propertyName) {
    getMetadataArgsStorage().entityListeners.push({
      target: object.constructor,
      propertyName,
      type: EventListenerTypes.AFTER_REMOVE
    });
  };
}

// ../node_modules/typeorm/browser/decorator/listeners/AfterSoftRemove.js
function AfterSoftRemove() {
  return function(object, propertyName) {
    getMetadataArgsStorage().entityListeners.push({
      target: object.constructor,
      propertyName,
      type: EventListenerTypes.AFTER_SOFT_REMOVE
    });
  };
}

// ../node_modules/typeorm/browser/decorator/listeners/AfterRecover.js
function AfterRecover() {
  return function(object, propertyName) {
    getMetadataArgsStorage().entityListeners.push({
      target: object.constructor,
      propertyName,
      type: EventListenerTypes.AFTER_RECOVER
    });
  };
}

// ../node_modules/typeorm/browser/decorator/listeners/AfterUpdate.js
function AfterUpdate() {
  return function(object, propertyName) {
    getMetadataArgsStorage().entityListeners.push({
      target: object.constructor,
      propertyName,
      type: EventListenerTypes.AFTER_UPDATE
    });
  };
}

// ../node_modules/typeorm/browser/decorator/listeners/BeforeInsert.js
function BeforeInsert() {
  return function(object, propertyName) {
    getMetadataArgsStorage().entityListeners.push({
      target: object.constructor,
      propertyName,
      type: EventListenerTypes.BEFORE_INSERT
    });
  };
}

// ../node_modules/typeorm/browser/decorator/listeners/BeforeRemove.js
function BeforeRemove() {
  return function(object, propertyName) {
    getMetadataArgsStorage().entityListeners.push({
      target: object.constructor,
      propertyName,
      type: EventListenerTypes.BEFORE_REMOVE
    });
  };
}

// ../node_modules/typeorm/browser/decorator/listeners/BeforeSoftRemove.js
function BeforeSoftRemove() {
  return function(object, propertyName) {
    getMetadataArgsStorage().entityListeners.push({
      target: object.constructor,
      propertyName,
      type: EventListenerTypes.BEFORE_SOFT_REMOVE
    });
  };
}

// ../node_modules/typeorm/browser/decorator/listeners/BeforeRecover.js
function BeforeRecover() {
  return function(object, propertyName) {
    getMetadataArgsStorage().entityListeners.push({
      target: object.constructor,
      propertyName,
      type: EventListenerTypes.BEFORE_RECOVER
    });
  };
}

// ../node_modules/typeorm/browser/decorator/listeners/BeforeUpdate.js
function BeforeUpdate() {
  return function(object, propertyName) {
    getMetadataArgsStorage().entityListeners.push({
      target: object.constructor,
      propertyName,
      type: EventListenerTypes.BEFORE_UPDATE
    });
  };
}

// ../node_modules/typeorm/browser/decorator/listeners/EventSubscriber.js
function EventSubscriber() {
  return function(target) {
    getMetadataArgsStorage().entitySubscribers.push({
      target
    });
  };
}

// ../node_modules/typeorm/browser/decorator/relations/JoinColumn.js
function JoinColumn(optionsOrOptionsArray) {
  return function(object, propertyName) {
    const options = Array.isArray(optionsOrOptionsArray) ? optionsOrOptionsArray : [optionsOrOptionsArray || {}];
    options.forEach((options2) => {
      getMetadataArgsStorage().joinColumns.push({
        target: object.constructor,
        propertyName,
        name: options2.name,
        referencedColumnName: options2.referencedColumnName,
        foreignKeyConstraintName: options2.foreignKeyConstraintName
      });
    });
  };
}

// ../node_modules/typeorm/browser/decorator/relations/JoinTable.js
function JoinTable(options) {
  return function(object, propertyName) {
    options = options || {};
    getMetadataArgsStorage().joinTables.push({
      target: object.constructor,
      propertyName,
      name: options.name,
      joinColumns: options && options.joinColumn ? [options.joinColumn] : options.joinColumns,
      inverseJoinColumns: options && options.inverseJoinColumn ? [options.inverseJoinColumn] : options.inverseJoinColumns,
      schema: options && options.schema ? options.schema : void 0,
      database: options && options.database ? options.database : void 0,
      synchronize: !(options && options.synchronize === false)
    });
  };
}

// ../node_modules/typeorm/browser/decorator/relations/ManyToMany.js
function ManyToMany(typeFunctionOrTarget, inverseSideOrOptions, options) {
  let inverseSideProperty;
  if (ObjectUtils.isObject(inverseSideOrOptions)) {
    options = inverseSideOrOptions;
  } else {
    inverseSideProperty = inverseSideOrOptions;
  }
  return function(object, propertyName) {
    if (!options) options = {};
    let isLazy = options.lazy === true;
    if (!isLazy && Reflect && Reflect.getMetadata) {
      const reflectedType = Reflect.getMetadata("design:type", object, propertyName);
      if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise") isLazy = true;
    }
    getMetadataArgsStorage().relations.push({
      target: object.constructor,
      propertyName,
      // propertyType: reflectedType,
      relationType: "many-to-many",
      isLazy,
      type: typeFunctionOrTarget,
      inverseSideProperty,
      options
    });
  };
}

// ../node_modules/typeorm/browser/decorator/relations/ManyToOne.js
function ManyToOne(typeFunctionOrTarget, inverseSideOrOptions, options) {
  let inverseSideProperty;
  if (ObjectUtils.isObject(inverseSideOrOptions)) {
    options = inverseSideOrOptions;
  } else {
    inverseSideProperty = inverseSideOrOptions;
  }
  return function(object, propertyName) {
    if (!options) options = {};
    let isLazy = options && options.lazy === true;
    if (!isLazy && Reflect && Reflect.getMetadata) {
      const reflectedType = Reflect.getMetadata("design:type", object, propertyName);
      if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise") isLazy = true;
    }
    getMetadataArgsStorage().relations.push({
      target: object.constructor,
      propertyName,
      // propertyType: reflectedType,
      relationType: "many-to-one",
      isLazy,
      type: typeFunctionOrTarget,
      inverseSideProperty,
      options
    });
  };
}

// ../node_modules/typeorm/browser/decorator/relations/OneToMany.js
function OneToMany(typeFunctionOrTarget, inverseSide, options) {
  return function(object, propertyName) {
    if (!options) options = {};
    let isLazy = options && options.lazy === true;
    if (!isLazy && Reflect && Reflect.getMetadata) {
      const reflectedType = Reflect.getMetadata("design:type", object, propertyName);
      if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise") isLazy = true;
    }
    getMetadataArgsStorage().relations.push({
      target: object.constructor,
      propertyName,
      // propertyType: reflectedType,
      isLazy,
      relationType: "one-to-many",
      type: typeFunctionOrTarget,
      inverseSideProperty: inverseSide,
      options
    });
  };
}

// ../node_modules/typeorm/browser/decorator/relations/OneToOne.js
function OneToOne(typeFunctionOrTarget, inverseSideOrOptions, options) {
  let inverseSideProperty;
  if (ObjectUtils.isObject(inverseSideOrOptions)) {
    options = inverseSideOrOptions;
  } else {
    inverseSideProperty = inverseSideOrOptions;
  }
  return function(object, propertyName) {
    if (!options) options = {};
    let isLazy = options && options.lazy === true ? true : false;
    if (!isLazy && Reflect && Reflect.getMetadata) {
      const reflectedType = Reflect.getMetadata("design:type", object, propertyName);
      if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise") isLazy = true;
    }
    getMetadataArgsStorage().relations.push({
      target: object.constructor,
      propertyName,
      // propertyType: reflectedType,
      isLazy,
      relationType: "one-to-one",
      type: typeFunctionOrTarget,
      inverseSideProperty,
      options
    });
  };
}

// ../node_modules/typeorm/browser/decorator/relations/RelationCount.js
function RelationCount(relation, alias, queryBuilderFactory) {
  return function(object, propertyName) {
    getMetadataArgsStorage().relationCounts.push({
      target: object.constructor,
      propertyName,
      relation,
      alias,
      queryBuilderFactory
    });
  };
}

// ../node_modules/typeorm/browser/decorator/relations/RelationId.js
function RelationId(relation, alias, queryBuilderFactory) {
  return function(object, propertyName) {
    getMetadataArgsStorage().relationIds.push({
      target: object.constructor,
      propertyName,
      relation,
      alias,
      queryBuilderFactory
    });
  };
}

// ../node_modules/typeorm/browser/decorator/entity/Entity.js
function Entity(nameOrOptions, maybeOptions) {
  const options = (ObjectUtils.isObject(nameOrOptions) ? nameOrOptions : maybeOptions) || {};
  const name = typeof nameOrOptions === "string" ? nameOrOptions : options.name;
  return function(target) {
    getMetadataArgsStorage().tables.push({
      target,
      name,
      type: "regular",
      orderBy: options.orderBy ? options.orderBy : void 0,
      engine: options.engine ? options.engine : void 0,
      database: options.database ? options.database : void 0,
      schema: options.schema ? options.schema : void 0,
      synchronize: options.synchronize,
      withoutRowid: options.withoutRowid,
      comment: options.comment ? options.comment : void 0
    });
  };
}

// ../node_modules/typeorm/browser/decorator/entity/ChildEntity.js
function ChildEntity(discriminatorValue) {
  return function(target) {
    getMetadataArgsStorage().tables.push({
      target,
      type: "entity-child"
    });
    if (typeof discriminatorValue !== "undefined") {
      getMetadataArgsStorage().discriminatorValues.push({
        target,
        value: discriminatorValue
      });
    }
  };
}

// ../node_modules/typeorm/browser/decorator/entity/TableInheritance.js
function TableInheritance(options) {
  return function(target) {
    getMetadataArgsStorage().inheritances.push({
      target,
      pattern: options && options.pattern ? options.pattern : "STI",
      column: options && options.column ? typeof options.column === "string" ? {
        name: options.column
      } : options.column : void 0
    });
  };
}

// ../node_modules/typeorm/browser/decorator/entity-view/ViewEntity.js
function ViewEntity(nameOrOptions, maybeOptions) {
  const options = (ObjectUtils.isObject(nameOrOptions) ? nameOrOptions : maybeOptions) || {};
  const name = typeof nameOrOptions === "string" ? nameOrOptions : options.name;
  return function(target) {
    getMetadataArgsStorage().tables.push({
      target,
      name,
      expression: options.expression,
      dependsOn: options.dependsOn ? new Set(options.dependsOn) : void 0,
      type: "view",
      database: options.database ? options.database : void 0,
      schema: options.schema ? options.schema : void 0,
      synchronize: options.synchronize === false ? false : true,
      materialized: !!options.materialized
    });
  };
}

// ../node_modules/typeorm/browser/decorator/tree/TreeLevelColumn.js
function TreeLevelColumn() {
  return function(object, propertyName) {
    getMetadataArgsStorage().columns.push({
      target: object.constructor,
      propertyName,
      mode: "treeLevel",
      options: {}
    });
  };
}

// ../node_modules/typeorm/browser/decorator/tree/TreeParent.js
function TreeParent(options) {
  return function(object, propertyName) {
    if (!options) options = {};
    const reflectedType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : void 0;
    const isLazy = reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise" || false;
    getMetadataArgsStorage().relations.push({
      isTreeParent: true,
      target: object.constructor,
      propertyName,
      isLazy,
      relationType: "many-to-one",
      type: () => object.constructor,
      options
    });
  };
}

// ../node_modules/typeorm/browser/decorator/tree/TreeChildren.js
function TreeChildren(options) {
  return function(object, propertyName) {
    if (!options) options = {};
    const reflectedType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : void 0;
    const isLazy = reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise" || false;
    getMetadataArgsStorage().relations.push({
      isTreeChildren: true,
      target: object.constructor,
      propertyName,
      isLazy,
      relationType: "one-to-many",
      type: () => object.constructor,
      options
    });
  };
}

// ../node_modules/typeorm/browser/decorator/tree/Tree.js
function Tree(type, options) {
  return function(target) {
    getMetadataArgsStorage().trees.push({
      target,
      type,
      options: type === "closure-table" ? options : void 0
    });
  };
}

// ../node_modules/typeorm/browser/decorator/Index.js
function Index(nameOrFieldsOrOptions, maybeFieldsOrOptions, maybeOptions) {
  const name = typeof nameOrFieldsOrOptions === "string" ? nameOrFieldsOrOptions : void 0;
  const fields = typeof nameOrFieldsOrOptions === "string" ? maybeFieldsOrOptions : nameOrFieldsOrOptions;
  let options = ObjectUtils.isObject(nameOrFieldsOrOptions) && !Array.isArray(nameOrFieldsOrOptions) ? nameOrFieldsOrOptions : maybeOptions;
  if (!options) options = ObjectUtils.isObject(maybeFieldsOrOptions) && !Array.isArray(maybeFieldsOrOptions) ? maybeFieldsOrOptions : maybeOptions;
  return function(clsOrObject, propertyName) {
    getMetadataArgsStorage().indices.push({
      target: propertyName ? clsOrObject.constructor : clsOrObject,
      name,
      columns: propertyName ? [propertyName] : fields,
      synchronize: options && options.synchronize === false ? false : true,
      where: options ? options.where : void 0,
      unique: options && options.unique ? true : false,
      spatial: options && options.spatial ? true : false,
      fulltext: options && options.fulltext ? true : false,
      nullFiltered: options && options.nullFiltered ? true : false,
      parser: options ? options.parser : void 0,
      sparse: options && options.sparse ? true : false,
      background: options && options.background ? true : false,
      concurrent: options && options.concurrent ? true : false,
      expireAfterSeconds: options ? options.expireAfterSeconds : void 0
    });
  };
}

// ../node_modules/typeorm/browser/decorator/Unique.js
function Unique(nameOrFieldsOrOptions, maybeFieldsOrOptions, maybeOptions) {
  const name = typeof nameOrFieldsOrOptions === "string" ? nameOrFieldsOrOptions : void 0;
  const fields = typeof nameOrFieldsOrOptions === "string" ? maybeFieldsOrOptions : nameOrFieldsOrOptions;
  let options = ObjectUtils.isObject(nameOrFieldsOrOptions) && !Array.isArray(nameOrFieldsOrOptions) ? nameOrFieldsOrOptions : maybeOptions;
  if (!options) options = ObjectUtils.isObject(nameOrFieldsOrOptions) && !Array.isArray(maybeFieldsOrOptions) ? maybeFieldsOrOptions : maybeOptions;
  return function(clsOrObject, propertyName) {
    let columns = fields;
    if (propertyName !== void 0) {
      switch (typeof propertyName) {
        case "string":
          columns = [propertyName];
          break;
        case "symbol":
          columns = [propertyName.toString()];
          break;
      }
    }
    const args = {
      target: propertyName ? clsOrObject.constructor : clsOrObject,
      name,
      columns,
      deferrable: options ? options.deferrable : void 0
    };
    getMetadataArgsStorage().uniques.push(args);
  };
}

// ../node_modules/typeorm/browser/decorator/Check.js
function Check(nameOrExpression, maybeExpression) {
  const name = maybeExpression ? nameOrExpression : void 0;
  const expression = maybeExpression ? maybeExpression : nameOrExpression;
  if (!expression) throw new TypeORMError(`Check expression is required`);
  return function(clsOrObject, propertyName) {
    getMetadataArgsStorage().checks.push({
      target: propertyName ? clsOrObject.constructor : clsOrObject,
      name,
      expression
    });
  };
}

// ../node_modules/typeorm/browser/decorator/Exclusion.js
function Exclusion(nameOrExpression, maybeExpression) {
  const name = maybeExpression ? nameOrExpression : void 0;
  const expression = maybeExpression ? maybeExpression : nameOrExpression;
  if (!expression) throw new TypeORMError(`Exclusion expression is required`);
  return function(clsOrObject, propertyName) {
    getMetadataArgsStorage().exclusions.push({
      target: propertyName ? clsOrObject.constructor : clsOrObject,
      name,
      expression
    });
  };
}

// ../node_modules/typeorm/browser/decorator/Generated.js
function Generated(strategy = "increment") {
  return function(object, propertyName) {
    getMetadataArgsStorage().generations.push({
      target: object.constructor,
      propertyName,
      strategy
    });
  };
}

// ../node_modules/typeorm/browser/decorator/EntityRepository.js
function EntityRepository(entity) {
  return function(target) {
    getMetadataArgsStorage().entityRepositories.push({
      target,
      entity
    });
  };
}

// ../node_modules/typeorm/browser/find-options/operator/And.js
function And(...values) {
  return new FindOperator("and", values, true, true);
}

// ../node_modules/typeorm/browser/find-options/operator/Or.js
function Or(...values) {
  return new FindOperator("or", values, true, true);
}

// ../node_modules/typeorm/browser/find-options/operator/Any.js
function Any(value) {
  return new FindOperator("any", value);
}

// ../node_modules/typeorm/browser/find-options/operator/ArrayContainedBy.js
function ArrayContainedBy(value) {
  return new FindOperator("arrayContainedBy", value);
}

// ../node_modules/typeorm/browser/find-options/operator/ArrayContains.js
function ArrayContains(value) {
  return new FindOperator("arrayContains", value);
}

// ../node_modules/typeorm/browser/find-options/operator/ArrayOverlap.js
function ArrayOverlap(value) {
  return new FindOperator("arrayOverlap", value);
}

// ../node_modules/typeorm/browser/find-options/operator/Between.js
function Between(from, to) {
  return new FindOperator("between", [from, to], true, true);
}

// ../node_modules/typeorm/browser/find-options/EqualOperator.js
var EqualOperator = class extends FindOperator {
  constructor(value) {
    super("equal", value);
    this["@instanceof"] = Symbol.for("EqualOperator");
  }
};

// ../node_modules/typeorm/browser/find-options/operator/Equal.js
function Equal(value) {
  return new EqualOperator(value);
}

// ../node_modules/typeorm/browser/find-options/operator/IsNull.js
function IsNull() {
  return new FindOperator("isNull", void 0, false);
}

// ../node_modules/typeorm/browser/find-options/operator/LessThan.js
function LessThan(value) {
  return new FindOperator("lessThan", value);
}

// ../node_modules/typeorm/browser/find-options/operator/LessThanOrEqual.js
function LessThanOrEqual(value) {
  return new FindOperator("lessThanOrEqual", value);
}

// ../node_modules/typeorm/browser/find-options/operator/ILike.js
function ILike(value) {
  return new FindOperator("ilike", value);
}

// ../node_modules/typeorm/browser/find-options/operator/Like.js
function Like(value) {
  return new FindOperator("like", value);
}

// ../node_modules/typeorm/browser/find-options/operator/MoreThan.js
function MoreThan(value) {
  return new FindOperator("moreThan", value);
}

// ../node_modules/typeorm/browser/find-options/operator/MoreThanOrEqual.js
function MoreThanOrEqual(value) {
  return new FindOperator("moreThanOrEqual", value);
}

// ../node_modules/typeorm/browser/find-options/operator/Not.js
function Not(value) {
  return new FindOperator("not", value);
}

// ../node_modules/typeorm/browser/find-options/operator/Raw.js
function Raw(valueOrSqlGenerator, sqlGeneratorParameters) {
  if (typeof valueOrSqlGenerator !== "function") {
    return new FindOperator("raw", valueOrSqlGenerator, false);
  }
  return new FindOperator("raw", [], true, true, valueOrSqlGenerator, sqlGeneratorParameters);
}

// ../node_modules/typeorm/browser/find-options/operator/JsonContains.js
function JsonContains(value) {
  return new FindOperator("jsonContains", value);
}

// ../node_modules/typeorm/browser/repository/BaseEntity.js
var BaseEntity = class {
  // -------------------------------------------------------------------------
  // Public Methods
  // -------------------------------------------------------------------------
  /**
   * Checks if entity has an id.
   * If entity composite compose ids, it will check them all.
   */
  hasId() {
    const baseEntity = this.constructor;
    return baseEntity.getRepository().hasId(this);
  }
  /**
   * Saves current entity in the database.
   * If entity does not exist in the database then inserts, otherwise updates.
   */
  save(options) {
    const baseEntity = this.constructor;
    return baseEntity.getRepository().save(this, options);
  }
  /**
   * Removes current entity from the database.
   */
  remove(options) {
    const baseEntity = this.constructor;
    return baseEntity.getRepository().remove(this, options);
  }
  /**
   * Records the delete date of current entity.
   */
  softRemove(options) {
    const baseEntity = this.constructor;
    return baseEntity.getRepository().softRemove(this, options);
  }
  /**
   * Recovers a given entity in the database.
   */
  recover(options) {
    const baseEntity = this.constructor;
    return baseEntity.getRepository().recover(this, options);
  }
  /**
   * Reloads entity data from the database.
   */
  reload() {
    return __async(this, null, function* () {
      const baseEntity = this.constructor;
      const id = baseEntity.getRepository().metadata.getEntityIdMap(this);
      if (!id) {
        throw new Error(`Entity doesn't have id-s set, cannot reload entity`);
      }
      const reloadedEntity = yield baseEntity.getRepository().findOneByOrFail(id);
      ObjectUtils.assign(this, reloadedEntity);
    });
  }
  // -------------------------------------------------------------------------
  // Public Static Methods
  // -------------------------------------------------------------------------
  /**
   * Sets DataSource to be used by entity.
   */
  static useDataSource(dataSource) {
    this.dataSource = dataSource;
  }
  /**
   * Gets current entity's Repository.
   */
  static getRepository() {
    const dataSource = this.dataSource;
    if (!dataSource) throw new Error(`DataSource is not set for this entity.`);
    return dataSource.getRepository(this);
  }
  /**
   * Returns object that is managed by this repository.
   * If this repository manages entity from schema,
   * then it returns a name of that schema instead.
   */
  static get target() {
    return this.getRepository().target;
  }
  /**
   * Checks entity has an id.
   * If entity composite compose ids, it will check them all.
   */
  static hasId(entity) {
    return this.getRepository().hasId(entity);
  }
  /**
   * Gets entity mixed id.
   */
  static getId(entity) {
    return this.getRepository().getId(entity);
  }
  /**
   * Creates a new query builder that can be used to build a SQL query.
   */
  static createQueryBuilder(alias) {
    return this.getRepository().createQueryBuilder(alias);
  }
  /**
   * Creates a new entity instance and copies all entity properties from this object into a new entity.
   * Note that it copies only properties that present in entity schema.
   */
  static create(entityOrEntities) {
    return this.getRepository().create(entityOrEntities);
  }
  /**
   * Merges multiple entities (or entity-like objects) into a given entity.
   */
  static merge(mergeIntoEntity, ...entityLikes) {
    return this.getRepository().merge(mergeIntoEntity, ...entityLikes);
  }
  /**
   * Creates a new entity from the given plain javascript object. If entity already exist in the database, then
   * it loads it (and everything related to it), replaces all values with the new ones from the given object
   * and returns this new entity. This new entity is actually a loaded from the db entity with all properties
   * replaced from the new object.
   *
   * Note that given entity-like object must have an entity id / primary key to find entity by.
   * Returns undefined if entity with given id was not found.
   */
  static preload(entityLike) {
    const thisRepository = this.getRepository();
    return thisRepository.preload(entityLike);
  }
  /**
   * Saves one or many given entities.
   */
  static save(entityOrEntities, options) {
    return this.getRepository().save(entityOrEntities, options);
  }
  /**
   * Removes one or many given entities.
   */
  static remove(entityOrEntities, options) {
    return this.getRepository().remove(entityOrEntities, options);
  }
  /**
   * Records the delete date of one or many given entities.
   */
  static softRemove(entityOrEntities, options) {
    return this.getRepository().softRemove(entityOrEntities, options);
  }
  /**
   * Inserts a given entity into the database.
   * Unlike save method executes a primitive operation without cascades, relations and other operations included.
   * Executes fast and efficient INSERT query.
   * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.
   */
  static insert(entity) {
    return this.getRepository().insert(entity);
  }
  /**
   * Updates entity partially. Entity can be found by a given conditions.
   * Unlike save method executes a primitive operation without cascades, relations and other operations included.
   * Executes fast and efficient UPDATE query.
   * Does not check if entity exist in the database.
   */
  static update(criteria, partialEntity) {
    return this.getRepository().update(criteria, partialEntity);
  }
  /**
   * Inserts a given entity into the database, unless a unique constraint conflicts then updates the entity
   * Unlike save method executes a primitive operation without cascades, relations and other operations included.
   * Executes fast and efficient INSERT ... ON CONFLICT DO UPDATE/ON DUPLICATE KEY UPDATE query.
   */
  static upsert(entityOrEntities, conflictPathsOrOptions) {
    return this.getRepository().upsert(entityOrEntities, conflictPathsOrOptions);
  }
  /**
   * Deletes entities by a given criteria.
   * Unlike remove method executes a primitive operation without cascades, relations and other operations included.
   * Executes fast and efficient DELETE query.
   * Does not check if entity exist in the database.
   */
  static delete(criteria) {
    return this.getRepository().delete(criteria);
  }
  /**
   * Checks whether any entity exists that matches the given options.
   */
  static exists(options) {
    return this.getRepository().exists(options);
  }
  /**
   * Checks whether any entity exists that matches the given conditions.
   */
  static existsBy(where) {
    return this.getRepository().existsBy(where);
  }
  /**
   * Counts entities that match given options.
   */
  static count(options) {
    return this.getRepository().count(options);
  }
  /**
   * Counts entities that match given WHERE conditions.
   */
  static countBy(where) {
    return this.getRepository().countBy(where);
  }
  /**
   * Return the SUM of a column
   */
  static sum(columnName, where) {
    return this.getRepository().sum(columnName, where);
  }
  /**
   * Return the AVG of a column
   */
  static average(columnName, where) {
    return this.getRepository().average(columnName, where);
  }
  /**
   * Return the MIN of a column
   */
  static minimum(columnName, where) {
    return this.getRepository().minimum(columnName, where);
  }
  /**
   * Return the MAX of a column
   */
  static maximum(columnName, where) {
    return this.getRepository().maximum(columnName, where);
  }
  /**
   * Finds entities that match given options.
   */
  static find(options) {
    return this.getRepository().find(options);
  }
  /**
   * Finds entities that match given WHERE conditions.
   */
  static findBy(where) {
    return this.getRepository().findBy(where);
  }
  /**
   * Finds entities that match given find options.
   * Also counts all entities that match given conditions,
   * but ignores pagination settings (from and take options).
   */
  static findAndCount(options) {
    return this.getRepository().findAndCount(options);
  }
  /**
   * Finds entities that match given WHERE conditions.
   * Also counts all entities that match given conditions,
   * but ignores pagination settings (from and take options).
   */
  static findAndCountBy(where) {
    return this.getRepository().findAndCountBy(where);
  }
  /**
   * Finds entities by ids.
   * Optionally find options can be applied.
   *
   * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:
   *
   * .findBy({
   *     id: In([1, 2, 3])
   * })
   */
  static findByIds(ids) {
    return this.getRepository().findByIds(ids);
  }
  /**
   * Finds first entity that matches given conditions.
   */
  static findOne(options) {
    return this.getRepository().findOne(options);
  }
  /**
   * Finds first entity that matches given conditions.
   */
  static findOneBy(where) {
    return this.getRepository().findOneBy(where);
  }
  /**
   * Finds first entity that matches given options.
   *
   * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:
   *
   * .findOneBy({
   *     id: 1 // where "id" is your primary column name
   * })
   */
  static findOneById(id) {
    return this.getRepository().findOneById(id);
  }
  /**
   * Finds first entity that matches given conditions.
   */
  static findOneOrFail(options) {
    return this.getRepository().findOneOrFail(options);
  }
  /**
   * Finds first entity that matches given conditions.
   */
  static findOneByOrFail(where) {
    return this.getRepository().findOneByOrFail(where);
  }
  /**
   * Executes a raw SQL query and returns a raw database results.
   * Raw query execution is supported only by relational databases (MongoDB is not supported).
   */
  static query(query, parameters) {
    return this.getRepository().query(query, parameters);
  }
  /**
   * Clears all the data from the given table/collection (truncates/drops it).
   */
  static clear() {
    return this.getRepository().clear();
  }
};

// ../node_modules/typeorm/browser/connection/Connection.js
var Connection = class extends DataSource {
};

// ../node_modules/typeorm/browser/query-builder/NotBrackets.js
var NotBrackets = class extends Brackets {
  constructor() {
    super(...arguments);
    this["@instanceof"] = Symbol.for("NotBrackets");
  }
};

// ../node_modules/typeorm/browser/naming-strategy/LegacyOracleNamingStrategy.js
var LegacyOracleNamingStrategy = class extends DefaultNamingStrategy {
  constructor(shortenStrategy = "hash") {
    super();
    this.IDENTIFIER_MAX_SIZE = 30;
    this.DEFAULT_COLUMN_PREFIX = "COL_";
    this.shortenStrategy = shortenStrategy;
  }
  columnName(propertyName, customName, embeddedPrefixes) {
    const longName = super.columnName(propertyName, customName, embeddedPrefixes);
    if (this.shortenStrategy === "truncate") {
      return this.truncateIdentifier(longName);
    } else if (this.shortenStrategy === "hash") {
      return this.hashIdentifier(longName, this.DEFAULT_COLUMN_PREFIX);
    } else {
      throw new TypeORMError(`Invalid shortenStrategy`);
    }
  }
  hashIdentifier(input, prefix) {
    if (prefix.length >= this.IDENTIFIER_MAX_SIZE) {
      throw new TypeORMError(`Prefix must be shorter than IDENTIFIER_MAX_SIZE`);
    }
    return prefix + RandomGenerator.sha1(input).substring(0, this.IDENTIFIER_MAX_SIZE - prefix.length);
  }
  truncateIdentifier(input) {
    if (input.length > this.IDENTIFIER_MAX_SIZE) {
      return input.substring(0, this.IDENTIFIER_MAX_SIZE);
    } else {
      return input;
    }
  }
};

// ../node_modules/typeorm/browser/entity-schema/EntitySchema.js
var EntitySchema = class {
  constructor(options) {
    this.options = options;
    this["@instanceof"] = Symbol.for("EntitySchema");
  }
};

// ../node_modules/typeorm/browser/entity-schema/EntitySchemaEmbeddedColumnOptions.js
var EntitySchemaEmbeddedColumnOptions = class {
};

// ../node_modules/typeorm/browser/entity-schema/EntitySchemaOptions.js
var EntitySchemaOptions = class {
};
export {
  AbstractLogger,
  AbstractRepository,
  AdvancedConsoleLogger,
  AfterInsert,
  AfterLoad,
  AfterRecover,
  AfterRemove,
  AfterSoftRemove,
  AfterUpdate,
  AlreadyHasActiveConnectionError,
  And,
  Any,
  ArrayContainedBy,
  ArrayContains,
  ArrayOverlap,
  AuroraMysqlDriver,
  AuroraPostgresDriver,
  BaseEntity,
  BeforeInsert,
  BeforeRecover,
  BeforeRemove,
  BeforeSoftRemove,
  BeforeUpdate,
  BetterSqlite3Driver,
  Between,
  Brackets,
  CannotAttachTreeChildrenEntityError,
  CannotConnectAlreadyConnectedError,
  CannotCreateEntityIdMapError,
  CannotDetermineEntityError,
  CannotExecuteNotConnectedError,
  CannotGetEntityManagerNotConnectedError,
  CannotReflectMethodParameterTypeError,
  Check,
  ChildEntity,
  CircularRelationsError,
  CockroachDriver,
  Column,
  ColumnTypeUndefinedError,
  Connection,
  ConnectionIsNotSetError,
  ConnectionManager,
  ConnectionNotFoundError,
  ConnectionOptionsReader,
  CreateDateColumn,
  CustomRepositoryCannotInheritRepositoryError,
  CustomRepositoryDoesNotHaveEntityError,
  CustomRepositoryNotFoundError,
  DataSource,
  DataTypeNotSupportedError,
  DefaultNamingStrategy,
  DeleteDateColumn,
  DeleteQueryBuilder,
  DeleteResult,
  DriverOptionNotSetError,
  DriverPackageNotInstalledError,
  DummyLogger,
  Entity,
  EntityManager,
  EntityMetadata,
  EntityMetadataNotFoundError,
  EntityNotFoundError,
  EntityPropertyNotFoundError,
  EntityRepository,
  EntitySchema,
  EntitySchemaEmbeddedColumnOptions,
  EntitySchemaOptions,
  Equal,
  EqualOperator,
  EventSubscriber,
  Exclusion,
  FileLogger,
  FindOperator,
  FindOptionsUtils,
  FindRelationsNotFoundError,
  ForbiddenTransactionModeOverrideError,
  Generated,
  ILike,
  In,
  Index,
  InitializedRelationError,
  InsertQueryBuilder,
  InsertResult,
  InsertValuesMissingError,
  InstanceChecker,
  IsNull,
  JoinColumn,
  JoinTable,
  JsonContains,
  LegacyOracleNamingStrategy,
  LessThan,
  LessThanOrEqual,
  Like,
  LimitOnUpdateNotSupportedError,
  LockNotSupportedOnGivenDriverError,
  ManyToMany,
  ManyToOne,
  MetadataAlreadyExistsError,
  MetadataWithSuchNameAlreadyExistsError,
  Migration,
  MigrationExecutor,
  MissingDeleteDateColumnError,
  MissingDriverError,
  MissingJoinColumnError,
  MissingJoinTableError,
  MissingPrimaryColumnError,
  MongoDriver,
  MongoEntityManager,
  MongoQueryRunner,
  MongoRepository,
  MoreThan,
  MoreThanOrEqual,
  MssqlParameter,
  MustBeEntityError,
  MysqlDriver,
  NamingStrategyNotFoundError,
  NoConnectionForRepositoryError,
  NoConnectionOptionError,
  NoNeedToReleaseEntityManagerError,
  NoVersionOrUpdateDateColumnError,
  Not,
  NotBrackets,
  ObjectIdColumn,
  OffsetWithoutLimitNotSupportedError,
  OneToMany,
  OneToOne,
  OptimisticLockCanNotBeUsedError,
  OptimisticLockVersionMismatchError,
  Or,
  OracleDriver,
  PersistedEntityNotFoundError,
  PessimisticLockTransactionRequiredError,
  PostgresDriver,
  PrimaryColumn,
  PrimaryColumnCannotBeNullableError,
  PrimaryGeneratedColumn,
  QueryBuilder,
  QueryFailedError,
  QueryResult,
  QueryRunnerAlreadyReleasedError,
  QueryRunnerProviderAlreadyReleasedError,
  Raw,
  RelationCount,
  RelationId,
  RelationQueryBuilder,
  Repository,
  RepositoryNotTreeError,
  ReturningStatementNotSupportedError,
  SapDriver,
  SelectQueryBuilder,
  SimpleConsoleLogger,
  SqlServerDriver,
  SqliteDriver,
  SubjectRemovedAndUpdatedError,
  SubjectWithoutIdentifierError,
  Table,
  TableCheck,
  TableColumn,
  TableExclusion,
  TableForeignKey,
  TableIndex,
  TableInheritance,
  TableUnique,
  TransactionAlreadyStartedError,
  TransactionNotStartedError,
  Tree,
  TreeChildren,
  TreeLevelColumn,
  TreeParent,
  TreeRepository,
  TreeRepositoryNotSupportedError,
  TreeRepositoryUtils,
  TypeORMError,
  Unique,
  UpdateDateColumn,
  UpdateQueryBuilder,
  UpdateResult,
  UpdateValuesMissingError,
  UsingJoinColumnIsNotAllowedError,
  UsingJoinColumnOnlyOnOneSideAllowedError,
  UsingJoinTableIsNotAllowedError,
  UsingJoinTableOnlyOnOneSideAllowedError,
  VersionColumn,
  View,
  ViewColumn,
  ViewEntity,
  VirtualColumn,
  createConnection,
  createConnections,
  createQueryBuilder,
  getConnection,
  getConnectionManager,
  getConnectionOptions,
  getCustomRepository,
  getFromContainer,
  getManager,
  getMetadataArgsStorage,
  getMongoManager,
  getMongoRepository,
  getRepository,
  getSqljsManager,
  getTreeRepository,
  useContainer
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

typeorm/browser/index.js:
  (*!
   *)
*/
//# sourceMappingURL=typeorm.js.map
